<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PostgreSQL 中文网</title>
  
  <subtitle>francs&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://postgres.fun/"/>
  <updated>2019-01-08T00:38:59.709Z</updated>
  <id>https://postgres.fun/</id>
  
  <author>
    <name>francs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo: 添加Valine评论(邮件通知、评论列表头像)</title>
    <link href="https://postgres.fun/20190107095300.html"/>
    <id>https://postgres.fun/20190107095300.html</id>
    <published>2019-01-07T01:53:22.000Z</published>
    <updated>2019-01-08T00:38:59.709Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 博客和 Valine 模块部署有好几个月了，Valine 模块部署本身并不复杂，但部署后发现头像无法显示设置的图像，这个问题困扰了至少1个月，今天请教高手终于解决了这个问题，是时候好好总结下 Valine 模块的部署历程了。</p><p>之所以选择 Valine 模块，一方面因为 Valine 评论模块延续了Hexo模板简洁的风格，两者匹配得可谓天衣无缝，另一方面国内可选的评论模块有些已经不再支持，有些模块的UI各人不太喜欢。</p><h1 id="关于-Valine-模块"><a href="#关于-Valine-模块" class="headerlink" title="关于 Valine 模块"></a>关于 Valine 模块</h1><p><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 诞生于2017年8月7日，是一款基于 Leancloud 的快速、简洁且高效的无后端评论系统，支持但不限于静态博客。</p><p>具有以下特性：</p><ul><li>快速</li><li>安全</li><li>Emoji</li><li>无后端实现</li><li>MarkDown 全语法支持</li><li>轻量易用(~15kb gzipped)</li><li>文章阅读量统计 v1.2.0+</li></ul><h1 id="Valine-部署"><a href="#Valine-部署" class="headerlink" title="Valine 部署"></a>Valine 部署</h1><p>Valine 是基于 <a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud</a>的评论模块，评论数据都存储在 Leancloud 平台，因此需要先在 <a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud</a> 申请帐号。</p><h2 id="申请-Leancloud-帐号"><a href="#申请-Leancloud-帐号" class="headerlink" title="申请 Leancloud 帐号"></a>申请 Leancloud 帐号</h2><p>申请 Leancloud 步骤比较简单，首先进行 Leancloud 控制台创建应用(个人使用开发版)，之后获取应用的 App ID 和 App Key，后面配置博客的主题配置文件会用到。</p><h2 id="配置安全域名"><a href="#配置安全域名" class="headerlink" title="配置安全域名"></a>配置安全域名</h2><p>登录leancloud控制台，选择 设置 -&gt; 安全中心 -&gt;  Web 安全域名，这里设置成博客的域名地址和本地地址即可，如图:</p><p><img src="/images/safe_domain.png" alt=""></p><h2 id="配置主题配置文件"><a href="#配置主题配置文件" class="headerlink" title="配置主题配置文件"></a>配置主题配置文件</h2><p>修改博客主题配置文件 <code>/d/hexo/themes/next/_config.yml</code>，配置 Valine 的 enable、appid、appkey 参数，如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span>  <span class="string">your</span> <span class="string">leancloud</span> <span class="string">app</span> <span class="string">id</span></span><br><span class="line"><span class="attr">  appkey:</span> <span class="string">your</span> <span class="string">leancloud</span> <span class="string">app</span> <span class="string">key</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">true</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">留言</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span>   <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure><p>以上的 appid和appkey为本文开始在Leancloud创建应用的 App ID 和 App Key。</p><h2 id="评论模块验证"><a href="#评论模块验证" class="headerlink" title="评论模块验证"></a>评论模块验证</h2><p>之后访问博客，可以看到如下评论模块：</p><p><img src="/images/valine_comment_test.png" alt=""></p><p>并且可以留言评论了，以上就是 Valine 模块的基本部署过程。</p><h1 id="开启-Valine-评论邮件通知"><a href="#开启-Valine-评论邮件通知" class="headerlink" title="开启 Valine 评论邮件通知"></a>开启 Valine 评论邮件通知</h1><p>以上使用 Valine 模块实现了最基本的评论功能，但功能还需要完善，例如评论邮件通知、评论管理等功能，正好 <a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine Admin</a> 可以满足需求，Valine Admin 是Valine评论模块的扩展和增强。</p><p>这块内容主要参考 <a href="https://deserts.io/valine-admin-document/" target="_blank" rel="noopener">valine-admin-document</a>。</p><h2 id="云引擎”一键”部署"><a href="#云引擎”一键”部署" class="headerlink" title="云引擎”一键”部署"></a>云引擎”一键”部署</h2><p>在Leancloud云引擎设置界面，填写代码库并保存：<a href="https://github.com/DesertsP/Valine-Admin.git" target="_blank" rel="noopener">https://github.com/DesertsP/Valine-Admin.git</a>，如图:</p><p><img src="/images/valine_admin_code.png" alt=""></p><h2 id="设置-Web-二级域名"><a href="#设置-Web-二级域名" class="headerlink" title="设置 Web 二级域名"></a>设置 Web 二级域名</h2><p>Valine Admin 同时提供评论WEB管理后台，能方便的管理评论，例如标记为垃圾评论或删除评论。</p><p>在云引擎设置页面，设置Web二级域名，如下</p><p><img src="/images/valine_web_domain.png" alt=""></p><p>二级域名用于评论后台管理，这里设置为 <a href="https://postgres.leanapp.cn" target="_blank" rel="noopener">https://postgres.leanapp.cn</a> 。</p><p>之后访问出现登录界面，如图:</p><p><img src="/images/valine_admin_login.png" alt=""></p><p>用户名为leancloud的登录邮箱, 密码设置如下:</p><p><img src="/images/valine_admin_password.png" alt=""></p><p>点请示重置后Leancloud会给你发一封密码重置的邮件，这里设置的密码为评论管理WEB后台的密码。之前不知道密码存储在云引擎的user对象里，多亏了<a href="https://lruihao.cn/" target="_blank" rel="noopener">博採眾長</a>的指导。</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>设置环境变量，如下图:</p><p><img src="/images/valine_var_template.png" alt=""></p><p>以上参数需正确配置，我的参数配置如下:</p><p><img src="/images/valine_var_my.png" alt=""></p><p>配置完参数后，之后切换到云引擎页面点部署。</p><h2 id="验证评论邮件通知功能"><a href="#验证评论邮件通知功能" class="headerlink" title="验证评论邮件通知功能"></a>验证评论邮件通知功能</h2><p>假设我为博主且游客评论时填写了邮箱，以下场景能收到博客评论通知邮件:</p><p>1、用博主的帐号评论时，博主能收到通知邮件。<br>2、游客评论后，博主能收到通知邮件。<br>3、博主回复游客，游客能收到通知邮件。</p><h1 id="Valine-头像设置"><a href="#Valine-头像设置" class="headerlink" title="Valine 头像设置"></a>Valine 头像设置</h1><p>Valine 部署完成后使用了默认图像，查阅 <a href="https://valine.js.org/avatar.html" target="_blank" rel="noopener">Valine官网</a>后，了解到 Valine 使用的是 <a href="https://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>作为评论列表头像，评论时提供 Gravatar 注册的邮箱即可显示设置的头像。之后我在 Gravatar 修改头像一直没生效(gravatar.cat.net 有七天的缓存)，评论列表头像没生效问题折腾了一个月左右，早已超出了7天的缓存期，后来咨询了一位高手终于解决，这里记录下。</p><p>评论头像没有刷新的原因为：Valine 默认用的是第三方CDN，第一次请求的时候缓存源站的头像，当再请求的时候就不需要返回源站请求，可能这个第三方CDN缓存刷新时有问题导致有些用户刷新成功，有些用户没有刷新，可以通过更换其它CDN解决，这里设置成 Gravatar 的CDN。</p><h2 id="avatar-参数"><a href="#avatar-参数" class="headerlink" title="avatar 参数"></a>avatar 参数</h2><p>Valine 的 avatar 参数用来设置评论头像，avatar 参数可选值如下:</p><p><img src="/images/avatar_parameter.png" alt=""></p><p>我这里将 avatar 设置成空，表示使用的是默认的评论图像。</p><h2 id="Gravatar-设置"><a href="#Gravatar-设置" class="headerlink" title="Gravatar 设置"></a>Gravatar 设置</h2><p>登录 <a href="https://cn.gravatar.com/" target="_blank" rel="noopener">gravatar</a>，注册账号并设置头像，我的设置如下：</p><p><img src="/images/gravatar.png" alt=""></p><h2 id="Next-主题设置"><a href="#Next-主题设置" class="headerlink" title="Next 主题设置"></a>Next 主题设置</h2><p>主题配置文件增加 avatar_cdn 参数，如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span>  <span class="string">UK8DCa4kSCj0Th48U4nGPxrO-gzGzoHsz</span></span><br><span class="line"><span class="attr">  appkey:</span> <span class="string">gxPalmYtqejoIqRUifA1Lqg6</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">true</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">留言</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span>   <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line"><span class="attr">  avatar_cdn:</span> <span class="attr">https://www.gravatar.com/avatar/</span></span><br></pre></td></tr></table></figure><p>目前Valine的版本不支持 avatar_cdn 参数，这里手工加一个并设置成Gravatar的CDN。</p><p>之后修改Valine模板文件 <code>/d/hexo/themes/next/layout/_third-party/comments/valine.swig</code>，增加 <code>avatar_cnd</code>这行代码，如下:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//unpkg.com/valine/dist/Valine.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">    var GUEST = ['nick','mail','link'];</span></span><br><span class="line"><span class="xml">    var guest = '</span><span class="template-variable">&#123;&#123; theme.valine.guest_info &#125;&#125;</span><span class="xml">';</span></span><br><span class="line"><span class="xml">    guest = guest.split(',').filter(item=&gt;&#123;</span></span><br><span class="line"><span class="xml">      return GUEST.indexOf(item)&gt;-1;</span></span><br><span class="line"><span class="xml">    &#125;);</span></span><br><span class="line"><span class="xml">    new Valine(&#123;</span></span><br><span class="line"><span class="xml">        el: '#comments' ,</span></span><br><span class="line"><span class="xml">        verify: </span><span class="template-variable">&#123;&#123; theme.valine.verify &#125;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">        notify: </span><span class="template-variable">&#123;&#123; theme.valine.notify &#125;&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">        appId: '</span><span class="template-variable">&#123;&#123; theme.valine.appid &#125;&#125;</span><span class="xml">',</span></span><br><span class="line"><span class="xml">        appKey: '</span><span class="template-variable">&#123;&#123; theme.valine.appkey &#125;&#125;</span><span class="xml">',</span></span><br><span class="line"><span class="xml">        placeholder: '</span><span class="template-variable">&#123;&#123; theme.valine.placeholder &#125;&#125;</span><span class="xml">',</span></span><br><span class="line"><span class="xml">        avatar:'</span><span class="template-variable">&#123;&#123; theme.valine.avatar &#125;&#125;</span><span class="xml">',</span></span><br><span class="line"><span class="xml">        guest_info:guest,</span></span><br><span class="line"><span class="xml">        pageSize:'</span><span class="template-variable">&#123;&#123; theme.valine.pageSize &#125;&#125;</span><span class="xml">' || 10,</span></span><br><span class="line"><span class="xml">        avatar_cdn:'</span><span class="template-variable">&#123;&#123; theme.valine.avatar_cdn &#125;&#125;</span><span class="xml">',</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>评论头像终于刷新来了，如下图:</p><p><img src="/images/valine_ruolin.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://valine.js.org/" target="_blank" rel="noopener">valine</a></li><li><a href="https://deserts.io/valine-admin-document/" target="_blank" rel="noopener">Valine Admin 配置手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hexo 博客和 Valine 模块部署有好几个月了，Valine 模块部署本身并不复杂，但部署后发现头像无法显示设置的图像，这个问题困扰了至少1个月，今天请教高手终于解决了这个问题，是时候好好总结下 Valine 模块的部署历程了。&lt;/p&gt;
&lt;p&gt;之所以选择 Valine
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 2018 中国技术大会圆满举行</title>
    <link href="https://postgres.fun/20181219135100.html"/>
    <id>https://postgres.fun/20181219135100.html</id>
    <published>2018-12-19T05:51:47.000Z</published>
    <updated>2018-12-20T07:56:04.545Z</updated>
    
    <content type="html"><![CDATA[<p>“Postgres中国技术大会2018（大象会，第8届）”已于2018年12月15、16日在浙江吉利控股集团有限公司总部(杭州市滨江区江陵路1760号)举行。</p><p>大会由中国Postgres用户会（China Postgres User Group，简称：CPUG）主办，是一场汇聚各界PostgreSQL大拿、交流最新业界技术动态和真实应用案例的盛宴。 本次大会参会者、嘉宾共400余人，议题丰富。</p><p><img src="/images/pgconf2018.png" alt=""></p><p>本届大会的议题如下:</p><h1 id="主会场-–-12-15日"><a href="#主会场-–-12-15日" class="headerlink" title="主会场 – 12/15日"></a>主会场 – 12/15日</h1><ul><li>赖宝华_开源分布式NewSQL数据库CockroachDB架构及最佳实践</li><li>李海龙_Qunar的PostgreSQL运维实践</li><li>周正中_如何构建PostgreSQL大生态之我见</li><li>潘娟ApacheShardingSphere云架构演化</li><li>邵宗文_图数据库及应用场景</li><li>汪洋_PG之高可用特性、工具及架构设计</li><li>王昊Greenplum5智能运维管理实例及展望</li></ul><h1 id="主会场-–-12-16日"><a href="#主会场-–-12-16日" class="headerlink" title="主会场 – 12/16日"></a>主会场 – 12/16日</h1><ul><li>陈华军_citus在苏宁的大规模应用</li><li>梅白帆_PostGIS在传统行业中的应用简介</li><li>石勇虎_庖丁解牛之平安vacuum优化之路</li><li>唐建法MongoDB4.0_开创NoSQL＿+＿ACID新纪元</li><li>王帅_从Oracle到PostgreSQL的数据迁移</li><li>张启程_为什么我们抛弃MongoDB和MySQL，选择PgSQL</li><li>赵振平_PostgreSQL和Greenplum数据库故障排查</li><li>周飞_PG在Hellobike的应用</li></ul><h1 id="分会场1-–-12-15日"><a href="#分会场1-–-12-15日" class="headerlink" title="分会场1 – 12/15日"></a>分会场1 – 12/15日</h1><ul><li>陈河堆_PostgreSQL基于PaaS平台的高可用集群方案V3</li><li>董红禹SQLServer迁移PG经验分享</li><li>桑栎_PipelineDB体系结构和使用场景</li><li>杨杰PostgreSQL-FlashbackQuery实现与介绍</li></ul><h1 id="分会场1-–-12-16日"><a href="#分会场1-–-12-16日" class="headerlink" title="分会场1 – 12/16日"></a>分会场1 – 12/16日</h1><ul><li>曾文旌阿里云RDSfor_PostgreSQL在PostgreSQL功能和性能改进</li><li>樊文凯_ORACLE数据库和应用异构迁移最佳实践</li><li>冯慧媛_GIS地理信息-postgres在时空大数据方面的应用</li><li>黄晓涛_通过FDW对大容量非结构化文件的管理和访问</li><li>赖思超PostgreSQL10hash索引的WAL日志修改版final</li><li>刘成伟_oracle到Postgres数据库迁移工具</li><li>陶征霖_新一代数据仓库OushuDB架构剖析</li></ul><h1 id="分会场2-–-12-15日"><a href="#分会场2-–-12-15日" class="headerlink" title="分会场2 – 12/15日"></a>分会场2 – 12/15日</h1><ul><li>党宏博_亚信AntDB在业务驱动下的创新-v0.2</li><li>马鹏玮_以标准推动数据库新技术的快速落地</li><li>权宗亮_基于odyssey连接池实现企业级PostgreSQL数据分布中间件</li><li>肖斐_PostgreSQL数据库时空引擎Ganos</li></ul><h1 id="分会场2-–-12-16日"><a href="#分会场2-–-12-16日" class="headerlink" title="分会场2 – 12/16日"></a>分会场2 – 12/16日</h1><ul><li>胡森_TBase分布式架构以及OLAP性能优化</li><li>刘东明_PostgreSQL并行查询</li><li>余鹏_gogudb—基于FDW实现的PG分库分表插件</li></ul><h1 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h1><p>本次大会的资料可在PosgreSQL中文社区官网下载  <a href="http://postgres.cn/v2/news/viewone/1/377" target="_blank" rel="noopener">http://postgres.cn/v2/news/viewone/1/377</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“Postgres中国技术大会2018（大象会，第8届）”已于2018年12月15、16日在浙江吉利控股集团有限公司总部(杭州市滨江区江陵路1760号)举行。&lt;/p&gt;
&lt;p&gt;大会由中国Postgres用户会（China Postgres User Group，简称：CPUG
      
    
    </summary>
    
      <category term="PG大会活动" scheme="https://postgres.fun/categories/PG%E5%A4%A7%E4%BC%9A%E6%B4%BB%E5%8A%A8/"/>
    
    
      <category term="PostgreSQL活动" scheme="https://postgres.fun/tags/PostgreSQL%E6%B4%BB%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL何以支持丰富的NoSQL特性?</title>
    <link href="https://postgres.fun/20181218101700.html"/>
    <id>https://postgres.fun/20181218101700.html</id>
    <published>2018-12-18T02:17:26.000Z</published>
    <updated>2018-12-20T00:26:56.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p><a href="https://postgres.fun/20181214145600.html">上篇文章</a> 介绍了PostgreSQL的典型高级SQL特性，PostgreSQL不仅是关系型数据库，同时支持丰富的NoSQL特性，本文将从 <a href="https://item.jd.com/12405774.html" target="_blank" rel="noopener">《PostgreSQL实战》</a> 一书的“ 第9章 PostgreSQL的NoSQL特性”中摘选部分内容介绍。</p><p>本文主要包含以下三部分内容:</p><ul><li>PostgreSQL的 JSON和JSONB数据类型简介</li><li>JSON与JSONB读写性能测试</li><li>PostgreSQL全文检索支持JSON和JSONB（PosgreSQL 10 新特性）</li></ul><h1 id="二、PostgreSQL的JSON和JSONB数据类型"><a href="#二、PostgreSQL的JSON和JSONB数据类型" class="headerlink" title="二、PostgreSQL的JSON和JSONB数据类型"></a>二、PostgreSQL的JSON和JSONB数据类型</h1><p>PostgreSQL支持非关系数据类型json (JavaScript Object Notation)，本节介绍json类型、json与jsonb差异、json与jsonb操作符和函数，以及jsonb键值的追加、删除、更新。</p><h2 id="JSON类型简介"><a href="#JSON类型简介" class="headerlink" title="JSON类型简介"></a>JSON类型简介</h2><p>PotgreSQL早在9.2版本已经提供了json类型，并且随着大版本的演进，PostgreSQL对json的支持趋于完善，例如提供更多的json函数和操作符方便应用开发，一个简单的json类型例子如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT <span class="emphasis">'&#123;"a":1,"b":2&#125;'</span>::json;</span><br><span class="line"><span class="code">     json</span></span><br><span class="line">---------------</span><br><span class="line"><span class="code"> &#123;"a":1,"b":2&#125;</span></span><br></pre></td></tr></table></figure></p><p>为了更好演示json类型，接下来创建一张表，如下所示：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; CREATE <span class="keyword">TABLE</span> test_json1 <span class="comment">(id serial primary key,name json)</span>;</span><br><span class="line">CREATE <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure></p><p>以上示例定义字段name为json类型，插入表数据，如下所示：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; INSERT INTO test_json1 (<span class="name">name</span>)</span><br><span class="line">VALUES ('&#123;<span class="string">"col1"</span>:<span class="number">1</span>,<span class="string">"col2"</span>:<span class="string">"francs"</span>,<span class="string">"col3"</span>:<span class="string">"male"</span>&#125;')<span class="comment">;</span></span><br><span class="line">INSERT <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mydb=&gt; INSERT INTO test_json1 (<span class="name">name</span>)</span><br><span class="line">VALUES ('&#123;<span class="string">"col1"</span>:<span class="number">2</span>,<span class="string">"col2"</span>:<span class="string">"fp"</span>,<span class="string">"col3"</span>:<span class="string">"female"</span>&#125;')<span class="comment">;</span></span><br><span class="line">INSERT <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>查询表test_json1数据：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM test_json1;</span><br><span class="line"> id <span class="string">|                   name</span></span><br><span class="line">----+------------------------------------------</span><br><span class="line">  <span class="number">1</span> <span class="string">| &#123;"</span>col1<span class="string">":1,"</span>col2<span class="string">":"</span>francs<span class="string">","</span>col3<span class="string">":"</span>male<span class="string">"&#125;</span></span><br><span class="line">  <span class="number">2</span> <span class="string">| &#123;"</span>col1<span class="string">":2,"</span>col2<span class="string">":"</span>fp<span class="string">","</span>col3<span class="string">":"</span>female<span class="string">"&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="查询JSON数据"><a href="#查询JSON数据" class="headerlink" title="查询JSON数据"></a>查询JSON数据</h2><p>通过-&gt;操作符可以查询json数据的键值，如下所示：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="built_in">SELECT</span>  <span class="built_in">name</span> -&gt; <span class="string">'col2'</span> <span class="keyword">FROM</span> test_json1 WHERE id=<span class="number">1</span>;</span><br><span class="line"> ?column?</span><br><span class="line">----------</span><br><span class="line"> <span class="string">"francs"</span></span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>如果想以文本格式返回json字段键值可以使用-&gt;&gt;符，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span>  name -&gt;&gt; <span class="string">'col2'</span> <span class="keyword">FROM</span> test_json1 <span class="keyword">WHERE</span> id=<span class="number">1</span>;</span><br><span class="line"> ?column?</span><br><span class="line">----------</span><br><span class="line"> francs</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><h2 id="JSONB与JSON差异"><a href="#JSONB与JSON差异" class="headerlink" title="JSONB与JSON差异"></a>JSONB与JSON差异</h2><p>PostgreSQL支持两种JSON数据类型：json和jsonb，两种类型在使用上几乎完全相同，两者主要区别为以下：json存储格式为文本而jsonb存储格式为二进制 ，由于存储格式的不同使得两种json数据类型的处理效率不一样，json类型以文本存储并且存储的内容和输入数据一样，当检索json数据时必须重新解析，而jsonb以二进制形式存储已解析好的数据，当检索jsonb数据时不需要重新解析，因此json写入比jsonb快，但检索比jsonb慢，后面会通过测试验证两者读写性能差异。<br>除了上述介绍的区别之外，json与jsonb在使用过程中还存在差异，例如jsonb输出的键的顺序和输入不一样，如下所示：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> '&#123;<span class="string">"bar"</span>: <span class="string">"baz"</span>, <span class="string">"balance"</span>: <span class="number">7.77</span>, <span class="string">"active"</span>:<span class="literal">false</span>&#125;'::jsonb;</span><br><span class="line">                      jsonb</span><br><span class="line"><span class="comment">--------------------------------------------------</span></span><br><span class="line"> &#123;<span class="string">"bar"</span>: <span class="string">"baz"</span>, <span class="string">"active"</span>: <span class="literal">false</span>, <span class="string">"balance"</span>: <span class="number">7.77</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>而json的输出键的顺序和输入完全一样，如下所示：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> '&#123;<span class="string">"bar"</span>: <span class="string">"baz"</span>, <span class="string">"balance"</span>: <span class="number">7.77</span>, <span class="string">"active"</span>:<span class="literal">false</span>&#125;'::json;</span><br><span class="line">                      json</span><br><span class="line"><span class="comment">-------------------------------------------------</span></span><br><span class="line"> &#123;<span class="string">"bar"</span>: <span class="string">"baz"</span>, <span class="string">"balance"</span>: <span class="number">7.77</span>, <span class="string">"active"</span>:<span class="literal">false</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>另外，jsonb类型会去掉输入数据中键值的空格，如下所示：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> ' &#123;<span class="string">"id"</span>:<span class="number">1</span>,    <span class="string">"name"</span>:<span class="string">"francs"</span>&#125;'::jsonb;</span><br><span class="line">            jsonb</span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"> &#123;<span class="string">"id"</span>: <span class="number">1</span>, <span class="string">"name"</span>: <span class="string">"francs"</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>上例中id键与name键输入时是有空格的，输出显示空格键被删除，而json的输出和输入一样，不会删掉空格键：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> ' &#123;<span class="string">"id"</span>:<span class="number">1</span>,    <span class="string">"name"</span>:<span class="string">"francs"</span>&#125;'::json;</span><br><span class="line">             json</span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line">  &#123;<span class="string">"id"</span>:<span class="number">1</span>,    <span class="string">"name"</span>:<span class="string">"francs"</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>另外，jsonb会删除重复的键，仅保留最后一个，如下所示：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT ' &#123;<span class="string">"id"</span>:1,</span><br><span class="line"><span class="string">"name"</span>:<span class="string">"francs"</span>,</span><br><span class="line"><span class="string">"remark"</span>:<span class="string">"a good guy!"</span>,</span><br><span class="line"><span class="string">"name"</span>:<span class="string">"test"</span></span><br><span class="line"><span class="section">&#125;'::jsonb;</span></span><br><span class="line">                       jsonb</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> &#123;<span class="string">"id"</span>: 1, <span class="string">"name"</span>: <span class="string">"test"</span>, <span class="string">"remark"</span>: <span class="string">"a good guy!"</span>&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>上面name键重复，仅保留最后一个name键的值，而json数据类型会保留重复的键值。<br>相比json大多数应用场景建议使用jsonb，除非有特殊的需求，比如对json的键顺序有特殊的要求。</p><h2 id="JSONB与JSON操作符"><a href="#JSONB与JSON操作符" class="headerlink" title="JSONB与JSON操作符"></a>JSONB与JSON操作符</h2><p>PostgreSQL支持丰富的JSONB和JSON的操作符，举例如下：<br>以文本格式返回json类型的字段键值可以使用-&gt;&gt;符，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span>  name -&gt;&gt; <span class="string">'col2'</span> <span class="keyword">FROM</span> test_json1 <span class="keyword">WHERE</span> id=<span class="number">1</span>;</span><br><span class="line"> ?column?</span><br><span class="line">----------</span><br><span class="line"> francs</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>字符串是否作为顶层键值，如下所示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT <span class="emphasis">'&#123;"a":1, "b":2&#125;'</span>::jsonb ? <span class="emphasis">'a'</span>;</span><br><span class="line"><span class="code"> ?column?</span></span><br><span class="line">----------</span><br><span class="line"><span class="code"> t</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>删除json数据的键/值，如下所示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT <span class="emphasis">'&#123;"a":1, "b":2&#125;'</span>::jsonb - <span class="emphasis">'a'</span>;</span><br><span class="line"><span class="code"> ?column?</span></span><br><span class="line">----------</span><br><span class="line"><span class="code"> &#123;"b": 2&#125;</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><h2 id="JSONB与JSON函数"><a href="#JSONB与JSON函数" class="headerlink" title="JSONB与JSON函数"></a>JSONB与JSON函数</h2><p>json与jsonb相关的函数非常丰富，举例如下：<br>扩展最外层的json对象成为一组键/值结果集，如下所示：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> SELECT * FROM json_each(<span class="name">'</span>&#123;<span class="string">"a"</span>:<span class="string">"foo"</span>, <span class="string">"b"</span>:<span class="string">"bar"</span>&#125;')<span class="comment">;</span></span></span><br><span class="line"> key | value</span><br><span class="line">-----+-------</span><br><span class="line"> a   | "foo"</span><br><span class="line"> b   | "bar"</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></p><p>以文本形式返回结果，如下所示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM json<span class="emphasis">_each_</span>text(<span class="emphasis">'&#123;"a":"foo", "b":"bar"&#125;'</span>);</span><br><span class="line"><span class="code"> key | value</span></span><br><span class="line">-----+-------</span><br><span class="line"><span class="code"> a   | foo</span></span><br><span class="line"><span class="code"> b   | bar</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></p><p>一个非常重要的函数为row_to_json()函数，能够将行作为json对象返回，此函数常用来生成json测试数据，比如将一个普通表转换成json类型表：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; SELECT * <span class="keyword">FROM</span> test_copy WHERE <span class="attribute">id</span>=1;</span><br><span class="line"> id | name</span><br><span class="line">----+------</span><br><span class="line">  1 | a</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; SELECT row_to_json(test_copy) <span class="keyword">FROM</span> test_copy WHERE <span class="attribute">id</span>=1;</span><br><span class="line">     row_to_json</span><br><span class="line">---------------------</span><br><span class="line"> &#123;<span class="string">"id"</span>:1,<span class="string">"name"</span>:<span class="string">"a"</span>&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>返回最外层的json对像中的键的集合，如下所示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM json<span class="emphasis">_object_</span>keys(<span class="emphasis">'&#123;"a":"foo", "b":"bar"&#125;'</span>);</span><br><span class="line"><span class="code"> json_object_keys</span></span><br><span class="line">------------------</span><br><span class="line"><span class="code"> a</span></span><br><span class="line"><span class="code"> b</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></p><h2 id="jsonb键-值的追加、删除、更新"><a href="#jsonb键-值的追加、删除、更新" class="headerlink" title="jsonb键/值的追加、删除、更新"></a>jsonb键/值的追加、删除、更新</h2><p>jsonb键/值追加可通过||操作符，如下增加sex键/值：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> '&#123;<span class="string">"name"</span>:<span class="string">"francs"</span>,<span class="string">"age"</span>:<span class="string">"31"</span>&#125;'::jsonb ||</span><br><span class="line">'&#123;<span class="string">"sex"</span>:<span class="string">"male"</span>&#125;'::jsonb;</span><br><span class="line">                    ?column?</span><br><span class="line"><span class="comment">------------------------------------------------</span></span><br><span class="line"> &#123;<span class="string">"age"</span>: <span class="string">"31"</span>, <span class="string">"sex"</span>: <span class="string">"male"</span>, <span class="string">"name"</span>: <span class="string">"francs"</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>jsonb键/值的删除有两种方法，一种是通过操作符号-删除，另一种通过操作符#-删除指定键/值。<br>通过操作符号-删除键/值如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT <span class="emphasis">'&#123;"name": "James", "email": "james@localhost"&#125;'</span>::jsonb</span><br><span class="line"><span class="code"> - 'email';</span></span><br><span class="line"><span class="code">     ?column?</span></span><br><span class="line">-------------------</span><br><span class="line"><span class="code"> &#123;"name": "James"&#125;</span></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">mydb=&gt; SELECT <span class="emphasis">'["red","green","blue"]'</span>::jsonb - 0;</span><br><span class="line"><span class="code">     ?column?</span></span><br><span class="line">-------------------</span><br><span class="line"><span class="code"> ["green", "blue"]</span></span><br></pre></td></tr></table></figure></p><p>第二种方法是通过操作符#-删除指定键/值，通常用于有嵌套json数据删除的场景，如下删除嵌套contact中的fax键/值：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> SELECT '&#123;<span class="string">"name"</span>: <span class="string">"James"</span>, <span class="string">"contact"</span>: &#123;<span class="string">"phone"</span>: <span class="string">"01234 567890"</span>, <span class="string">"fax"</span>: <span class="string">"01987 543210"</span>&#125;&#125;'<span class="symbol">::jsonb</span> #- '&#123;contact,fax&#125;'<span class="symbol">::text</span>[]<span class="comment">;</span></span></span><br><span class="line">                        ?column?</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"> &#123;"name": "James", "contact": &#123;"phone": "01234 567890"&#125;&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>删除嵌套aliases中的位置为1的键/值，如下所示：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> SELECT '&#123;<span class="string">"name"</span>: <span class="string">"James"</span>, <span class="string">"aliases"</span>: [<span class="string">"Jamie"</span>,<span class="string">"The Jamester"</span>,<span class="string">"J Man"</span>]&#125;'<span class="symbol">::jsonb</span> #- '&#123;aliases,<span class="number">1</span>&#125;'<span class="symbol">::text</span>[]<span class="comment">;</span></span></span><br><span class="line">                     ?column?</span><br><span class="line">--------------------------------------------------</span><br><span class="line"> &#123;"name": "James", "aliases": ["Jamie", "J Man"]&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>键/值的更新也有两种方式，第一种方式为||操作符，||操作符可以连接json键，也可覆盖重复的键值，如下修改age键的值：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> '&#123;<span class="string">"name"</span>:<span class="string">"francs"</span>,<span class="string">"age"</span>:<span class="string">"31"</span>&#125;'::jsonb ||</span><br><span class="line">'&#123;<span class="string">"age"</span>:<span class="string">"32"</span>&#125;'::jsonb;</span><br><span class="line">            ?column?</span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"> &#123;<span class="string">"age"</span>: <span class="string">"32"</span>, <span class="string">"name"</span>: <span class="string">"francs"</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>第二种方式是通过jsonb_set函数，语法如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jsonb_set(target </span><span class="keyword">jsonb, </span>path text[], new_value <span class="keyword">jsonb[, </span>create_missing <span class="keyword">boolean])</span></span><br></pre></td></tr></table></figure></p><p>target指源jsonb数据，path指路径，new_value指更新后的键值，create_missing 值为 true表示如果键不存在则添加，create_missing 值为 false表示如果键不存在则不添加，示例如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> jsonb_set('&#123;<span class="string">"name"</span>:<span class="string">"francs"</span>,<span class="string">"age"</span>:<span class="string">"31"</span>&#125;'::jsonb,'&#123;age&#125;<span class="string">','</span><span class="string">"32"</span>'::jsonb,<span class="literal">false</span>);</span><br><span class="line">            jsonb_set</span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"> &#123;<span class="string">"age"</span>: <span class="string">"32"</span>, <span class="string">"name"</span>: <span class="string">"francs"</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">SELECT</span> jsonb_set('&#123;<span class="string">"name"</span>:<span class="string">"francs"</span>,<span class="string">"age"</span>:<span class="string">"31"</span>&#125;'::jsonb,'&#123;sex&#125;<span class="string">','</span><span class="string">"male"</span>'::jsonb,<span class="literal">true</span>);</span><br><span class="line">                   jsonb_set</span><br><span class="line"><span class="comment">------------------------------------------------</span></span><br><span class="line"> &#123;<span class="string">"age"</span>: <span class="string">"31"</span>, <span class="string">"sex"</span>: <span class="string">"male"</span>, <span class="string">"name"</span>: <span class="string">"francs"</span>&#125;</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><h2 id="给JSONB类型创建索引"><a href="#给JSONB类型创建索引" class="headerlink" title="给JSONB类型创建索引"></a>给JSONB类型创建索引</h2><p>这一小节介绍给jsonb数据类型创建索引，jsonb数据类型支持GIN索引，为了便于说明，假如一个json字段内容如下，并且以jsonb格式存储。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"user_id"</span>: <span class="number">1440933</span>,</span><br><span class="line">  <span class="attr">"user_name"</span>: <span class="string">"1_francs"</span>,</span><br><span class="line">  <span class="attr">"create_time"</span>: <span class="string">"2017-08-03 16:22:05.528432+08"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如存储以上jsonb数据的字段名为user_info，表名为tbl_user_jsonb，在user_info字段上创建GIN索引语法如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_gin <span class="keyword">ON</span> tbl_user_jsonb <span class="keyword">USING</span> gin(user_info);</span><br></pre></td></tr></table></figure></p><p>jsonb上的GIN索引支持@&gt;、?、 ?&amp;、?|操作符，例如以下查询将会使用索引。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_user_jsonb <span class="keyword">WHERE</span> user_info @&gt; <span class="string">'&#123;"user_name": "1_frans"&#125;'</span></span><br></pre></td></tr></table></figure></p><p>但是以下基于jsonb键值的查询不会走索引idx_gin，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_user_jsonb <span class="keyword">WHERE</span> user_info-&gt;&gt;<span class="string">'user_name'</span>= <span class="string">'1_francs'</span>;</span><br></pre></td></tr></table></figure></p><p>如果要想提升基于jsonb类型的键值检索效率，可以在jsonb数据类型对应的键值上创建索引，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_gin_user_infob_user_name <span class="keyword">ON</span> tbl_user_jsonb <span class="keyword">USING</span> btree</span><br><span class="line">((user_info -&gt;&gt; <span class="string">'user_name'</span>));</span><br></pre></td></tr></table></figure></p><p>创建以上索引后，上述根据user_info-&gt;&gt;’user_name’键值查询的SQL将会走索引。</p><h1 id="三、JSON与JSONB读写性能测试"><a href="#三、JSON与JSONB读写性能测试" class="headerlink" title="三、JSON与JSONB读写性能测试"></a>三、JSON与JSONB读写性能测试</h1><p>上一小节介绍了jsonb数据类型索引创建相关内容，本小节将对json、jsonb读写性能进行简单对比，在第3章数据类型章节中介绍json、jsonb数据类型时提到了两者读写性能的差异，主要表现为json写入时比jsonb快，但检索时比jsonb慢，主要原因为：json存储格式为文本而jsonb存储格式为二进制，存储格式的不同使得两种json数据类型的处理效率不一样，json类型存储的内容和输入数据一样，当检索json数据时必须重新解析，而jsonb以二进制形式存储已解析好的数据，当检索jsonb数据时不需要重新解析。</p><h2 id="构建JSON、JSONB测试表"><a href="#构建JSON、JSONB测试表" class="headerlink" title="构建JSON、JSONB测试表"></a>构建JSON、JSONB测试表</h2><p>下面通过一个简单的例子测试下json、jsonb的读写性能差异，计划创建以下三张表：</p><ul><li>user_ini：基础数据表，并插入200万测试数据；</li><li>tbl_user_json:： json 数据类型表，200万数据；</li><li>tbl_user_jsonb： jsonb 数据类型表，200万数据；</li></ul><p>首先创建user_ini表并插入200万测试数据，如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> TABLE user_ini(id int4 ,user_id int8, user_name character</span><br><span class="line">varying(<span class="number">64</span>),create_time timestamp(<span class="number">6</span>) <span class="keyword">with</span> time zone default</span><br><span class="line">clock_timestamp());</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_ini(id,user_id,user_name)</span><br><span class="line"><span class="keyword">SELECT</span> r,<span class="built_in">round</span>(<span class="built_in">random</span>()*<span class="number">2000000</span>), r || <span class="string">'_francs'</span></span><br><span class="line"><span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">2000000</span>) <span class="keyword">as</span> r;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">2000000</span></span><br></pre></td></tr></table></figure></p><p>计划使用user_ini表数据生成json、jsonb数据，创建user_ini_json、user_ini_jsonb表，如下所示：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; CREATE <span class="keyword">TABLE</span> tbl_user_json(id <span class="comment">serial, user_info json)</span>;</span><br><span class="line">CREATE <span class="keyword">TABLE</span></span><br><span class="line">mydb=&gt; CREATE <span class="keyword">TABLE</span> tbl_user_jsonb(id <span class="comment">serial, user_info jsonb)</span>;</span><br><span class="line">CREATE <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure></p><h2 id="JSON与JSONB表写性能测试"><a href="#JSON与JSONB表写性能测试" class="headerlink" title="JSON与JSONB表写性能测试"></a>JSON与JSONB表写性能测试</h2><p>根据user_ini数据通过row_to_json函数向表user_ini_json插入200万json数据，如下：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; \timing</span><br><span class="line">Timing is on.</span><br><span class="line"></span><br><span class="line">mydb=&gt; INSERT INTO tbl_user_json(user_info) SELECT row_to_json(user_ini)</span><br><span class="line">FROM user_ini;</span><br><span class="line">INSERT 0 2000000</span><br><span class="line"><span class="keyword">Time:</span> 13825.974 ms (00:13.826)</span><br></pre></td></tr></table></figure></p><p>从以上结果看出tbl_user_json插入200万数据花了13秒左右；接着根据user_ini表数据生成200万jsonb数据并插入表tbl_user_jsonb，如下：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; INSERT INTO tbl_user_jsonb(user_info)</span><br><span class="line"> SELECT row_to_json(user_ini)::jsonb FROM user_ini;</span><br><span class="line">INSERT 0 2000000</span><br><span class="line"><span class="keyword">Time:</span> 20756.993 ms (00:20.757)</span><br></pre></td></tr></table></figure></p><p>从以上看出tbl_user_jsonb表插入200万jsonb数据花了20秒左右，正好验证了json数据写入比jsonb快，比较两表占用空间大小，如下所示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; \dt+ tbl_user_json</span><br><span class="line">                       List of relations</span><br><span class="line"> Schema |     Name      |<span class="built_in"> Type </span> | Owner  |  Size  | Description</span><br><span class="line">--------+---------------+-------+--------+--------+-------------</span><br><span class="line"> pguser | tbl_user_json | table | pguser | 281 MB |</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; \dt+ tbl_user_jsonb</span><br><span class="line">                        List of relations</span><br><span class="line"> Schema |      Name      |<span class="built_in"> Type </span> | Owner  |  Size  | Description</span><br><span class="line">--------+----------------+-------+--------+--------+-------------</span><br><span class="line"> pguser | tbl_user_jsonb | table | pguser | 333 MB |</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>从占用空间来看，同样的数据量jsonb数据类型占用空间比json稍大。</p><p>查询tbl_user_json表的一条测试数据，如下：：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM tbl<span class="emphasis">_user_</span>json LIMIT 1;</span><br><span class="line"><span class="code">   id    |                                             user_info</span></span><br><span class="line">---------+------------------------------------------------------------------------------------</span><br><span class="line"><span class="code"> 2000001 | &#123;"id":1,"user_id":1182883,"user_name":"1_francs","create_time":"2017-08-03T20:59:27.42741+08:00"&#125;</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><h2 id="JSON与JSONB表读性能测试"><a href="#JSON与JSONB表读性能测试" class="headerlink" title="JSON与JSONB表读性能测试"></a>JSON与JSONB表读性能测试</h2><p>对于json、jsonb读性能测试我们选择基于json、jsonb键值查询的场景，例如，根据user_info字段的user_name键的值查询，如下所示：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="keyword">SELECT</span> * FROM tbl_user_jsonb <span class="keyword">WHERE</span> user_info-&gt;&gt;<span class="string">'user_name'</span>=<span class="string">'1_francs'</span>;</span><br><span class="line">                          QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Seq Scan <span class="keyword">on</span> tbl_user_jsonb  (cost=<span class="number">0.00</span>.<span class="number">.72859</span><span class="number">.90</span> <span class="keyword">rows</span>=<span class="number">10042</span> width=<span class="number">143</span>) (actual time=<span class="number">0.023</span>.<span class="number">.524</span><span class="number">.843</span> <span class="keyword">rows</span>=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   Filter: ((user_info -&gt;&gt; <span class="string">'user_name'</span><span class="type">::text</span>) = <span class="string">'1_francs'</span><span class="type">::text</span>)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Filter: <span class="number">1999999</span></span><br><span class="line"> Planning time: <span class="number">0.091</span> ms</span><br><span class="line"> Execution time: <span class="number">524.876</span> ms</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure></p><p>上述SQL执行时间为524毫秒左右，基于user_info字段的user_name键值创建btree索引如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_jsonb <span class="keyword">ON</span> tbl_user_jsonb <span class="keyword">USING</span> btree</span><br><span class="line">((user_info-&gt;&gt;<span class="string">'user_name'</span>));</span><br></pre></td></tr></table></figure></p><p>再次执行上述查询，如下所示：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mydb</span>=&gt; EXPLAIN ANALYZE SELECT * FROM tbl_user_jsonb WHERE user_info-&gt;</span>&gt;<span class="string">'user_name'</span>=<span class="string">'1_francs'</span>;</span><br><span class="line">                                   QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan on tbl_user_jsonb  (cost=<span class="number">155.93</span>..<span class="number">14113.93</span> rows=<span class="number">10000</span> width=<span class="number">143</span>) (actual <span class="built_in">time</span>=<span class="number">0.027</span>..<span class="number">0.027</span> rows=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   R<span class="function"><span class="title">echeck</span> Cond: ((user_info -&gt;</span>&gt; <span class="string">'user_name'</span>::<span class="keyword">text</span>) = <span class="string">'1_francs'</span>::<span class="keyword">text</span>)</span><br><span class="line">   Heap Blocks: exact=<span class="number">1</span></span><br><span class="line">   -&gt;  Bitmap Index Scan on idx_jsonb  (cost=<span class="number">0.00</span>..<span class="number">153.43</span> rows=<span class="number">10000</span> width=<span class="number">0</span>) (actual <span class="built_in">time</span>=<span class="number">0.021</span>..<span class="number">0.021</span> rows=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">         I<span class="function"><span class="title">ndex</span> Cond: ((user_info -&gt;</span>&gt; <span class="string">'user_name'</span>::<span class="keyword">text</span>) = <span class="string">'1_francs'</span>::<span class="keyword">text</span>)</span><br><span class="line"> Planning <span class="built_in">time</span>: <span class="number">0.091</span> ms</span><br><span class="line"> Execution <span class="built_in">time</span>: <span class="number">0.060</span> ms</span><br><span class="line">(<span class="number">7</span> rows)</span><br></pre></td></tr></table></figure></p><p>根据上述执行计划看出走了索引，并且SQL时间下降到0.060ms。为更好的对比tbl_user_json、tbl_user_jsonb表基于键值查询的效率，计划根据user_info字段id键进行范围扫描对比性能，创建索引如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_gin_user_info_id <span class="keyword">ON</span> tbl_user_json <span class="keyword">USING</span> btree</span><br><span class="line">(((user_info -&gt;&gt; <span class="string">'id'</span>)::integer));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_gin_user_infob_id <span class="keyword">ON</span> tbl_user_jsonb <span class="keyword">USING</span> btree</span><br><span class="line">(((user_info -&gt;&gt; <span class="string">'id'</span>)::integer));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>索引创建后，查询tbl_user_json表如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mydb</span>=&gt; EXPLAIN ANALYZE SELECT id,user_info-&gt;</span><span class="string">'id'</span>,<span class="function"><span class="title">user_info</span>-&gt;</span><span class="string">'user_name'</span></span><br><span class="line"> FROM tbl_user_json</span><br><span class="line">WHERE (<span class="function"><span class="title">user_info</span>-&gt;</span>&gt;<span class="string">'id'</span>)::<span class="function"><span class="title">int4</span>&gt;1 AND (user_info-&gt;</span>&gt;<span class="string">'id'</span>)::int4&lt;<span class="number">10000</span>;</span><br><span class="line">                               QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan on tbl_user_json  (cost=<span class="number">166.30</span>..<span class="number">14178.17</span> rows=<span class="number">10329</span> width=<span class="number">68</span>) (actual <span class="built_in">time</span>=<span class="number">1.167</span>..<span class="number">26.534</span> rows=<span class="number">9998</span> loops=<span class="number">1</span>)</span><br><span class="line">   R<span class="function"><span class="title">echeck</span> Cond: ((((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="function"><span class="title">text</span>))::<span class="keyword">integer</span> &gt; 1) AND (((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="keyword">text</span>))::<span class="keyword">integer</span> &lt; <span class="number">10000</span>))</span><br><span class="line">   Heap Blocks: exact=<span class="number">338</span></span><br><span class="line">   -&gt;  Bitmap Index Scan on idx_gin_user_info_id  (cost=<span class="number">0.00</span>..<span class="number">163.72</span> rows=<span class="number">10329</span> width=<span class="number">0</span>) (actual <span class="built_in">time</span>=<span class="number">1.110</span>..<span class="number">1.110</span> rows=<span class="number">19996</span> loops=</span><br><span class="line"><span class="number">1</span>)</span><br><span class="line">         I<span class="function"><span class="title">ndex</span> Cond: ((((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="function"><span class="title">text</span>))::<span class="keyword">integer</span> &gt; 1) AND (((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="keyword">text</span>))::<span class="keyword">integer</span> &lt; <span class="number">10000</span>))</span><br><span class="line"> Planning <span class="built_in">time</span>: <span class="number">0.094</span> ms</span><br><span class="line"> Execution <span class="built_in">time</span>: <span class="number">27.092</span> ms</span><br><span class="line">(<span class="number">7</span> rows)</span><br></pre></td></tr></table></figure></p><p>根据以上看出，查询表tbl_user_json的user_info字段id键值在1到10000范围内的记录走了索引，并且执行时间为27.092毫秒，接着测试tbl_user_jsonb表同样SQL的检索性能，如下所示：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mydb</span>=&gt; EXPLAIN ANALYZE SELECT id,user_info-&gt;</span><span class="string">'id'</span>,<span class="function"><span class="title">user_info</span>-&gt;</span><span class="string">'user_name'</span></span><br><span class="line"> FROM tbl_user_jsonb</span><br><span class="line">WHERE (<span class="function"><span class="title">user_info</span>-&gt;</span>&gt;<span class="string">'id'</span>)::<span class="function"><span class="title">int4</span>&gt;1 AND (user_info-&gt;</span>&gt;<span class="string">'id'</span>)::int4&lt;<span class="number">10000</span>;</span><br><span class="line">                        QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan on tbl_user_jsonb  (cost=<span class="number">158.93</span>..<span class="number">14316.93</span> rows=<span class="number">10000</span> width=<span class="number">68</span>) (actual <span class="built_in">time</span>=<span class="number">1.140</span>..<span class="number">8.116</span> rows=<span class="number">9998</span> loops=<span class="number">1</span>)</span><br><span class="line">   R<span class="function"><span class="title">echeck</span> Cond: ((((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="function"><span class="title">text</span>))::<span class="keyword">integer</span> &gt; 1) AND (((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="keyword">text</span>))::<span class="keyword">integer</span> &lt; <span class="number">10000</span>))</span><br><span class="line">   Heap Blocks: exact=<span class="number">393</span></span><br><span class="line">   -&gt;  Bitmap Index Scan on idx_gin_user_infob_id  (cost=<span class="number">0.00</span>..<span class="number">156.43</span> rows=<span class="number">10000</span> width=<span class="number">0</span>) (actual <span class="built_in">time</span>=<span class="number">1.058</span>..<span class="number">1.058</span> rows=<span class="number">18992</span> loops</span><br><span class="line">=<span class="number">1</span>)</span><br><span class="line">         I<span class="function"><span class="title">ndex</span> Cond: ((((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="function"><span class="title">text</span>))::<span class="keyword">integer</span> &gt; 1) AND (((user_info -&gt;</span>&gt; <span class="string">'id'</span>::<span class="keyword">text</span>))::<span class="keyword">integer</span> &lt; <span class="number">10000</span>))</span><br><span class="line"> Planning <span class="built_in">time</span>: <span class="number">0.104</span> ms</span><br><span class="line"> Execution <span class="built_in">time</span>: <span class="number">8.656</span> ms</span><br><span class="line">(<span class="number">7</span> rows)</span><br></pre></td></tr></table></figure></p><p>根据以上看出，查询表tbl_user_jsonb的user_info字段id键值在1到10000范围内的记录走了索引并且执行时间为8.656毫秒，从这个测试看出jsonb检索比json效率高。<br>从以上两个测试看出，正好验证了“json写入比jsonb快，但检索时比jsonb慢”的观点，值得一提的是如果需要通过key/value进行检索，例如以下。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_user_jsonb <span class="keyword">WHERE</span> user_info @&gt; <span class="string">'&#123;"user_name": "2_francs"&#125;'</span>;</span><br></pre></td></tr></table></figure></p><p>这时执行计划为全表扫描，如下所示：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="keyword">SELECT</span> * FROM tbl_user_jsonb <span class="keyword">WHERE</span> user_info @&gt; <span class="string">'&#123;"user_name": "2_francs"&#125;'</span>;</span><br><span class="line">                                QUERY PLAN</span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line"> Seq Scan <span class="keyword">on</span> tbl_user_jsonb  (cost=<span class="number">0.00</span>.<span class="number">.67733</span><span class="number">.00</span> <span class="keyword">rows</span>=<span class="number">2000</span> width=<span class="number">143</span>) (actual time=<span class="number">0.018</span>.<span class="number">.582</span><span class="number">.207</span> <span class="keyword">rows</span>=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   Filter: (user_info @&gt; <span class="string">'&#123;"user_name": "2_francs"&#125;'</span><span class="type">::jsonb</span>)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Filter: <span class="number">1999999</span></span><br><span class="line"> Planning time: <span class="number">0.065</span> ms</span><br><span class="line"> Execution time: <span class="number">582.232</span> ms</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure></p><p>从以上看出执行时间为582毫秒左右，在tbl_user_jsonb字段user_info上创建gin索引，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_tbl_user_jsonb_user_Info <span class="keyword">ON</span> tbl_user_jsonb <span class="keyword">USING</span> gin</span><br><span class="line"> (user_Info);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>索引创建后，再次执行以下，如下所示：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mydb=&gt;</span> EXPLAIN ANALYZE SELECT * FROM tbl_user_jsonb WHERE user_info @&gt; '&#123;<span class="string">"user_name"</span>: <span class="string">"2_francs"</span>&#125;';</span><br><span class="line">                                  QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan on tbl_user_jsonb  (<span class="attr">cost=37.50..3554.34</span> <span class="attr">rows=2000</span> <span class="attr">width=143)</span> (actual <span class="attr">time=0.079..0.080</span> <span class="attr">rows=1</span> <span class="attr">loops=1)</span></span><br><span class="line">   Recheck Cond: (user_info @&gt; '&#123;<span class="string">"user_name"</span>: <span class="string">"2_francs"</span>&#125;'::jsonb)</span><br><span class="line">   Heap Blocks: <span class="attr">exact=1</span></span><br><span class="line">   -&gt;  Bitmap Index Scan on idx_tbl_user_jsonb_user_info  (<span class="attr">cost=0.00..37.00</span> <span class="attr">rows=2000</span> <span class="attr">width=0)</span> (actual <span class="attr">time=0.069..0.069</span> <span class="attr">rows=1</span> loop</span><br><span class="line"><span class="attr">s=1)</span></span><br><span class="line">         Index Cond: (user_info @&gt; '&#123;<span class="string">"user_name"</span>: <span class="string">"2_francs"</span>&#125;'::jsonb)</span><br><span class="line"> Planning time: <span class="number">0.094</span> ms</span><br><span class="line"> Execution time: <span class="number">0.114</span> ms</span><br><span class="line">(<span class="number">7</span> rows)</span><br></pre></td></tr></table></figure></p><p>从以上看出走了索引，并且执行时间下降到了0.114毫秒。<br>这一小节测试了json、jsonb数据类型读写性能差异，验证了json写入时比jsonb快，但检索时比jsonb慢的观点。</p><h1 id="四、PostgreSQ全文检索支持JSON和JSONB"><a href="#四、PostgreSQ全文检索支持JSON和JSONB" class="headerlink" title="四、PostgreSQ全文检索支持JSON和JSONB"></a>四、PostgreSQ全文检索支持JSON和JSONB</h1><p>这一小节将介绍PostgreSQL10的一个新特性：全文检索支持json、jsonb数据类型，本小节分两部分，第一部分简单介绍PostgreSQL全文检索，第二部分演示全文检索对json、jsonb数据类型的支持。</p><h2 id="PostgreSQL全文检索简介"><a href="#PostgreSQL全文检索简介" class="headerlink" title="PostgreSQL全文检索简介"></a>PostgreSQL全文检索简介</h2><p>对于大多数应用全文检索很少放到数据库中实现，一般使用单独的全文检索引擎，例如基于SQL全文检索引擎Sphinx。PostgreSQL支持全文检索，对于规模不大的应用如果不想搭建专门的搜索引擎，PostgreSQL的全文检索也可以满足需求。<br>如果没有使用专门的搜索引擎，大部检索需要通过数据库like操作匹配，这种检索方式主要缺点在于：</p><ul><li>不能很好的支持索引，通常需全表扫描检索数据，数据量大时检索性能很低。</li><li>不提供检索结果排序，当输出结果数据量非常大时表现更加明显。</li></ul><p>PostgreSQL全文检索能有效地解决这个问题，PostgreSQL全文检索通过以下两种数据类型来实现。</p><h3 id="tsvector"><a href="#tsvector" class="headerlink" title="tsvector"></a>tsvector</h3><p>tsvector全文检索数据类型代表一个被优化的可以基于搜索的文档，将一串字符串转换成tsvector全文检索数据类型，如下：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> <span class="symbol">'Hello</span>,cat,how are u? cat <span class="keyword">is</span> smiling! '::tsvector;</span><br><span class="line">                     tsvector</span><br><span class="line"><span class="comment">--------------------------------------------------</span></span><br><span class="line"> <span class="symbol">'Hello</span>,cat,how<span class="string">' '</span>are<span class="string">' '</span>cat<span class="string">' '</span><span class="keyword">is</span><span class="string">' '</span>smiling!<span class="string">' '</span>u?'</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>可以看到，字符串的内容被分隔成好几段，但通过::tsvector只是做类型转换，没有进行数据标准化处理，对于英文全文检索可通过函数to_tsvector进行数据标准化，如下所示：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> to_tsvector(<span class="symbol">'english</span><span class="string">','</span>Hello cat,');</span><br><span class="line">    to_tsvector</span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"> <span class="symbol">'cat</span>':<span class="number">2</span> <span class="symbol">'hello</span>':<span class="number">1</span></span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><h3 id="tsquery"><a href="#tsquery" class="headerlink" title="tsquery"></a>tsquery</h3><p>tsquery表示一个文本查询，存储用于搜索的词，并且支持布尔操作&amp;、|、!，将字符串转换成tsquery，如下所示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT  <span class="emphasis">'hello&amp;cat'</span>::tsquery;</span><br><span class="line"><span class="code">     tsquery</span></span><br><span class="line">-----------------</span><br><span class="line"><span class="code"> 'hello' &amp; 'cat'</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>上述只是转换成tsquery类型，而并没有做标准化，使用to_tsquery函数可以执行标准化，如下所示：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> to_tsquery( <span class="symbol">'hello</span>&amp;cat' );</span><br><span class="line">   to_tsquery</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"> <span class="symbol">'hello</span>' &amp; <span class="symbol">'cat</span>'</span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>一个全文检索示例如下，检索字符串是否包括hello和cat字符，本例中返回真。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT to<span class="emphasis">_tsvector('english','Hello cat,how are u') @@</span></span><br><span class="line"><span class="emphasis">to_</span>tsquery( <span class="emphasis">'hello&amp;cat'</span> );</span><br><span class="line"><span class="code"> ?column?</span></span><br><span class="line">----------</span><br><span class="line"><span class="code"> t</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>检索字符串是否包含字符hello和dog，本例中返回假。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT to<span class="emphasis">_tsvector('english','Hello cat,how are u') @@</span></span><br><span class="line"><span class="emphasis"> to_</span>tsquery( <span class="emphasis">'hello&amp;dog'</span> );</span><br><span class="line"><span class="code"> ?column?</span></span><br><span class="line">----------</span><br><span class="line"><span class="code"> f</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>有兴趣的读者可以测试tsquery的其他操作符，例如|、!等。</p><p>注意：这里使用了带双参数的to_tsvector函数，函数to_tsvector双参数的格式如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to_tsvector([<span class="built_in"> config </span>regconfig , ] document text)，本节to_tsvector函数指定了config参数为english，如果不指定config参数，则默认使用default_text_search_config参数的配置。</span><br></pre></td></tr></table></figure></p><h3 id="英文全文检索例子"><a href="#英文全文检索例子" class="headerlink" title="英文全文检索例子"></a>英文全文检索例子</h3><p>下面演示一个英文全文检索示例，创建一张测试表并插入200万测试数据，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> TABLE test_search(id int4,name text);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_search(id,name) <span class="keyword">SELECT</span> n, n||<span class="string">'_francs'</span></span><br><span class="line"><span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">2000000</span>) n;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">2000000</span></span><br></pre></td></tr></table></figure></p><p>执行以下SQL，查询test_search表name字段包含字符1_francs的记录。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM test<span class="emphasis">_search WHERE name LIKE '1_</span>francs';</span><br><span class="line"><span class="code"> id |   name</span></span><br><span class="line">----+----------</span><br><span class="line"><span class="code">  1 | 1_francs</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>执行计划如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="keyword">SELECT</span> * FROM test_search <span class="keyword">WHERE</span> name LIKE <span class="string">'1_francs'</span>;</span><br><span class="line">                                      QUERY PLAN</span><br><span class="line">------------------------------------------------------------------------------------<span class="params">-Seq</span> Scan <span class="keyword">on</span> test_search  (cost=<span class="number">0.00</span>.<span class="number">.38465</span><span class="number">.04</span> <span class="keyword">rows</span>=<span class="number">204</span> width=<span class="number">18</span>) (actual time=<span class="number">0.022</span>.<span class="number">.261</span><span class="number">.766</span> <span class="keyword">rows</span>=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   Filter: (name ~~ <span class="string">'1_francs'</span><span class="type">::text</span>)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Filter: <span class="number">1999999</span></span><br><span class="line"> Planning time: <span class="number">0.101</span> ms</span><br><span class="line"> Execution time: <span class="number">261.796</span> ms</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure></p><p>以上执行计划走了全表扫描，执行时间为261毫秒左右，性能很低，接着创建索引，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_gin_search <span class="keyword">ON</span> test_search <span class="keyword">USING</span> gin</span><br><span class="line">(to_tsvector(<span class="string">'english'</span>,name));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>执行以下SQL，查询test_search表name字段包含字符1_francs的记录。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM test<span class="emphasis">_search WHERE to_</span>tsvector(<span class="emphasis">'english'</span>,name) @@</span><br><span class="line">to<span class="emphasis">_tsquery('english','1_</span>francs');</span><br><span class="line"><span class="code"> id |   name</span></span><br><span class="line">----+----------</span><br><span class="line"><span class="code">  1 | 1_francs</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>再次查看执行计划和执行时间，如下所示：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="keyword">SELECT</span> * FROM test_search <span class="keyword">WHERE</span> to_tsvector(<span class="string">'english'</span>,name) @@</span><br><span class="line">to_tsquery(<span class="string">'english'</span>,<span class="string">'1_francs'</span>);</span><br><span class="line">                                        QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan <span class="keyword">on</span> test_search  (cost=<span class="number">18.39</span>.<span class="number">.128</span><span class="number">.38</span> <span class="keyword">rows</span>=<span class="number">50</span> width=<span class="number">36</span>) (actual time=<span class="number">0.071</span>.<span class="number">.0</span><span class="number">.071</span> <span class="keyword">rows</span>=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   Recheck Cond: (to_tsvector(<span class="string">'english'</span><span class="type">::regconfig</span>, name) @@ <span class="string">''</span><span class="string">'1'</span><span class="string">' &amp; '</span><span class="string">'franc'</span><span class="string">''</span><span class="type">::tsquery</span>)</span><br><span class="line">   Heap Blocks: exact=<span class="number">1</span></span><br><span class="line">   -&gt;  Bitmap Index Scan <span class="keyword">on</span> idx_gin_search  (cost=<span class="number">0.00</span>.<span class="number">.18</span><span class="number">.38</span> <span class="keyword">rows</span>=<span class="number">50</span> width=<span class="number">0</span>) (actual time=<span class="number">0.064</span>.<span class="number">.0</span><span class="number">.064</span> <span class="keyword">rows</span>=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">         Index Cond: (to_tsvector(<span class="string">'english'</span><span class="type">::regconfig</span>, name) @@ <span class="string">''</span><span class="string">'1'</span><span class="string">' &amp; '</span><span class="string">'franc'</span><span class="string">''</span><span class="type">::tsquery</span>)</span><br><span class="line"> Planning time: <span class="number">0.122</span> ms</span><br><span class="line"> Execution time: <span class="number">0.104</span> ms</span><br><span class="line">(<span class="number">7</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure></p><p>创建索引后，以上查询走了索引并且执行时间下降到0.104毫秒，性能提升了3个数量级，值得一提的是如果SQL改成以下，则不走索引，如下所示：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="built_in">SELECT</span> * FROM test_search</span><br><span class="line"> <span class="built_in">WHERE</span> to_tsvector(name) <span class="comment">@@</span> to_tsquery('<span class="number">1</span>_francs');</span><br><span class="line">                                 QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Seq Scan on test_search  (cost=<span class="number">0.00</span>.<span class="number">.1037730</span><span class="number">.00</span> <span class="built_in">rows</span>=<span class="number">50</span> width=<span class="number">18</span>) (actual <span class="built_in">time</span>=<span class="number">0.036</span>.<span class="number">.10297</span><span class="number">.764</span> <span class="built_in">rows</span>=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   Filter: (to_tsvector(name) <span class="comment">@@</span> to_tsquery('<span class="number">1</span>_francs'::text))</span><br><span class="line">   <span class="built_in">Rows</span> Removed by Filter: <span class="number">1999999</span></span><br><span class="line"> Planning <span class="built_in">time</span>: <span class="number">0.098</span> ms</span><br><span class="line"> Execution <span class="built_in">time</span>: <span class="number">10297.787</span> ms</span><br><span class="line">(<span class="number">5</span> <span class="built_in">rows</span>)</span><br></pre></td></tr></table></figure></p><p>由于创建索引时使用的是to_tsvector(‘english’,name)函数索引，带了两个参数，因此where条件中的to_tsvector函数带两个参数才能走索引，而to_tsvector(name)不走索引。</p><h2 id="JSON、JSONB全文检索实践"><a href="#JSON、JSONB全文检索实践" class="headerlink" title="JSON、JSONB全文检索实践"></a>JSON、JSONB全文检索实践</h2><p>在PostgreSQL10版本之前全文检索不支持json和jsonb数据类型，10版本的一个重要特性是全文检索支持json和jsonb数据类型，这一小节演示下10版本的这个新特性。</p><h3 id="PostgreSQL-10版本与9-6版本to-tsvector函数的差异"><a href="#PostgreSQL-10版本与9-6版本to-tsvector函数的差异" class="headerlink" title="PostgreSQL 10版本与9.6版本to_tsvector函数的差异"></a>PostgreSQL 10版本与9.6版本to_tsvector函数的差异</h3><p>先来看下9.6版本to_tsvector函数，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[postgres@pghost1 ~]$ psql francs francs</span><br><span class="line">psql (9.6.3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; \df *to_tsvector*</span><br><span class="line">                                List of functions</span><br><span class="line">   Schema   |       Name        | Result data<span class="built_in"> type </span>| Argument data types |  Type</span><br><span class="line">------------+-------------------+------------------+---------------------+--------</span><br><span class="line"> pg_catalog | array_to_tsvector | tsvector         | text[]              | normal</span><br><span class="line"> pg_catalog | to_tsvector       | tsvector         | regconfig, text     | normal</span><br><span class="line"> pg_catalog | to_tsvector       | tsvector         | text                | normal</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure></p><p>从以上看出9.6版本to_tsvector函数的输入参数仅支持text、text[]数据类型，接着看下10版本的to_tsvector函数，如下所示：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[postgres@pghost1 ~]$ psql mydb pguser</span><br><span class="line">psql (<span class="number">10.0</span>)</span><br><span class="line"><span class="keyword">Type</span> <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line">mydb=&gt; \df *to_tsvector*</span><br><span class="line">                                List of functions</span><br><span class="line">   Schema   |       <span class="type">Name</span>        | <span class="type">Result</span> data type | <span class="type">Argument</span> data types |  <span class="type">Type</span></span><br><span class="line">------------+-------------------+------------------+---------------------+--------</span><br><span class="line"> pg_catalog | <span class="type">array_to_tsvector</span> | <span class="type">tsvector</span>         | <span class="type">text</span>[]              | <span class="type">normal</span></span><br><span class="line"> pg_catalog | <span class="type">to_tsvector</span>       | <span class="type">tsvector</span>         | <span class="type">json</span>                | <span class="type">normal</span></span><br><span class="line"> pg_catalog | <span class="type">to_tsvector</span>       | <span class="type">tsvector</span>         | <span class="type">jsonb</span>               | <span class="type">normal</span></span><br><span class="line"> pg_catalog | <span class="type">to_tsvector</span>       | <span class="type">tsvector</span>         | <span class="type">regconfig</span>, json     | <span class="type">normal</span></span><br><span class="line"> pg_catalog | <span class="type">to_tsvector</span>       | <span class="type">tsvector</span>         | <span class="type">regconfig</span>, jsonb    | <span class="type">normal</span></span><br><span class="line"> pg_catalog | <span class="type">to_tsvector</span>       | <span class="type">tsvector</span>         | <span class="type">regconfig</span>, text     | <span class="type">normal</span></span><br><span class="line"> pg_catalog | <span class="type">to_tsvector</span>       | <span class="type">tsvector</span>         | <span class="type">text</span>                | <span class="type">normal</span></span><br><span class="line">(<span class="number">7</span> rows)</span><br></pre></td></tr></table></figure><p>从以上看出，10版本的to_tsvector函数支持的数据类型增加了json和jsonb。</p><h3 id="创建数据生成函数"><a href="#创建数据生成函数" class="headerlink" title="创建数据生成函数"></a>创建数据生成函数</h3><p>为了便于生成测试数据，创建以下两个函数用来随机生成指定长度的字符串，创建random_range(int4, int4)函数如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> random_range(int4, int4)</span><br><span class="line"><span class="keyword">RETURNS</span> int4</span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">    <span class="keyword">SELECT</span> ($<span class="number">1</span> + <span class="keyword">FLOOR</span>(($<span class="number">2</span> - $<span class="number">1</span> + <span class="number">1</span>) * random() ))::int4;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure></p><p>接着创建random_text_simple(length int4)函数，此函数会调用random_range(int4, int4)函数。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> random_text_simple(<span class="keyword">length</span> int4)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> PLPGSQL</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    possible_chars <span class="built_in">text</span> := <span class="string">'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line">    output text := '';</span><br><span class="line">    i int4;</span><br><span class="line">    pos int4;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.length <span class="keyword">LOOP</span></span><br><span class="line">        pos := random_range(<span class="number">1</span>, <span class="keyword">length</span>(possible_chars));</span><br><span class="line">        output := output || substr(possible_chars, pos, 1);</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">    RETURN output;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure></p><p>random_text_simple(length int4)函数可以随机生成指定长度字符串，如下随机生成含三位字符的字符串。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT random<span class="emphasis">_text_</span>simple(3);</span><br><span class="line"><span class="code"> random_text_simple</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="code"> LL9</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>随机生成含六位字符的字符串，如下所示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT random<span class="emphasis">_text_</span>simple(6);</span><br><span class="line"><span class="code"> random_text_simple</span></span><br><span class="line">--------------------</span><br><span class="line"><span class="code"> B81BPW</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>后面会用到这个函数生成测试数据。</p><h3 id="创建JSON测试表"><a href="#创建JSON测试表" class="headerlink" title="创建JSON测试表"></a>创建JSON测试表</h3><p>创建user_ini测试表，并通过random_text_simple(length int4)函数插入100万随机生成六位字符的字符串测试数据，如下所示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; CREATE TABLE user_ini(id int4 ,user_id int8,</span><br><span class="line">user_name character varying(64),</span><br><span class="line">create_time timestamp(6) with time zone<span class="built_in"> default </span>clock_timestamp());</span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; INSERT INTO user_ini(id,user_id,user_name)</span><br><span class="line">SELECT r,round(random()<span class="number">*1000000</span>), random_text_simple(6)</span><br><span class="line"><span class="keyword">FROM</span> generate_series(1,1000000) as r;</span><br><span class="line">INSERT 0 1000000</span><br></pre></td></tr></table></figure></p><p>创建tbl_user_search_json表，并通过row_to_json函数将表user_ini行数据转换成json数据，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> TABLE tbl_user_search_json(id serial, user_info json);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_user_search_json(user_info)</span><br><span class="line"> <span class="keyword">SELECT</span> row_to_json(user_ini) <span class="keyword">FROM</span> user_ini;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1000000</span></span><br></pre></td></tr></table></figure></p><p>生成的数据如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; SELECT * <span class="keyword">FROM</span> tbl_user_search_json LIMIT 1;</span><br><span class="line"> id |                                            user_info</span><br><span class="line">----+-----------------------------------------------------------------------------------------------</span><br><span class="line">  1 | &#123;<span class="string">"id"</span>:1,<span class="string">"user_id"</span>:186536,<span class="string">"user_name"</span>:<span class="string">"KTU89H"</span>,<span class="string">"create_time"</span>:<span class="string">"2017-08-05T15:59:25.359148+08:00"</span>&#125;</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><h3 id="JSON数据全文检索测试"><a href="#JSON数据全文检索测试" class="headerlink" title="JSON数据全文检索测试"></a>JSON数据全文检索测试</h3><p>使用全文检索查询表tbl_user_search_json的user_info字段中包含KTU89H字符的记录，如下所示：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM tbl_user_search_json</span><br><span class="line">WHERE to_tsvector('english',user_info) @@ to_tsquery('ENGLISH','KTU89H');</span><br><span class="line"> id <span class="string">|                                            user_info</span></span><br><span class="line">----+----------------------------------------------------------------------------------------</span><br><span class="line">  <span class="number">1</span> <span class="string">| &#123;"</span>id<span class="string">":1,"</span>user_id<span class="string">":186536,"</span>user_name<span class="string">":"</span>KTU89H<span class="string">","</span>create_time<span class="string">":"</span><span class="number">2017</span>-<span class="number">08</span>-<span class="number">05</span>T15:<span class="number">59</span>:<span class="number">25.359148</span>+<span class="number">08</span>:<span class="number">00</span><span class="string">"&#125;</span></span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>以上SQL能正常执行说明全文检索支持json数据类型，只是上述SQL走了全表扫描性能低，执行时间为8061毫秒，如下所示：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="keyword">SELECT</span> * FROM tbl_user_search_json</span><br><span class="line"> <span class="keyword">WHERE</span> to_tsvector(<span class="string">'english'</span>,user_info) @@ to_tsquery(<span class="string">'ENGLISH'</span>,<span class="string">'KTU89H'</span>);</span><br><span class="line">                                        QUERY PLAN</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"> Seq Scan <span class="keyword">on</span> tbl_user_search_json  (cost=<span class="number">0.00</span>.<span class="number">.279513</span><span class="number">.00</span> <span class="keyword">rows</span>=<span class="number">5000</span> width=<span class="number">104</span>) (actual time=<span class="number">0.046</span>.<span class="number">.8061</span><span class="number">.858</span> <span class="keyword">rows</span>=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   Filter: (to_tsvector(<span class="string">'english'</span><span class="type">::regconfig</span>, user_info) @@ <span class="string">''</span><span class="string">'ktu89h'</span><span class="string">''</span><span class="type">::tsquery</span>)</span><br><span class="line">   <span class="keyword">Rows</span> Removed <span class="keyword">by</span> Filter: <span class="number">999999</span></span><br><span class="line"> Planning time: <span class="number">0.091</span> ms</span><br><span class="line"> Execution time: <span class="number">8061.880</span> ms</span><br><span class="line">(<span class="number">5</span> <span class="keyword">rows</span>)</span><br></pre></td></tr></table></figure></p><p>创建如下索引：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt;  <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_gin_search_json <span class="keyword">ON</span> tbl_user_search_json <span class="keyword">USING</span></span><br><span class="line">gin(to_tsvector(<span class="string">'english'</span>,user_info));</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>索引创建后，再次执行以下SQL，如下所示：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE SELECT * FROM tbl_user_search_json WHERE to_tsvector(<span class="string">'english'</span>,user_info) @@ to_tsquery(<span class="string">'ENGLISH'</span>,<span class="string">'KTU89H'</span>);</span><br><span class="line">                                        QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"> Bitmap Heap Scan on tbl_user_search_json  (cost=<span class="number">50.75</span>..<span class="number">7876.06</span> rows=<span class="number">5000</span> width=<span class="number">104</span>) (actual time=<span class="number">0.024</span>..<span class="number">0.024</span> rows=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">   Recheck Cond: (to_tsvector(<span class="string">'english'</span>::regconfig, user_info) @@ <span class="string">'''ktu89h'''</span>::tsquery)</span><br><span class="line">   Heap Blocks: exact=<span class="number">1</span></span><br><span class="line">   -&gt;  Bitmap Index Scan on idx_gin_search_json  (cost=<span class="number">0.00</span>..<span class="number">49.50</span> rows=<span class="number">5000</span> width=<span class="number">0</span>) (actual time=<span class="number">0.018</span>..<span class="number">0.018</span> rows=<span class="number">1</span> loops=<span class="number">1</span>)</span><br><span class="line">         Index Cond: (to_tsvector(<span class="string">'english'</span>::regconfig, user_info) @@ <span class="string">'''ktu89h'''</span>::tsquery)</span><br><span class="line"> Planning time: <span class="number">0.113</span> ms</span><br><span class="line"> Execution time: <span class="number">0.057</span> ms</span><br><span class="line">(<span class="number">7</span> rows)</span><br></pre></td></tr></table></figure></p><p>从上述执行计划看出走了索引，并且执行时间降为0.057毫秒，性能非常不错。<br>这一小节前一部分对PostgreSQL全文检索的实现做了简单介绍，并且给出了一个英文检索的例子，后一部分通过示例介绍了PostgreSQL10的一个新特性，即全文检索支持json、jsonb类型。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>本文介绍了PostgreSQL的NoSQL特性，首先介绍了json和jsonb数据类型，之后通过示例对比json、jsonb数据类型读写性能差异，最后介绍了PostgreSQL全文检索对json、jsonb类型的支持（PostgreSQL10新特性）；值得一提的是，PostgreSQL对中文全文检索也是支持的，有兴趣的读者可自行测试。</p><h1 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h1><ul><li><a href="https://postgres.fun/20181214145600.html">PostgreSQL用户应掌握的高级SQL特性</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://postgres.fun/20181214145600.html&quot;&gt;上篇文章&lt;/a&gt; 介绍
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL用户应掌握的高级SQL特性</title>
    <link href="https://postgres.fun/20181214145600.html"/>
    <id>https://postgres.fun/20181214145600.html</id>
    <published>2018-12-14T06:56:20.000Z</published>
    <updated>2018-12-20T00:27:43.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>PostgreSQL数据库在SQL和NoSQL方面具有很多丰富的特性，本文将从 <a href="https://item.jd.com/12405774.html" target="_blank" rel="noopener">《PostgreSQL实战》</a> 一书的“ 第4章 SQL高级特性”中摘选部分内容介绍。</p><p>这一部分主要介绍PostgreSQL在SQL方面的高级特性，例如WITH查询、批量插入、RETURNING返回修改的数据、UPSERT、数据抽样、聚合函数、窗口函数。</p><h1 id="WITH查询"><a href="#WITH查询" class="headerlink" title="WITH查询"></a>WITH查询</h1><p>WITH查询是PostgreSQL支持的高级SQL特性之一，这一特性常称为CTE(Common Table Expressions)，WITH查询在复杂查询中定义一个辅助语句（可理解成在一个查询中定义的临时表），这一特性常用于复杂查询或递归查询应用场景</p><p>先通过一个简单的CTE示例了解WITH查询，如下所示：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WITH <span class="literal">t</span> as (</span><br><span class="line">  SELECT generate_series(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">)</span><br><span class="line">SELECT * FROM <span class="literal">t</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">generate<span class="emphasis">_series </span></span><br><span class="line"><span class="emphasis">-----------------</span></span><br><span class="line"><span class="emphasis">               1</span></span><br><span class="line"><span class="emphasis">               2</span></span><br><span class="line"><span class="emphasis">               3</span></span><br><span class="line"><span class="emphasis">(3 rows)</span></span><br></pre></td></tr></table></figure></p><p>这个简单的CTE示例中，一开始定义了一条辅助语句t取数，之后在主查询语句中查询t，定义的辅助语句就像是定义了一张临时表，对于复杂查询如果不使用CTE，可以通过创建视图方式简化SQL。</p><p>WITH查询的一个重要属性是RECURSIVE，使用RECURSIVE属性可以引用自己的输出，从而实现递归，一般用于层次结构或树状结构的应用场景。</p><p>例如，存在一张包含如下数据的表。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id name fatherid</span><br><span class="line"><span class="number">1</span> 中国 <span class="number">0</span></span><br><span class="line"><span class="number">2</span> 辽宁 <span class="number">1</span></span><br><span class="line"><span class="number">3</span> 山东 <span class="number">1</span></span><br><span class="line"><span class="number">4</span> 沈阳 <span class="number">2</span></span><br><span class="line"><span class="number">5</span> 大连 <span class="number">2</span></span><br><span class="line"><span class="number">6</span> 济南 <span class="number">3</span></span><br><span class="line"><span class="number">7</span> 和平区 <span class="number">4</span></span><br><span class="line"><span class="number">8</span> 沈河区 <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>使用PostgreSQL的WITH查询检索ID为7以及以上的所有父节点，如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE r AS ( </span><br><span class="line">       <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test_area <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">7</span> </span><br><span class="line">     <span class="keyword">UNION</span>   ALL </span><br><span class="line">       <span class="keyword">SELECT</span> test_area.* <span class="keyword">FROM</span> test_area, r <span class="keyword">WHERE</span> test_area.id = r.fatherid </span><br><span class="line">     ) </span><br><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> r <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p><p>查询结果如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id |  name  | fatherid </span><br><span class="line">----<span class="code">+--------+</span>----------</span><br><span class="line"><span class="code">  1 | 中国   |        0</span></span><br><span class="line"><span class="code">  2 | 辽宁   |        1</span></span><br><span class="line"><span class="code">  4 | 沈阳   |        2</span></span><br><span class="line"><span class="code">  7 | 和平区 |        4</span></span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure></p><h1 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h1><p>批量插入是指一次性插入多条数据，主要用于提升数据插入效率，PostgreSQL有多种方法实现批量插入。</p><h2 id="方式一：INSERT-INTO-SELECT"><a href="#方式一：INSERT-INTO-SELECT" class="headerlink" title="方式一：INSERT INTO..SELECT."></a>方式一：INSERT INTO..SELECT.</h2><p>过表数据或函数批量插入，这种方式大部分关系数据库都支持，语法如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">SELECT</span> …<span class="keyword">FROM</span> source_table</span><br></pre></td></tr></table></figure></p><h2 id="方式二：INSERT-INTO-VALUES-…"><a href="#方式二：INSERT-INTO-VALUES-…" class="headerlink" title="方式二：INSERT INTO VALUES (),(),…()"></a>方式二：INSERT INTO VALUES (),(),…()</h2><p>这种批量插入方式为一条INSERT语句中通过VALUES关键字插入多条记录，通过一个例子就很容易理解，如下所示：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> CREATE TABLE tbl_batch<span class="number">3</span>(<span class="name">id</span> int4,info text)<span class="comment">;</span></span></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> INSERT INTO tbl_batch<span class="number">3</span>(<span class="name">id</span>,info) VALUES (<span class="number">1</span>,'a'),(<span class="number">2</span>,'b'),(<span class="number">3</span>,'c')<span class="comment">;</span></span></span><br><span class="line">INSERT 0 3</span><br></pre></td></tr></table></figure></p><p>数据如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM tbl_batch3;</span><br><span class="line"> id | <span class="type">info</span> </span><br><span class="line">----+------</span><br><span class="line">  <span class="number">1</span> | <span class="type">a</span></span><br><span class="line">  <span class="number">2</span> | <span class="type">b</span></span><br><span class="line">  <span class="number">3</span> | <span class="type">c</span></span><br><span class="line">(<span class="number">3</span> rows)</span><br></pre></td></tr></table></figure></p><p>这种批量插入方式非常独特，一条SQL插入多行数据，相比一条SQL插入一条数据的方式能减少和数据库的交互，减少数据库WAL（Write-Ahead Logging）日志的生成，提升插入效率，通常很少有开发人员了解PostgreSQL的这种批量插入方式。</p><h2 id="方式三：COPY或-COPY元命令"><a href="#方式三：COPY或-COPY元命令" class="headerlink" title="方式三：COPY或\COPY元命令"></a>方式三：COPY或\COPY元命令</h2><p><code>COPY</code>或<code>\COPY</code>元命令能够将一定格式的文件数据导入到数据库中，相比INSERT命令插入效率更高，通常大数据量的文件导入一般在数据库服务端主机通过PostgreSQL超级用户使用COPY命令导入。</p><p>将文件tbl_batch4.txt的一千万数据导入到表中，如下所示：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=# TRUNCATE <span class="keyword">TABLE</span> pguser.tbl_batch4;</span><br><span class="line">TRUNCATE <span class="keyword">TABLE</span></span><br><span class="line"></span><br><span class="line">mydb=# COPY pguser.tbl_batch4 FROM <span class="string">'/home/pg10/tbl_batch4.txt'</span>;</span><br><span class="line">COPY <span class="number">10000000</span></span><br></pre></td></tr></table></figure></p><h1 id="RETURNING返回修改的数据"><a href="#RETURNING返回修改的数据" class="headerlink" title="RETURNING返回修改的数据"></a>RETURNING返回修改的数据</h1><p>PostgreSQL的RETURNING特性可以返回DML修改的数据，具体为以下三个场景 ，INSERT语句后接RETURNING属性返回插入的数据，UPDATE语句后接RETURNING属性返回更新后的新值，DELETE语句后接RETURNING属性返回删除的数据，这个特性的优点在于不需要额外的SQL获取这些值，能够方便应用开发，接着通过示例演示。</p><h2 id="RETURNING返回插入的数据"><a href="#RETURNING返回插入的数据" class="headerlink" title="RETURNING返回插入的数据"></a>RETURNING返回插入的数据</h2><p>INSERT语句后接RETURNING属性返回插入的值，以下创建测试表，并返回已插入的整行数据。<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> CREATE TABLE test_r<span class="number">1</span>(<span class="name">id</span> serial,flag char(<span class="number">1</span>))<span class="comment">;</span></span></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> INSERT INTO test_r<span class="number">1</span>(<span class="name">flag</span>) VALUES (<span class="name">'a'</span>) RETURNING *<span class="comment">;</span></span></span><br><span class="line"> id | flag </span><br><span class="line">----+------</span><br><span class="line">  1 | a</span><br><span class="line">(1 row)</span><br><span class="line">INSERT 0 1</span><br></pre></td></tr></table></figure></p><h2 id="RETURNING返回更新后数据"><a href="#RETURNING返回更新后数据" class="headerlink" title="RETURNING返回更新后数据"></a>RETURNING返回更新后数据</h2><p>UPDATE后接RETURNING属性返回UPDATE语句更新后的值，如下所示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; SELECT * <span class="keyword">FROM</span> test_r1 WHERE <span class="attribute">id</span>=1;</span><br><span class="line"> id | flag </span><br><span class="line">----+------</span><br><span class="line">  1 | a</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; UPDATE test_r1 <span class="builtin-name">SET</span> <span class="attribute">flag</span>=<span class="string">'p'</span> WHERE <span class="attribute">id</span>=1 RETURNING *;</span><br><span class="line"> id | flag </span><br><span class="line">----+------</span><br><span class="line">  1 | p</span><br><span class="line">(1 row)</span><br><span class="line">UPDATE 1</span><br></pre></td></tr></table></figure></p><h2 id="RETURNING返回删除的数据"><a href="#RETURNING返回删除的数据" class="headerlink" title="RETURNING返回删除的数据"></a>RETURNING返回删除的数据</h2><p>DELETE后接RETURNING属性返回删除的数据，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">DELETE</span> <span class="keyword">FROM</span> test_r1 <span class="keyword">WHERE</span> id=<span class="number">2</span> <span class="keyword">RETURNING</span> *;</span><br><span class="line"> id | flag </span><br><span class="line">----+------</span><br><span class="line">  2 | b</span><br><span class="line">(1 row)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h1 id="UPSERT"><a href="#UPSERT" class="headerlink" title="UPSERT"></a>UPSERT</h1><p>PostgreSQL的UPSERT特性是指 <code>INSERT ... ON CONFLICT UPDATE</code>，用来解决在数据插入过程中数据冲突的情况，比如违反用户自定义约束，日志数据应用场景通常在事务中批量插入日志数据，如果其中有一条数据违反表上的约束，则整个插入事务将会回滚，PostgreSQL的UPSERT特性可解决这一问题。</p><p>接下来通过例子来理解UPSERT的功能，定义一张用户登录日志表并插入一条数据，如下，</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">CREATE</span> TABLE user_logins(user_name text <span class="keyword">primary</span> <span class="keyword">key</span>,</span><br><span class="line">login_cnt int4,</span><br><span class="line">last_login_time timestamp(<span class="number">0</span>) without time zone);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_logins(user_name,login_cnt) <span class="keyword">VALUES</span> (<span class="string">'francs'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在user_logins表user_name字段上定义主键，批量插入数据中如有重复会报错，如下所示：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; INSERT INTO user_logins(user_name,login_cnt) </span><br><span class="line">VALUES ('matiler',1),('francs',1);</span><br><span class="line"><span class="keyword">ERROR:  </span>duplicate key value violates unique constraint "user_logins_pkey"</span><br><span class="line">DETAIL:  Key (user_name)=(francs) already exists.</span><br></pre></td></tr></table></figure></p><p>上述SQL试图插入两条数据，其中matiler这条数据不违反主键冲突，而francs这条数据违反主键冲突，结果两条数据都不能插入。PostgreSQL的UPSERT可以处理冲突的数据，比如当插入的数据冲突时不报错，同时更新冲突的数据，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_logins(user_name,login_cnt) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'matiler'</span>,<span class="number">1</span>),(<span class="string">'francs'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">ON</span> CONFLICT(user_name)    </span><br><span class="line"><span class="keyword">DO</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">login_cnt=user_logins.login_cnt+EXCLUDED.login_cnt,last_login_time=now();</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>上述INSERT语句插入两条数据，并设置规则：当数据冲突时更新登录次数字段login_cnt值加1，同时更新最近登录时间last_login_time，ON CONFLICT(user_name)定义冲突类型为user_name字段，DO UPDATE SET是指冲突动作，后面定义了一个UPDATE语句，注意上述SET命令中引用了user_loins表和内置表EXCLUDED，引用原表user_loins访问表中已存在的冲突记录，内置表EXCLUDED引用试图插入的值，再次查询表user_login，如下所示：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT * FROM user_logins ;</span><br><span class="line"> user_name | <span class="type">login_cnt</span> |   <span class="type">last_login_time</span>   </span><br><span class="line">-----------+-----------+---------------------</span><br><span class="line"> matiler   |         <span class="type">1</span> | <span class="type"></span></span><br><span class="line"><span class="type"> francs</span>    |         <span class="type">2</span> | <span class="type">2017</span><span class="number">-08</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">13</span></span><br><span class="line">(<span class="number">2</span> rows)</span><br></pre></td></tr></table></figure></p><p>一方面冲突的francs这条数据被更新了login_cnt和last_login_time字段，另一方面新的数据matiler记录已正常插入。</p><h1 id="数据抽样"><a href="#数据抽样" class="headerlink" title="数据抽样"></a>数据抽样</h1><p>数据抽样（TABLESAMPLE）在数据处理方面经常用到，特别是当表数据量比较大时，随机查询表一定数量记录很常见，PostgreSQL早在9.5版时就已经提供了TABLESAMPLE数据抽样功能，9.5版前通常通过ORDER BY random()方式实现数据抽样，这种方式虽然在功能上满足随机返回指定行数据，但性能很低，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; EXPLAIN ANALYZE SELECT * <span class="keyword">FROM</span> user_ini ORDER BY random() LIMIT 1;</span><br><span class="line">                                    QUERY PLAN                                                            </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"> Limit  (<span class="attribute">cost</span>=25599.98..25599.98 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=35) (actual <span class="attribute">time</span>=367.867..367.868 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=1)</span><br><span class="line">   -&gt;  Sort  (<span class="attribute">cost</span>=25599.98..28175.12 <span class="attribute">rows</span>=1030056 <span class="attribute">width</span>=35) (actual <span class="attribute">time</span>=367.866..367.866 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=1)</span><br><span class="line">         Sort Key: (random())</span><br><span class="line">         Sort Method: top-N heapsort  Memory: 25kB</span><br><span class="line">         -&gt;  Seq Scan on user_ini  (<span class="attribute">cost</span>=0.00..20449.70 <span class="attribute">rows</span>=1030056 <span class="attribute">width</span>=35) (actual <span class="attribute">time</span>=0.012..159.569 <span class="attribute">rows</span>=1000000 <span class="attribute">loops</span>=1)</span><br><span class="line"> Planning time: 0.083 ms</span><br><span class="line"> Execution time: 367.909 ms</span><br><span class="line">(7 rows)</span><br></pre></td></tr></table></figure></p><p>表user_ini数据量为100万，从100万随机取一条上述SQL执行时间为367ms，这种方法走了全表扫描和排序，效率非常低，当表数据量大时，性能几乎无法接受。</p><p>9.5版本以后PostgreSQL支持TABLESAMPLE数据抽样，语法为以下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> …</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( <span class="keyword">seed</span> ) ]</span><br></pre></td></tr></table></figure></p><p>sampling_method指抽样方法，主要有两种：SYSTEM和BERNOULLI，接下来详细介绍这两种抽样方式，argument指抽样百分比。</p><h2 id="SYSTEM抽样方式"><a href="#SYSTEM抽样方式" class="headerlink" title="SYSTEM抽样方式"></a>SYSTEM抽样方式</h2><p>SYSTEM抽样方式为随机抽取表上数据块上的数据，理论上被抽样表的每个数据块被检索的概率是一样的，SYSTEM抽样方式基于数据块级别，后接抽样参数，被选中的块上的所有数据将被检索。</p><p>创建test_sample测试表，并插入150万数据，抽样因子设置成0.01，意味着返回1500000*0.01%=150条记录，执行如下SQL。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="built_in">SELECT</span> * FROM test_sample TABLESAMPLE <span class="keyword">SYSTEM</span>(<span class="number">0.01</span>);</span><br><span class="line">                               QUERY PLAN                                                  </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"> Sample Scan on test_sample  (cost=<span class="number">0.00</span>.<span class="number">.3</span><span class="number">.50</span> <span class="built_in">rows</span>=<span class="number">150</span> width=<span class="number">45</span>) (actual <span class="built_in">time</span>=<span class="number">0.099</span>.<span class="number">.0</span><span class="number">.146</span> <span class="built_in">rows</span>=<span class="number">107</span> loops=<span class="number">1</span>)</span><br><span class="line">   Sampling: <span class="keyword">system</span> ('<span class="number">0.01</span>'::<span class="built_in">real</span>)</span><br><span class="line"> Planning <span class="built_in">time</span>: <span class="number">0.053</span> ms</span><br><span class="line"> Execution <span class="built_in">time</span>: <span class="number">0.166</span> ms</span><br><span class="line">(<span class="number">4</span> <span class="built_in">rows</span>)</span><br></pre></td></tr></table></figure><p>以上执行计划主要有两点，一方面走了Sample Scan扫描(抽样方式为SYSTEM)，执行时间为0.166毫秒，性能较好，另一方面优化器预计访问150条记录，实际返回107条。</p><h2 id="BERNOULLI抽样方式"><a href="#BERNOULLI抽样方式" class="headerlink" title="BERNOULLI抽样方式"></a>BERNOULLI抽样方式</h2><p>BERNOULLI抽样方式随机抽取表的数据行，并返回指定百分比数据，BERNOULLI抽样方式基于数据行级别，理论上被抽样表的每行记录被检索的概率是一样的，因此BERNOULLI抽样方式抽取的数据相比SYSTEM抽样方式具有更好的随机性，但性能上相比SYSTEM抽样方式低很多，下面演示下BERNOULLI抽样方式，同样基于test_sample测试表。</p><p>设置抽样方式为BERNOULLI，抽样因子为0.01，如下所示。<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; EXPLAIN ANALYZE <span class="built_in">SELECT</span> * FROM test_sample TABLESAMPLE BERNOULLI (<span class="number">0.01</span>);</span><br><span class="line">                                     QUERY PLAN                                                    </span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line"> Sample Scan on test_sample  (cost=<span class="number">0.00</span>.<span class="number">.14020</span><span class="number">.50</span> <span class="built_in">rows</span>=<span class="number">150</span> width=<span class="number">45</span>) (actual <span class="built_in">time</span>=<span class="number">0.025</span>.<span class="number">.22</span><span class="number">.541</span> <span class="built_in">rows</span>=<span class="number">152</span> loops=<span class="number">1</span>)</span><br><span class="line">   Sampling: bernoulli ('<span class="number">0.01</span>'::<span class="built_in">real</span>)</span><br><span class="line"> Planning <span class="built_in">time</span>: <span class="number">0.063</span> ms</span><br><span class="line"> Execution <span class="built_in">time</span>: <span class="number">22.569</span> ms</span><br><span class="line">(<span class="number">4</span> <span class="built_in">rows</span>)</span><br></pre></td></tr></table></figure></p><p>从以上执行计划看出走了Sample Scan扫描（抽样方式为BERNOULLI），执行计划预计返回150条记录，实际返回152条，从返回的记录数来看，非常接近150条（1000000*0.01%），但执行时间却要22.569毫秒，性能相比SYSTEM抽样方式0.166毫秒差了136倍。</p><p>多次执行以下查询，查看返回记录数的变化，如下所示：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure">  SELECT count(<span class="name"><span class="builtin-name">*</span></span>) FROM test_sample TABLESAMPLE BERNOULLI(<span class="number">0.01</span>)<span class="comment">;</span></span></span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">   151</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure">  SELECT count(<span class="name"><span class="builtin-name">*</span></span>) FROM test_sample TABLESAMPLE BERNOULLI(<span class="number">0.01</span>)<span class="comment">;</span></span></span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">   147</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>从以上看出，BERNOULLI抽样方式返回的数据量非常接近抽样数据的百分比，而SYSTEM抽样方式数据返回以数据块为单位，被抽样的块上的所有数据都被返回，因此SYSTEM抽样方式的数据量返回的偏差较大。</p><p>这里演示了SYSTEM和BERNOULLI抽样方式，SYSTEM抽样方式基于数据块级别，随机抽取表数据块上的记录，因此这种方式抽取的记录的随机性不是很好，但返回的数据以数据块为单位，抽样性能很高，适用于抽样效率优先的场景，例如抽样大小为GB的日志表；而BERNOULLI抽样方式基于数据行，相比SYSTEM抽样方式所抽样的数据随机性更好，但性能相比SYSTEM差很多，适用于抽样随机性优先的场景，读者可根据实际应用场景选择抽样方式。</p><h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p>聚合函数可以对结果集进行计算，常用的聚合函数有avg()、sum()、min()、max()、count()等，本节将介绍PostgreSQL两个特殊功能的聚合函数并给出测试示例。</p><p>在介绍两个聚合函数之前，先来看一个应用场景，假如一张表有以下数据，如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">country | city </span><br><span class="line">---------+------</span><br><span class="line"><span class="code"> 中国    | 台北</span></span><br><span class="line"><span class="code"> 中国    | 香港</span></span><br><span class="line"><span class="code"> 中国    | 上海</span></span><br><span class="line"><span class="code"> 日本    | 东京</span></span><br><span class="line"><span class="code"> 日本    | 大阪</span></span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure></p><p>要求得到如下结果集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中国    台北，香港，上海 </span><br><span class="line">日本    东京，大阪</span><br></pre></td></tr></table></figure></p><p>这个SQL读者想想如何写？</p><h2 id="string-agg函数"><a href="#string-agg函数" class="headerlink" title="string_agg函数"></a>string_agg函数</h2><p>首先介绍string_agg函数，此函数语法如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">string_agg</span><span class="params">(expression, delimiter)</span></span></span><br></pre></td></tr></table></figure></p><p>简单的说string_agg函数能将结果集某个字段的所有行连接成字符串，并用指定delimiter分隔符分隔，expression表示要处理的字符类型数据；参数的类型为(text, text) 或 (bytea, bytea)，函数返回的类型同输入参数类型一致，bytea属于二进制类型，使用情况不多，我们主要介绍text类型输入参数，本节开头的场景正好可以用string_agg函数处理。</p><p>将city字段连接成字符串如下：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mydb=&gt;</span><span class="clojure"> SELECT string_agg(<span class="name">city</span>,',') FROM city<span class="comment">;</span></span></span><br><span class="line">        string_agg        </span><br><span class="line">--------------------------</span><br><span class="line"> 台北,香港,上海,东京,大阪</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>可见string_agg函数将输出的结果集连接成了字符串，并用指定的逗号分隔符分隔，回到本文开头的问题，通过以下SQL实现，如下所示：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; <span class="keyword">SELECT</span> country,string_agg(city,<span class="string">','</span>) <span class="keyword">FROM</span> city <span class="keyword">GROUP</span> <span class="keyword">BY</span> country;</span><br><span class="line"> country |   string_agg   </span><br><span class="line">---------+----------------</span><br><span class="line"> 日本    | 东京,大阪</span><br><span class="line"> 中国    | 台北,香港,上海</span><br></pre></td></tr></table></figure></p><h2 id="array-agg函数"><a href="#array-agg函数" class="headerlink" title="array_agg函数"></a>array_agg函数</h2><p>array_agg函数和string_agg函数类似，最主要的区别为返回的类型为数组，数组数据类型同输入参数数据类型一致，array_agg函数支持两种语法，第一种如下：<br>array_agg(expression)  –输入参数为任何非数组类型</p><p>输入参数可以是任何非数组类型，返回的结果是一维数组，array_agg函数将结果集某个字段的所有行连接成数组，执行以下查询。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; SELECT country,array_agg(city) <span class="keyword">FROM</span> city<span class="built_in"> GROUP </span>BY country;</span><br><span class="line"> country |    array_agg     </span><br><span class="line">---------+------------------</span><br><span class="line"> 日本    | &#123;东京,大阪&#125;</span><br><span class="line"> 中国    | &#123;台北,香港,上海&#125;</span><br></pre></td></tr></table></figure></p><p>array_agg函数输出的结果为字符类型数组，其他无明显区别，使用array_agg函数主要优点在于可以使用数组相关函数和操作符。</p><h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>PostgreSQL提供内置的窗口函数，例如row_num()、rank()、lag()等，除了内置的窗口函数外，聚合函数、自定义函数后接OVER属性也可作为窗口函数。</p><p>窗口函数的调用语法稍复杂，如下所示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function_name ([expression [, expression <span class="built_in">..</span>. ]]) [<span class="built_in"> FILTER </span>( WHERE filter_clause ) ] OVER ( window_definition )</span><br></pre></td></tr></table></figure></p><p>其中window_definition语法如下：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ existing_window_name ]</span><br><span class="line">[ PARTITION BY expression [, ...] ]</span><br><span class="line">[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS &#123; FIRST | LAST &#125; ] [, ...] ]</span><br><span class="line">[ frame_clause ]</span><br></pre></td></tr></table></figure></p><ul><li>OVER表示窗口函数的关键字。</li><li>PARTITON BY 属性对查询返回的结果集进行分组，之后窗口函数处理分组的数据。</li><li>ORDER BY 属性设定结果集的分组数据的排序。</li></ul><h2 id="row-number-窗口函数"><a href="#row-number-窗口函数" class="headerlink" title="row_number() 窗口函数"></a>row_number() 窗口函数</h2><p>创建一张成绩表并插入测试数据，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> score ( <span class="keyword">id</span> <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">                      subject <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">32</span>),</span><br><span class="line">                      stu_name <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">32</span>),</span><br><span class="line">                      score <span class="built_in">numeric</span>(<span class="number">3</span>,<span class="number">0</span>) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'Chinese'</span>,<span class="string">'francs'</span>,<span class="number">70</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'Chinese'</span>,<span class="string">'matiler'</span>,<span class="number">70</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score) <span class="keyword">VALUES</span> (<span class="string">'Chinese'</span>,<span class="string">'tutu'</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'English'</span>,<span class="string">'matiler'</span>,<span class="number">75</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'English'</span>,<span class="string">'francs'</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'English'</span>,<span class="string">'tutu'</span>,<span class="number">60</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'Math'</span>,<span class="string">'francs'</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'Math'</span>,<span class="string">'matiler'</span>,<span class="number">99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score ( subject,stu_name,score ) <span class="keyword">VALUES</span> (<span class="string">'Math'</span>,<span class="string">'tutu'</span>,<span class="number">65</span>);</span><br></pre></td></tr></table></figure></p><p>row_number()窗口函数对结果集分组后的数据标注行号，从1开始，如下。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT row_number() OVER (partition <span class="built_in">by</span> subject ORDER BY score desc),* FROM score;</span><br><span class="line"> row_number | <span class="type">id</span> | <span class="type">subject</span> | <span class="type">stu_name</span> | <span class="type">score</span></span><br><span class="line">------------+----+---------+----------+-------</span><br><span class="line">          <span class="number">1</span> |  <span class="type">3</span> | <span class="type">Chinese</span> | <span class="type">tutu</span>     |    <span class="type">80</span></span><br><span class="line">          <span class="number">2</span> |  <span class="type">1</span> | <span class="type">Chinese</span> | <span class="type">francs</span>   |    <span class="type">70</span></span><br><span class="line">          <span class="number">3</span> |  <span class="type">2</span> | <span class="type">Chinese</span> | <span class="type">matiler</span>  |    <span class="type">70</span></span><br><span class="line">          <span class="number">1</span> |  <span class="type">5</span> | <span class="type">English</span> | <span class="type">francs</span>   |    <span class="type">90</span></span><br><span class="line">          <span class="number">2</span> |  <span class="type">4</span> | <span class="type">English</span> | <span class="type">matiler</span>  |    <span class="type">75</span></span><br><span class="line">          <span class="number">3</span> |  <span class="type">6</span> | <span class="type">English</span> | <span class="type">tutu</span>     |    <span class="type">60</span></span><br><span class="line">          <span class="number">1</span> |  <span class="type">8</span> | <span class="type">Math</span>    | <span class="type">matiler</span>  |    <span class="type">99</span></span><br><span class="line">          <span class="number">2</span> |  <span class="type">7</span> | <span class="type">Math</span>    | <span class="type">francs</span>   |    <span class="type">80</span></span><br><span class="line">          <span class="number">3</span> |  <span class="type">9</span> | <span class="type">Math</span>    | <span class="type">tutu</span>     |    <span class="type">65</span></span><br><span class="line">(<span class="number">9</span> rows)</span><br></pre></td></tr></table></figure></p><p>以上row_number()窗口函数显示的是分组后记录的行号，如果不指定partition属性，row_number()窗口函数显示表所有记录的行号，类似oracle里的ROWNUM，如下。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT  row_number() OVER (ORDER BY id) AS rownum ,* FROM score;</span><br><span class="line"> rownum | <span class="type">id</span> | <span class="type">subject</span> | <span class="type">stu_name</span> | <span class="type">score</span></span><br><span class="line">--------+----+---------+----------+-------</span><br><span class="line">      <span class="number">1</span> |  <span class="type">1</span> | <span class="type">Chinese</span> | <span class="type">francs</span>   |    <span class="type">70</span></span><br><span class="line">      <span class="number">2</span> |  <span class="type">2</span> | <span class="type">Chinese</span> | <span class="type">matiler</span>  |    <span class="type">70</span></span><br><span class="line">      <span class="number">3</span> |  <span class="type">3</span> | <span class="type">Chinese</span> | <span class="type">tutu</span>     |    <span class="type">80</span></span><br><span class="line">      <span class="number">4</span> |  <span class="type">4</span> | <span class="type">English</span> | <span class="type">matiler</span>  |    <span class="type">75</span></span><br><span class="line">      <span class="number">5</span> |  <span class="type">5</span> | <span class="type">English</span> | <span class="type">francs</span>   |    <span class="type">90</span></span><br><span class="line">      <span class="number">6</span> |  <span class="type">6</span> | <span class="type">English</span> | <span class="type">tutu</span>     |    <span class="type">60</span></span><br><span class="line">      <span class="number">7</span> |  <span class="type">7</span> | <span class="type">Math</span>    | <span class="type">francs</span>   |    <span class="type">80</span></span><br><span class="line">      <span class="number">8</span> |  <span class="type">8</span> | <span class="type">Math</span>    | <span class="type">matiler</span>  |    <span class="type">99</span></span><br><span class="line">      <span class="number">9</span> |  <span class="type">9</span> | <span class="type">Math</span>    | <span class="type">tutu</span>     |    <span class="type">65</span></span><br><span class="line">(<span class="number">9</span> rows)</span><br></pre></td></tr></table></figure><h2 id="avg-OVER-窗口函数"><a href="#avg-OVER-窗口函数" class="headerlink" title="avg() OVER()窗口函数"></a>avg() OVER()窗口函数</h2><p>聚合函数后接OVER属性的窗口函数表示在一个查询结果集上应用聚合函数，本小节将演示avg()聚合函数后接OVER属性的窗口函数，此窗口函数用来计算分组后数据的平均值。</p><p>查询每名学生学习成绩并且显示课程的平均分，通常是先计算出课程的平均分，之后score表再与平均分表关联查询，如下所示：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT s.subject, s.stu_name,s.score, tmp.avgscore</span><br><span class="line">  FROM score s</span><br><span class="line">  LEFT JOIN (SELECT subject, avg(score) avgscore FROM score GROUP BY subject) tmp</span><br><span class="line">    ON s.subject = tmp.subject;</span><br><span class="line"> subject | <span class="type">stu_name</span> | <span class="type">score</span> |      <span class="type">avgscore</span>       </span><br><span class="line">---------+----------+-------+---------------------</span><br><span class="line"> Chinese | <span class="type">francs</span>   |    <span class="type">70</span> | <span class="type">73</span><span class="number">.3333333333333333</span></span><br><span class="line"> Chinese | <span class="type">matiler</span>  |    <span class="type">70</span> | <span class="type">73</span><span class="number">.3333333333333333</span></span><br><span class="line"> Chinese | <span class="type">tutu</span>     |    <span class="type">80</span> | <span class="type">73</span><span class="number">.3333333333333333</span></span><br><span class="line"> English | <span class="type">matiler</span>  |    <span class="type">75</span> | <span class="type">75</span><span class="number">.0000000000000000</span></span><br><span class="line"> English | <span class="type">francs</span>   |    <span class="type">90</span> | <span class="type">75</span><span class="number">.0000000000000000</span></span><br><span class="line"> English | <span class="type">tutu</span>     |    <span class="type">60</span> | <span class="type">75</span><span class="number">.0000000000000000</span></span><br><span class="line"> Math    | <span class="type">francs</span>   |    <span class="type">80</span> | <span class="type">81</span><span class="number">.3333333333333333</span></span><br><span class="line"> Math    | <span class="type">matiler</span>  |    <span class="type">99</span> | <span class="type">81</span><span class="number">.3333333333333333</span></span><br><span class="line"> Math    | <span class="type">tutu</span>     |    <span class="type">65</span> | <span class="type">81</span><span class="number">.3333333333333333</span></span><br><span class="line">(<span class="number">9</span> rows)</span><br></pre></td></tr></table></figure></p><p>使用窗口函数很容易实现以上需求，如下所示：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT subject,stu_name, score, avg(score) OVER(PARTITION BY subject) FROM score;</span><br><span class="line"> subject | <span class="type">stu_name</span> | <span class="type">score</span> |         <span class="type">avg</span>         </span><br><span class="line">---------+----------+-------+---------------------</span><br><span class="line"> Chinese | <span class="type">francs</span>   |    <span class="type">70</span> | <span class="type">73</span><span class="number">.3333333333333333</span></span><br><span class="line"> Chinese | <span class="type">matiler</span>  |    <span class="type">70</span> | <span class="type">73</span><span class="number">.3333333333333333</span></span><br><span class="line"> Chinese | <span class="type">tutu</span>     |    <span class="type">80</span> | <span class="type">73</span><span class="number">.3333333333333333</span></span><br><span class="line"> English | <span class="type">matiler</span>  |    <span class="type">75</span> | <span class="type">75</span><span class="number">.0000000000000000</span></span><br><span class="line"> English | <span class="type">francs</span>   |    <span class="type">90</span> | <span class="type">75</span><span class="number">.0000000000000000</span></span><br><span class="line"> English | <span class="type">tutu</span>     |    <span class="type">60</span> | <span class="type">75</span><span class="number">.0000000000000000</span></span><br><span class="line"> Math    | <span class="type">francs</span>   |    <span class="type">80</span> | <span class="type">81</span><span class="number">.3333333333333333</span></span><br><span class="line"> Math    | <span class="type">matiler</span>  |    <span class="type">99</span> | <span class="type">81</span><span class="number">.3333333333333333</span></span><br><span class="line"> Math    | <span class="type">tutu</span>     |    <span class="type">65</span> | <span class="type">81</span><span class="number">.3333333333333333</span></span><br><span class="line">(<span class="number">9</span> rows)</span><br></pre></td></tr></table></figure></p><p>以上查询前三列来源于表score，第四列表示取课程的平均分，PARTITION BY subject表示根据字段subject进行分组。</p><h2 id="rank-窗口函数"><a href="#rank-窗口函数" class="headerlink" title="rank()窗口函数"></a>rank()窗口函数</h2><p>rank()窗口函数和row_number()窗口函数相似，主要区别为当组内某行字段值相同时，行号重复并且行号产生间隙（手册上解释为gaps），如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT rank() OVER(PARTITION BY subject ORDER BY score),* FROM score;</span><br><span class="line"> rank | <span class="type">id</span> | <span class="type">subject</span> | <span class="type">stu_name</span> | <span class="type">score</span> </span><br><span class="line">------+----+---------+----------+-------</span><br><span class="line">    <span class="number">1</span> |  <span class="type">2</span> | <span class="type">Chinese</span> | <span class="type">matiler</span>  |    <span class="type">70</span></span><br><span class="line">    <span class="number">1</span> |  <span class="type">1</span> | <span class="type">Chinese</span> | <span class="type">francs</span>   |    <span class="type">70</span></span><br><span class="line">    <span class="number">3</span> |  <span class="type">3</span> | <span class="type">Chinese</span> | <span class="type">tutu</span>     |    <span class="type">80</span></span><br><span class="line">    <span class="number">1</span> |  <span class="type">6</span> | <span class="type">English</span> | <span class="type">tutu</span>     |    <span class="type">60</span></span><br><span class="line">    <span class="number">2</span> |  <span class="type">4</span> | <span class="type">English</span> | <span class="type">matiler</span>  |    <span class="type">75</span></span><br><span class="line">    <span class="number">3</span> |  <span class="type">5</span> | <span class="type">English</span> | <span class="type">francs</span>   |    <span class="type">90</span></span><br><span class="line">    <span class="number">1</span> |  <span class="type">9</span> | <span class="type">Math</span>    | <span class="type">tutu</span>     |    <span class="type">65</span></span><br><span class="line">    <span class="number">2</span> |  <span class="type">7</span> | <span class="type">Math</span>    | <span class="type">francs</span>   |    <span class="type">80</span></span><br><span class="line">    <span class="number">3</span> |  <span class="type">8</span> | <span class="type">Math</span>    | <span class="type">matiler</span>  |    <span class="type">99</span></span><br><span class="line">(<span class="number">9</span> rows)</span><br></pre></td></tr></table></figure></p><p>以上示例中，Chinese课程前两条记录的score字段值都为70，因此前两行的rank字段值1，而第三行的rank字段值为3，产生了间隙。</p><h2 id="dense-rank-窗口函数"><a href="#dense-rank-窗口函数" class="headerlink" title="dense_rank ()窗口函数"></a>dense_rank ()窗口函数</h2><p>dense_rank ()窗口函数和rank ()窗口函数相似，主要区别为当组内某行字段值相同时，虽然行号重复，但行号不产生间隙（手册上解释为gaps），如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT dense_rank() OVER(PARTITION BY subject ORDER BY score),* FROM score;</span><br><span class="line"> dense_rank | <span class="type">id</span> | <span class="type">subject</span> | <span class="type">stu_name</span> | <span class="type">score</span> </span><br><span class="line">------------+----+---------+----------+-------</span><br><span class="line">          <span class="number">1</span> |  <span class="type">2</span> | <span class="type">Chinese</span> | <span class="type">matiler</span>  |    <span class="type">70</span></span><br><span class="line">          <span class="number">1</span> |  <span class="type">1</span> | <span class="type">Chinese</span> | <span class="type">francs</span>   |    <span class="type">70</span></span><br><span class="line">          <span class="number">2</span> |  <span class="type">3</span> | <span class="type">Chinese</span> | <span class="type">tutu</span>     |    <span class="type">80</span></span><br><span class="line">          <span class="number">1</span> |  <span class="type">6</span> | <span class="type">English</span> | <span class="type">tutu</span>     |    <span class="type">60</span></span><br><span class="line">          <span class="number">2</span> |  <span class="type">4</span> | <span class="type">English</span> | <span class="type">matiler</span>  |    <span class="type">75</span></span><br><span class="line">          <span class="number">3</span> |  <span class="type">5</span> | <span class="type">English</span> | <span class="type">francs</span>   |    <span class="type">90</span></span><br><span class="line">          <span class="number">1</span> |  <span class="type">9</span> | <span class="type">Math</span>    | <span class="type">tutu</span>     |    <span class="type">65</span></span><br><span class="line">          <span class="number">2</span> |  <span class="type">7</span> | <span class="type">Math</span>    | <span class="type">francs</span>   |    <span class="type">80</span></span><br><span class="line">          <span class="number">3</span> |  <span class="type">8</span> | <span class="type">Math</span>    | <span class="type">matiler</span>  |    <span class="type">99</span></span><br><span class="line">(<span class="number">9</span> rows)</span><br></pre></td></tr></table></figure></p><p>以上示例中，Chinese课程前两行的rank字段值1，而第三行的rank字段值为2，没有产生间隙。</p><p>PostgreSQL还支持很多其它内置窗口函数，例如、lag()、first_values()、last_values()等，篇幅关系不再介绍。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章主要介绍了PostgreSQL支持的一些高级SQL特性，例如WITH查询、批量插入、RETURNING返回DML修改的数据、UPSERT、数据抽样、聚合函数、窗口函数，了解这些功能能够简化SQL代码，提升开发效率，并且实现普通查询不容易实现的功能，希望通过阅读本章读者能够在实际工作中应用SQL高级特性，同时挖掘PostgreSQL的其他高级SQL特性。</p><p>PosgreSQL不仅是关系型数据库，同时支持NoSQL特性，关于PostgreSQL的NoSQL特性将在下篇文章中介绍。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://postgres.fun/20181218101700.html">PostgreSQL何以支持丰富的NoSQL特性?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;PostgreSQL数据库在SQL和NoSQL方面具有很多丰富的特性，本文将从 &lt;a href=&quot;https://item.jd.com/1
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: 推荐一个网站访问速度测试工具</title>
    <link href="https://postgres.fun/20181108144300.html"/>
    <id>https://postgres.fun/20181108144300.html</id>
    <published>2018-11-08T06:34:25.000Z</published>
    <updated>2018-11-08T06:41:31.398Z</updated>
    
    <content type="html"><![CDATA[<p>经同事推荐一个不错的网站速度测试工具，地址: <a href="http://tool.chinaz.com/speedtest" target="_blank" rel="noopener">http://tool.chinaz.com/speedtest</a></p><p>输入网站链接，即可返回不同地域访问网站的速度情况。</p><h1 id="国内测速"><a href="#国内测速" class="headerlink" title="国内测速"></a>国内测速</h1><p>输入博客地址，返回下图:</p><p><img src="/images/site_speed.png" alt=""></p><p>从上图看出一片绿色，大部分地区访问博客时间在1秒以下，访问速度还不错！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经同事推荐一个不错的网站速度测试工具，地址: &lt;a href=&quot;http://tool.chinaz.com/speedtest&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tool.chinaz.com/speedtest&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: 给每篇文章添加宣传栏</title>
    <link href="https://postgres.fun/20181107111000.html"/>
    <id>https://postgres.fun/20181107111000.html</id>
    <published>2018-11-07T03:10:53.000Z</published>
    <updated>2018-11-07T03:22:26.178Z</updated>
    
    <content type="html"><![CDATA[<p>最近琢磨如何在Hexo的每一篇博客底部添加宣传栏，用于推广，一时半会没找到，咨询了<a href="https://lruihao.cn/" target="_blank" rel="noopener">博採眾長</a>(Hexo高手)，可以通过修改打赏文件添加宣传信息，也就是说在打赏模块嵌入宣传栏。</p><p>Hexo部署博客最好要会一点前端，但这方面几乎不会，组内有个妹子会前端开发，在她的帮助下，终于实现了这个功能，对二位的帮助再次表示感谢！</p><h1 id="修改-reward-swig"><a href="#修改-reward-swig" class="headerlink" title="修改 reward.swig"></a>修改 reward.swig</h1><p>打赏模块对应的文件为 <code>/d/hexo/themes/next/layout/_macro/reward.swig</code> ，修改此文件添加5行代码，用于添加宣传栏功能，修改前记得做好文件备份，如下:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"># 以下5行新增</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:left"</span>&gt;</span>最后推荐和张文升共同编写的《PostgreSQL实战》，本书基于PostgreSQL 10 编写，共18章，重点介绍SQL高级特性、并行查询、分区表、物理复制、逻辑复制、备份恢复、高可用、性能优化、PostGIS等，涵盖大量实战用例！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:left"</span>&gt;</span>购买链接：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://item.jd.com/12405774.html"</span>&gt;</span>https://item.jd.com/12405774.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/PostgreSQL实战_small.png"</span> <span class="attr">alt</span>=<span class="string">"PostgreSQL实战"</span> <span class="attr">style</span>=<span class="string">"margin: 0 auto;"</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; theme.reward_comment &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"rewardButton"</span> <span class="attr">disable</span>=<span class="string">"enable"</span> <span class="attr">onclick</span>=<span class="string">"var qr = document.getElementById('QR'); if (qr.style.display === 'none') &#123;qr.style.display='block';&#125; else &#123;qr.style.display='none'&#125;"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('reward.donate') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"QR"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.wechatpay %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wechat"</span> <span class="attr">style</span>=<span class="string">"display: inline-block"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"wechat_qr"</span> <span class="attr">src</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.wechatpay &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">alt</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.author &#125;&#125;</span><span class="xml"><span class="tag"><span class="string"> </span></span></span><span class="template-variable">&#123;&#123; __('reward.wechatpay') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('reward.wechatpay') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.alipay %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"alipay"</span> <span class="attr">style</span>=<span class="string">"display: inline-block"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"alipay_qr"</span> <span class="attr">src</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.alipay &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">alt</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.author &#125;&#125;</span><span class="xml"><span class="tag"><span class="string"> </span></span></span><span class="template-variable">&#123;&#123; __('reward.alipay') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('reward.alipay') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.bitcoin %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bitcoin"</span> <span class="attr">style</span>=<span class="string">"display: inline-block"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"bitcoin_qr"</span> <span class="attr">src</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.bitcoin &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">alt</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; theme.author &#125;&#125;</span><span class="xml"><span class="tag"><span class="string"> </span></span></span><span class="template-variable">&#123;&#123; __('reward.bitcoin') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('reward.bitcoin') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>修改完后需重启博客生效。</p><h1 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h1><p>查看本文底部的书籍宣传信息查看效果，达到了预期效果!</p><h1 id="设置指定文章不打赏"><a href="#设置指定文章不打赏" class="headerlink" title="设置指定文章不打赏"></a>设置指定文章不打赏</h1><p>如何设置指定文章不打赏呢？<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 官方不提供是否打赏参数，可以通过修改 post.swig 源码实现此功能，详见 <a href="https://lruihao.cn/noreward.html" target="_blank" rel="noopener">如何设置指定文章不打赏？</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://lruihao.cn/noreward.html" target="_blank" rel="noopener">如何设置指定文章不打赏？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近琢磨如何在Hexo的每一篇博客底部添加宣传栏，用于推广，一时半会没找到，咨询了&lt;a href=&quot;https://lruihao.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博採眾長&lt;/a&gt;(Hexo高手)，可以通过修改打赏文件添加宣传信息，也
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 11 有哪些引人瞩目的新特性？</title>
    <link href="https://postgres.fun/20181102084300.html"/>
    <id>https://postgres.fun/20181102084300.html</id>
    <published>2018-11-02T00:43:12.000Z</published>
    <updated>2018-11-05T14:05:40.918Z</updated>
    
    <content type="html"><![CDATA[<p>2018-10-18 <a href="https://www.postgresql.org/about/news/1894/" target="_blank" rel="noopener">PostgreSQL官网</a> 宣布 PostgreSQL 11 正式版发行，PostgreSQL 11 重点对性能进行了提升和功能完善，特别是对大数据库和高计算负载的情况下进行了增强，主要包括以下:</p><ul><li>对分区表进行了大幅的改进和增强。</li><li>增加了对存储过程的支持，存储过程支持事务。</li><li>增强了并行查询能力和并行数据定义能力。</li><li>增加了对 just-in-time (JIT) 编译的支持，加速SQL中的表达式执行效率。</li></ul><p>最近对PostgreSQL以上新特性和其它功能完善做了演示，希望对PostgreSQL从业者有帮助，详见以下。</p><h1 id="分区表的改进"><a href="#分区表的改进" class="headerlink" title="分区表的改进"></a>分区表的改进</h1><p>PostgreSQL 11 对分区表进行了重大的改进，例如增加了哈希分区、支持创建主键、外键、索引、支持UPDATE分区键以及增加了默认分区，这些功能的完善极大的增强了分区表的可用性，详见以下:</p><ul><li><a href="https://postgres.fun/20180920082700.html">PostgreSQL11: 分区表增加哈希分区</a></li><li><a href="https://postgres.fun/20180920155600.html">PostgreSQL11：分区表支持创建主键、外键、索引</a></li><li><a href="https://postgres.fun/20180920214600.html">PostgreSQL11: 分区表支持UPDATE分区键</a></li><li><a href="https://postgres.fun/20180921101300.html">PostgreSQL11: 分区表增加 Default Partition</a></li></ul><h1 id="支持存储过程"><a href="#支持存储过程" class="headerlink" title="支持存储过程"></a>支持存储过程</h1><p>PostgreSQL 11 版本一个重量级新特性是对存储过程的支持，同时支持存储过程嵌入事务，存储过程是很多 PostgreSQL 从业者期待已久的特性，尤其是很多从Oracle转到PostgreSQL朋友。</p><p>尽管PostgreSQL提供函数可以实现大多数存储过程的功能，但函数不支持部分提交，换句话说，函数中的SQL要么都执行成功，要不全部返回失败，详见以下:</p><ul><li><a href="https://postgres.fun/20180925162500.html">PostgreSQL11: 支持存储过程(SQL Stored Procedures)</a></li></ul><h1 id="并行能力的增强"><a href="#并行能力的增强" class="headerlink" title="并行能力的增强"></a>并行能力的增强</h1><p>PostgreSQL 11 版本在并行方面得到较大增强，例如支持并行创建索引、并行Hash Join、并行 CREATE TABLE .. AS等，详见以下:</p><ul><li><a href="https://postgres.fun/20180922222100.html">PostgreSQL11：支持并行创建索引(Parallel Index Builds)</a></li><li><a href="https://postgres.fun/20180924134200.html">PostgreSQL11：支持并行哈希连接(Parallel Hash Joins)</a></li></ul><h1 id="增加对Just-in-Time-JIT-编译的支持"><a href="#增加对Just-in-Time-JIT-编译的支持" class="headerlink" title="增加对Just-in-Time (JIT)编译的支持"></a>增加对Just-in-Time (JIT)编译的支持</h1><p>PostgreSQL 11 版本的一个重量级新特性是引入了 JIT (Just-in-Time) 编译来加速SQL中的表达式计算效率。</p><p>JIT 表达式的编译使用LLVM项目编译器来提升在WHERE条件、指定列表、聚合以及一些内部操作表达式的编译执行，详见以下:</p><ul><li><a href="https://postgres.fun/20181031161700.html">PostgreSQL11: 增加对JIT(just-in-time)编译的支持提升分析型SQL执行效率</a></li></ul><h1 id="其它功能完善"><a href="#其它功能完善" class="headerlink" title="其它功能完善"></a>其它功能完善</h1><p>此外， PostgreSQL 11 增强了其它新特性以增加用户体验，以下列举了主要的几点，详见以下:</p><ul><li><a href="https://postgres.fun/20180929100400.html">PostgreSQL11: 新增非空默认值字段不需要重写表</a></li><li><a href="https://postgres.fun/20180930094300.html">PostgreSQL11: Indexs With Include Columns</a></li><li><a href="https://postgres.fun/20181013215100.html">PostgreSQL11: 新增三个默认角色</a></li><li><a href="https://postgres.fun/20181015113300.html">PostgreSQL11: 可通过GRNAT权限下放的四个系统函数</a></li><li><a href="https://postgres.fun/20181016214500.html">PostgreSQL11: Initdb/Pg_resetwal支持修改WAL文件大小</a></li><li><a href="https://postgres.fun/20181017123400.html">PostgreSQL11: psql 新增 \gdesc 显示查询结果的列名和类型</a></li><li><a href="https://postgres.fun/20181018084300.html">PostgreSQL11: psql 新增变量记录SQL语句的执行情况和错误</a></li></ul><h1 id="关于PostgreSQL"><a href="#关于PostgreSQL" class="headerlink" title="关于PostgreSQL"></a>关于PostgreSQL</h1><p>PostgreSQL 号称世界上最先进的开源关系型数据库，PostgreSQL 全球社区是一个由数千名用户、开发人员、公司或其他组织组成。 PostgreSQL 起源于加利福利亚的伯克利大学，有30年以上历史，经历了无数次开发升级。</p><p>PostgreSQL 的出众之处在于不仅具有商业数据库的功能特性，同时在扩展性、安全性、稳定性等高级数据库特性方面超越了它们。</p><p>若想获取到更多关于PostgreSQL的信息或者加入PostgreSQL社区，请浏览官网 <a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL.org</a> 。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/about/news/1894/" target="_blank" rel="noopener">PostgreSQL 11 Released!</a></li><li><a href="http://postgres.cn/release/v/49" target="_blank" rel="noopener">PostgreSQL 11.0 正式版更新版本发布说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018-10-18 &lt;a href=&quot;https://www.postgresql.org/about/news/1894/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PostgreSQL官网&lt;/a&gt; 宣布 PostgreSQL 11 正式版发行，P
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 增加对JIT(just-in-time)编译的支持提升分析型SQL执行效率</title>
    <link href="https://postgres.fun/20181031161700.html"/>
    <id>https://postgres.fun/20181031161700.html</id>
    <published>2018-10-31T08:17:15.000Z</published>
    <updated>2018-11-16T00:20:02.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-JIT"><a href="#关于-JIT" class="headerlink" title="关于 JIT"></a>关于 JIT</h1><p>PostgreSQL 11 版本的一个重量级新特性是引入了 <a href="https://www.postgresql.org/docs/11/static/jit.html" target="_blank" rel="noopener"><strong>JIT (Just-in-Time)</strong></a> 编译来加速SQL中的表达式计算效率。</p><p>JIT 表达式的编译使用LLVM项目编译器的架构来提升在WHERE条件、指定列表、聚合以及一些内部操作表达式的编译执行。</p><p>使用 JIT 必须在首先编译安装 <a href="https://llvm.org/" target="_blank" rel="noopener"><strong>LLVM</strong></a> ，之后编译安装 PostgreSQL 时设置 <code>--with-llvm</code> 选项，本文主要包括两部分，如下:</p><ul><li>CentOS7 编译安装 LLVM。</li><li>CentOS7 编译安装PostgreSQL 11，启用并演示 JIT。</li></ul><h1 id="JIT-使用场景"><a href="#JIT-使用场景" class="headerlink" title="JIT 使用场景"></a>JIT 使用场景</h1><p>JIT 常用于CPU密集型SQL(分析统计SQL)，执行很快的SQL使用JIT由于产生一定开销，反而可能引起性能下降。</p><h1 id="手册-Release说明"><a href="#手册-Release说明" class="headerlink" title="手册 Release说明"></a>手册 Release说明</h1><blockquote><p>Add <strong>Just-in-Time (JIT)</strong> compilation of some parts of query plans to improve execution speed (Andres Freund)<br>This feature requires LLVM to be available. It is not currently enabled by default, even in builds that support it.</p></blockquote><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>操作系统: CentOS Linux release 7.4.1708 (Core)<br>硬件环境: 8核4G/80G 的云主机</p><h1 id="LLVM安装前提条件"><a href="#LLVM安装前提条件" class="headerlink" title="LLVM安装前提条件"></a>LLVM安装前提条件</h1><p>LLVM 安装依赖较多，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">The</span> <span class="selector-tag">minimum</span> <span class="selector-tag">required</span> <span class="selector-tag">version</span> <span class="selector-tag">of</span> <span class="selector-tag">LLVM</span> <span class="selector-tag">is</span> <span class="selector-tag">currently</span> 3<span class="selector-class">.9</span>  <span class="selector-tag">--</span>本实验使用 <span class="selector-tag">LLVM</span> 5<span class="selector-class">.0</span><span class="selector-class">.2</span></span><br><span class="line"><span class="selector-tag">CMake</span>. <span class="selector-tag">Version</span> 3<span class="selector-class">.4</span><span class="selector-class">.3</span> <span class="selector-tag">is</span> <span class="selector-tag">the</span> <span class="selector-tag">minimum</span> <span class="selector-tag">required</span>.          <span class="selector-tag">--</span>本实验使用 <span class="selector-tag">Cmake</span> 3<span class="selector-class">.12</span><span class="selector-class">.3</span></span><br><span class="line"><span class="selector-tag">Python</span> 2<span class="selector-class">.7</span> <span class="selector-tag">or</span> <span class="selector-tag">newer</span> <span class="selector-tag">is</span> <span class="selector-tag">required</span>                        <span class="selector-tag">--</span>本实验使用 <span class="selector-tag">Python</span> 2<span class="selector-class">.7</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">GCC</span> <span class="selector-tag">version</span> <span class="selector-tag">must</span> <span class="selector-tag">be</span> <span class="selector-tag">at</span> <span class="selector-tag">least</span> 4<span class="selector-class">.8</span>!                      <span class="selector-tag">--</span>本实验使用 <span class="selector-tag">gcc</span> 4<span class="selector-class">.8</span><span class="selector-class">.5</span></span><br></pre></td></tr></table></figure><h1 id="安装-Cmake-3-12-3"><a href="#安装-Cmake-3-12-3" class="headerlink" title="安装 Cmake 3.12.3"></a>安装 Cmake 3.12.3</h1><p>下载并编译安装 cmake 3.12.3，如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget -c https://cmake.org/files/v3.12/cmake-3.12.3.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xvf cmake-3.12.3.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> cmake-3.12.3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./bootstrap</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make -j 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p><h1 id="安装Python-2-7-9"><a href="#安装Python-2-7-9" class="headerlink" title="安装Python 2.7.9"></a>安装Python 2.7.9</h1><p>下载并编译安装 python 2.7.9，如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget -c https://www.python.org/downloads/release/python-279/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar jxvf Python-2.7.9.tgz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> Python-2.7.9</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><h1 id="安装-LLVM-5-0-2"><a href="#安装-LLVM-5-0-2" class="headerlink" title="安装 LLVM 5.0.2"></a>安装 LLVM 5.0.2</h1><p>LLVM 的安装步骤较繁琐，并且编译安装过程时间较长，性能好的机器能减少编译时间，注意操作系统需启用 <code>swap</code>，否则编译过程中会报错,本人开始编译安装时没有启用 <code>swap</code>，折腾了很久。</p><h2 id="下载LLVM安装介质"><a href="#下载LLVM安装介质" class="headerlink" title="下载LLVM安装介质"></a>下载LLVM安装介质</h2><p>在 <a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener"><strong>LLVM官网</strong></a>下载安装介质，如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">llvm-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">cfe-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">clang-tools-extra-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">compiler-rt-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">libcxx-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">libcxxabi-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">libunwind-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br></pre></td></tr></table></figure><h2 id="编译安装LLVM"><a href="#编译安装LLVM" class="headerlink" title="编译安装LLVM"></a>编译安装LLVM</h2><p>解压 llvm-5.0.2.src.tar.xz<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /opt/soft_bak/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xvf llvm-5.0.2.src.tar.xz </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv llvm-5.0.2.src llvm</span></span><br></pre></td></tr></table></figure></p><p>解压安装包并重命名，目录结构对应如下，如下:</p><table><thead><tr><th style="text-align:left">安装包</th><th style="text-align:left">安装目录</th></tr></thead><tbody><tr><td style="text-align:left">llvm-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/llvm</td></tr><tr><td style="text-align:left">cfe-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/tools/clang</td></tr><tr><td style="text-align:left">clang-tools-extra-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/tools/clang/tools/extra</td></tr><tr><td style="text-align:left">compiler-rt-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/compiler-rt</td></tr><tr><td style="text-align:left">libcxx-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/libcxx</td></tr><tr><td style="text-align:left">libcxxabi-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/libcxxabi</td></tr><tr><td style="text-align:left">libunwind-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/libunwind</td></tr></tbody></table><p>LLVM 官网的其它安装包非必须，可根据情况选择。</p><p>编译安装 LLVM，如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /opt/soft_bak/llvm_build/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /opt/soft_bak/llvm_build/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cmake -G <span class="string">"Unix Makefiles"</span> -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span>/llvm -DCLANG_DEFAULT_CXX_STDLIB=libc++ -DCMAKE_BUILD_TYPE=<span class="string">"Release"</span> /opt/soft_bak/llvm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make -j 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p><p>设置环境变量，如下:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/usr/local/llvm/bin</span></span><br><span class="line">export LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span><span class="symbol">:/usr/local/llvm/lib</span></span><br></pre></td></tr></table></figure></p><p>查看版本<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@pghost7 ~]</span># <span class="selector-tag">llvm-cat</span> <span class="selector-tag">--version</span></span><br><span class="line"><span class="selector-tag">LLVM</span> (<span class="attribute">http</span>:<span class="comment">//llvm.org/):</span></span><br><span class="line">  LLVM version <span class="number">5.0</span>.<span class="number">2</span></span><br><span class="line">  Optimized build.</span><br><span class="line">  Default <span class="attribute">target</span>: x86_64-unknown-linux-gnu</span><br><span class="line">  Host <span class="attribute">CPU</span>: broadwell</span><br><span class="line"></span><br><span class="line">[root<span class="variable">@pghost7</span> ~]# clang --version</span><br><span class="line">clang version <span class="number">5.0</span>.<span class="number">2</span> (tags/RELEASE_502/final)</span><br><span class="line"><span class="attribute">Target</span>: x86_64-unknown-linux-gnu</span><br><span class="line">Thread <span class="attribute">model</span>: posix</span><br><span class="line"><span class="attribute">InstalledDir</span>: /usr/local/llvm/bin</span><br></pre></td></tr></table></figure></p><p>至此 LLVM 已安装成功。</p><h1 id="PostgreSQL-11-安装"><a href="#PostgreSQL-11-安装" class="headerlink" title="PostgreSQL 11 安装"></a>PostgreSQL 11 安装</h1><p>安装相关包，如下:<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc <span class="built_in">readline</span> <span class="built_in">readline</span>-devel zlib zlib-devel python-devel</span><br></pre></td></tr></table></figure></p><p>下载PostgreSQL 11 并编译安装，编译时指定 <code>--with-llvm</code> 选项， 如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget -c https://ftp.postgresql.org/pub/<span class="built_in">source</span>/v11.0/postgresql-11.0.tar.bz2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xvf postgresql-11.0.tar.bz2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">./configure --prefix=/opt/pgsql_11.0 --with-wal-blocksize=16 -with-pgport=1930 --with-llvm LLVM_CONFIG=<span class="string">'/usr/local/llvm/bin/llvm-config'</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make wolrd -j 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install-world</span></span><br></pre></td></tr></table></figure><p>设置 <code>.bash_profile</code> ，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGPORT</span>=1930</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGUSER</span>=postgres</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGDATA</span>=/database/pg11/pg_root</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">LANG</span>=en_US.utf8</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGHOME</span>=/opt/pgsql_11.0</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">LD_LIBRARY_PATH</span>=<span class="variable">$PGHOME</span>/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DATE</span>=`date +<span class="string">"%Y%m%d%H%M"</span>`</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PGHOME</span>/bin:$PATH:.</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">MANPATH</span>=<span class="variable">$PGHOME</span>/share/man:$MANPATH</span><br><span class="line">alias <span class="attribute">rm</span>=<span class="string">'rm -i'</span></span><br><span class="line">alias <span class="attribute">ll</span>=<span class="string">'ls -lh'</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>initdb</code> 初始化数据库，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost7 pg_root]$ initdb -D /database/pg11/pg_root <span class="attribute">-E</span>=UTF8 <span class="attribute">--locale</span>=C -U postgres -W</span><br></pre></td></tr></table></figure></p><p>postgresql.conf 设置以下 JIT 配置参数，其它参数按需配置，这里不贴出，如下:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - Other Defaults -</span></span><br><span class="line"><span class="comment">#dynamic_library_path = '$libdir'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jit</span> = <span class="literal">on</span>                                # allow JIT compilation</span><br><span class="line"><span class="attr">jit_provider</span> = <span class="string">'llvmjit'</span>                # JIT implementation to use</span><br></pre></td></tr></table></figure><p>设置 pg_hba.conf，如下:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host all        all     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>       md5</span><br></pre></td></tr></table></figure></p><p>之后启动数据库，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost7 pg_root]$ pg_ctl start</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-31 11:13:26.154 CST [19742] LOG:  listening on IPv4<span class="built_in"> address </span><span class="string">"0.0.0.0"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-31 11:13:26.154 CST [19742] LOG:  listening on<span class="built_in"> IPv6 address </span><span class="string">"::"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-31 11:13:26.159 CST [19742] LOG:  listening on Unix socket <span class="string">"/tmp/.s.PGSQL.1930"</span></span><br><span class="line">2018-10-31 11:13:26.185 CST [19742] LOG:  redirecting log output <span class="keyword">to</span><span class="built_in"> logging </span>collector process</span><br><span class="line">2018-10-31 11:13:26.185 CST [19742] HINT:  Future log output will appear <span class="keyword">in</span> directory <span class="string">"log"</span>.</span><br><span class="line"> done</span><br><span class="line">server started</span><br></pre></td></tr></table></figure></p><h1 id="JIT-测试"><a href="#JIT-测试" class="headerlink" title="JIT 测试"></a>JIT 测试</h1><p>以下大致演示 JIT，测试样例很简单，不做充分的性能测试，有兴趣的朋友可以做 TPC-H 性能测试。</p><h2 id="测试数据准备"><a href="#测试数据准备" class="headerlink" title="测试数据准备"></a>测试数据准备</h2><p>创建一张5千万的数据表，如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_llvm1(a int4, b int4, info <span class="built_in">text</span>, ctime <span class="keyword">timestamp</span>(<span class="number">6</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_llvm1 (a,b,info,ctime) <span class="keyword">SELECT</span> n,n*<span class="number">2</span>,n||<span class="string">'_llvm1'</span>,clock_timestamp() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">50000000</span>) n;</span><br></pre></td></tr></table></figure><h2 id="查看-JIT-相关参数"><a href="#查看-JIT-相关参数" class="headerlink" title="查看 JIT 相关参数"></a>查看 JIT 相关参数</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT name,setting FROM pg_settings WHERE name LIKE 'jit%';</span></span><br><span class="line">          name           |<span class="string"> setting</span></span><br><span class="line"><span class="string">-------------------------+---------</span></span><br><span class="line"><span class="string"> jit                     </span>|<span class="string"> on</span></span><br><span class="line"><span class="string"> jit_above_cost          </span>|<span class="string"> 100000</span></span><br><span class="line"><span class="string"> jit_debugging_support   </span>|<span class="string"> off</span></span><br><span class="line"><span class="string"> jit_dump_bitcode        </span>|<span class="string"> off</span></span><br><span class="line"><span class="string"> jit_expressions         </span>|<span class="string"> on</span></span><br><span class="line"><span class="string"> jit_inline_above_cost   </span>|<span class="string"> 500000</span></span><br><span class="line"><span class="string"> jit_optimize_above_cost </span>|<span class="string"> 500000</span></span><br><span class="line"><span class="string"> jit_profiling_support   </span>|<span class="string"> off</span></span><br><span class="line"><span class="string"> jit_provider            </span>|<span class="string"> llvmjit</span></span><br><span class="line"><span class="string"> jit_tuple_deforming     </span>|<span class="string"> on</span></span><br><span class="line"><span class="string">(10 rows)</span></span><br></pre></td></tr></table></figure><h2 id="开启-JIT"><a href="#开启-JIT" class="headerlink" title="开启 JIT"></a>开启 JIT</h2><p>开启 JIT，执行计划如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">postgres</span>=# <span class="builtin-name">SET</span> JIT = on;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="attribute">postgres</span>=# EXPLAIN ANALYZE SELECT count(*),sum(a) <span class="keyword">FROM</span> t_llvm1 WHERE (a+b) &gt; 10;</span><br><span class="line">                                                                    QUERY PLAN</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Finalize Aggregate  (<span class="attribute">cost</span>=576982.30..576982.31 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2148.607..2148.608 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=1)</span><br><span class="line">   -&gt;  Gather  (<span class="attribute">cost</span>=576981.86..576982.28 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2148.457..2153.185 <span class="attribute">rows</span>=5 <span class="attribute">loops</span>=1)</span><br><span class="line">         Workers Planned: 4</span><br><span class="line">         Workers Launched: 4</span><br><span class="line">         -&gt;  Partial Aggregate  (<span class="attribute">cost</span>=575981.86..575981.88 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2134.919..2134.919 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=5)</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_llvm1  (<span class="attribute">cost</span>=0.00..555148.48 <span class="attribute">rows</span>=4166677 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=105.597..1516.253 <span class="attribute">rows</span>=9999999 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: ((a + b) &gt; 10)</span><br><span class="line">                     Rows Removed by Filter: 1</span><br><span class="line"> Planning Time: 0.078 ms</span><br><span class="line"> JIT:</span><br><span class="line">   Functions: 28</span><br><span class="line">   Options: Inlining <span class="literal">true</span>, Optimization <span class="literal">true</span>, Expressions <span class="literal">true</span>, Deforming <span class="literal">true</span></span><br><span class="line">   Timing: Generation 5.842 ms, Inlining 226.589 ms, Optimization 191.071 ms, Emission 107.027 ms, Total 530.529 ms</span><br><span class="line"> Execution Time: 2154.870 ms</span><br><span class="line">(14 rows)</span><br></pre></td></tr></table></figure><p>从以上看出执行计划中包含 JIT 编译信息，执行时间为 2154 ms 左右。</p><h2 id="关闭-JIT"><a href="#关闭-JIT" class="headerlink" title="关闭 JIT"></a>关闭 JIT</h2><p>关闭 JIT,查看执行计划和扫行时间，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">postgres</span>=# <span class="builtin-name">SET</span> JIT = off;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="attribute">postgres</span>=# EXPLAIN ANALYZE SELECT count(*),sum(a) <span class="keyword">FROM</span> t_llvm1 WHERE (a+b) &gt; 10;</span><br><span class="line">                                                                   QUERY PLAN</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Finalize Aggregate  (<span class="attribute">cost</span>=576982.30..576982.31 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2382.035..2382.035 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=1)</span><br><span class="line">   -&gt;  Gather  (<span class="attribute">cost</span>=576981.86..576982.28 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2381.939..2385.143 <span class="attribute">rows</span>=5 <span class="attribute">loops</span>=1)</span><br><span class="line">         Workers Planned: 4</span><br><span class="line">         Workers Launched: 4</span><br><span class="line">         -&gt;  Partial Aggregate  (<span class="attribute">cost</span>=575981.86..575981.88 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2371.143..2371.143 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=5)</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_llvm1  (<span class="attribute">cost</span>=0.00..555148.48 <span class="attribute">rows</span>=4166677 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.560..1600.125 <span class="attribute">rows</span>=9999999 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: ((a + b) &gt; 10)</span><br><span class="line">                     Rows Removed by Filter: 1</span><br><span class="line"> Planning Time: 0.083 ms</span><br><span class="line"> Execution Time: 2385.209 ms</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure></p><p>从以上看出执行计划中没有包含 JIT 信息，执行时间为 2385 ms 左右，开启JIT性能提升了9.7% 左右。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/jit.html" target="_blank" rel="noopener">Chapter 32. Just-in-Time Compilation (JIT)</a></li><li><a href="https://llvm.org/" target="_blank" rel="noopener">The LLVM Compiler Infrastructure</a></li><li><a href="https://www.oschina.net/news/94492/postgresql-llvm-jit-landing" target="_blank" rel="noopener">PostgreSQL 已包含对 LLVM JIT 支持的提交性能将飙升</a></li><li><a href="https://blog.dbi-services.com/how-to-compile-postgresql-11-with-support-for-jit-compilation-on-rhelcentos-7/" target="_blank" rel="noopener">How to compile PostgreSQL 11 with support for JIT compilation on RHEL/CentOS 7</a></li><li><a href="https://www.citusdata.com/blog/2018/09/11/postgresql-11-just-in-time/" target="_blank" rel="noopener">PostgreSQL 11 and Just In Time Compilation of Queries</a></li><li><a href="https://llvm.org/devmtg/2016-09/slides/Melnik-PostgreSQLLLVM.pdf" target="_blank" rel="noopener">Speeding up query execution in PostgreSQL using LLVM JIT compiler</a></li><li><a href="http://postgres.cn/release/v/49" target="_blank" rel="noopener">PostgreSQL 11.0 正式版更新版本发布说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于-JIT&quot;&gt;&lt;a href=&quot;#关于-JIT&quot; class=&quot;headerlink&quot; title=&quot;关于 JIT&quot;&gt;&lt;/a&gt;关于 JIT&lt;/h1&gt;&lt;p&gt;PostgreSQL 11 版本的一个重量级新特性是引入了 &lt;a href=&quot;https://www.pos
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: 声明博客的许可协议</title>
    <link href="https://postgres.fun/20181028211900.html"/>
    <id>https://postgres.fun/20181028211900.html</id>
    <published>2018-10-28T13:19:09.000Z</published>
    <updated>2018-10-28T13:27:17.605Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 博客可以声明许可协议，在 <a href="https://creativecommons.org/" target="_blank" rel="noopener"><strong>creativecommons</strong></a> 网站上找适合自己的许可。</p><p>常用的许可协议如下:</p><ul><li>CC BY(署名)</li><li>CC BY-SA(署名-相同方式共享)</li><li>CC BY-ND(署名-禁止演绎)</li><li>CC BY-NC(署名-非商业性使用)</li><li>CC BY-NC-SA(署名-非商业性使用-相同方式共享 )</li><li>CC BY-NC-ND(署名-非商业性使用-禁止演绎)</li></ul><p>关于以上协议的解释详见 <a href="https://creativecommons.org/licenses/" target="_blank" rel="noopener">https://creativecommons.org/licenses/</a> 。</p><p>本博客计划使用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"><strong>CC BY-SA</strong></a> 协议。</p><h1 id="关于CC-BY-SA协议"><a href="#关于CC-BY-SA协议" class="headerlink" title="关于CC BY-SA协议"></a>关于CC BY-SA协议</h1><p><strong> You are free to:</strong></p><blockquote><p><strong>Attribution</strong> — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.<br><strong>ShareAlike</strong> — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</p></blockquote><p><strong>Under the following terms:</strong></p><blockquote><p><strong>Attribution</strong> — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.<br><strong>ShareAlike</strong> — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</p></blockquote><p>简单的说， CC BY-SA 协议允许其它人下载、发行、修改，即使是出于商业目的，但必须给出原创出处并指明原创身份，他人发行此作品采取的许可必须和原创作者采取的许可相同。</p><h1 id="设置网站的许可协议"><a href="#设置网站的许可协议" class="headerlink" title="设置网站的许可协议"></a>设置网站的许可协议</h1><p>修改主题配置文件 /d/hexo/themes/next/_config.yml 如下参数:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">CC</span> <span class="string">BY-SA</span> <span class="number">4.0</span></span><br><span class="line"><span class="attr">  license_url:</span> <span class="attr">https://creativecommons.org/licenses/by-sa/4.0/</span></span><br></pre></td></tr></table></figure><p>之后刷新博客，如下。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>之后博客的每篇文章的底部显示许可信息，如下:</p><p><img src="/images/xuke.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://creativecommons.org/licenses/" target="_blank" rel="noopener">creativecommons</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hexo 博客可以声明许可协议，在 &lt;a href=&quot;https://creativecommons.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;creativecommons&lt;/strong&gt;&lt;/a&gt; 网站上找适合自己的许可。
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: 给博客添加百度统计</title>
    <link href="https://postgres.fun/20181027203300.html"/>
    <id>https://postgres.fun/20181027203300.html</id>
    <published>2018-10-27T12:33:52.000Z</published>
    <updated>2018-10-28T12:21:56.387Z</updated>
    
    <content type="html"><![CDATA[<p>当Hexo博客被百度、必应、谷歌搜索引擎收录以后，有件重要的工作是统计博客的访问情况，比如博客的历史访问量、搜索关键字、访问来源、访问地域等统计数据。</p><p> <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener"><strong>百度统计</strong></a> 能方便的完成网站访问量分析统计，本文简单演示下Hexo+Next博客配置百度统计功能。</p><h1 id="开通百度统计帐号"><a href="#开通百度统计帐号" class="headerlink" title="开通百度统计帐号"></a>开通百度统计帐号</h1><p>在 <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener"><strong>百度统计</strong></a> 注册帐号。</p><p>帐号注册成功后，在网站列表中添加目标网站。</p><h1 id="获取跟踪代码"><a href="#获取跟踪代码" class="headerlink" title="获取跟踪代码"></a>获取跟踪代码</h1><p>网站添加之后在代码管理模块选择代码获取，可以看到如下代码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> _hmt = _hmt || [];</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></span><br><span class="line"><span class="actionscript">  hm.src = <span class="string">"https://hm.baidu.com/hm.js?____________________"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">  s.parentNode.insertBefore(hm, s);</span></span><br><span class="line"><span class="undefined">&#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码需要用户添加到网站全部页面的 <code>&lt;/head&gt;</code> 标签前，Next主题已对百度统计进行配置优化，只需要配置主题配置文件即可，下面会详细介绍。</p><p>其中 hm.js? 后面的字符串为用户的 key 值，将 key 值记录下来，后面会用到。</p><h1 id="配置主题配置文件"><a href="#配置主题配置文件" class="headerlink" title="配置主题配置文件"></a>配置主题配置文件</h1><p>配置主题配置文件 /d/hexo/themes/next/_config.yml ，配置 baidu_analytics 参数，如下:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Baidu </span>Analytics ID</span><br><span class="line"><span class="keyword">baidu_analytics: </span>上面步骤中记录的百度统计里用户的key值。</span><br></pre></td></tr></table></figure><p>修改完参数后执行 <code>hexo g</code> 和 <code>hexo d</code> 命令部署博客。</p><h1 id="验证百度统计"><a href="#验证百度统计" class="headerlink" title="验证百度统计"></a>验证百度统计</h1><p>之后仍然在代码管理模块的代码获取页面进行验证，如下图:</p><p><img src="/images/baidu_tongji_check.png" alt=""></p><p>上图表示验证通过。</p><p>一般过20分钟左右就可以看到网站分析数据，过了几小时后，已经看到博客的访问统计分析数据，如下图:</p><p><img src="/images/baidu_tongji_report1.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.jcsama.com/2016/01/25/hexo-baido-analytics/" target="_blank" rel="noopener">Hexo添加百度统计</a></li><li><a href="http://visugar.com/2017/08/01/20170801HexoPlugins/" target="_blank" rel="noopener">Hexo博客添加SEO-评论系统-阅读统计-站长统计</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当Hexo博客被百度、必应、谷歌搜索引擎收录以后，有件重要的工作是统计博客的访问情况，比如博客的历史访问量、搜索关键字、访问来源、访问地域等统计数据。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://tongji.baidu.com/web/welcome/login&quot; 
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>经历了20多天的闭站备案，终于完成了网站备案。</title>
    <link href="https://postgres.fun/20181026113200.html"/>
    <id>https://postgres.fun/20181026113200.html</id>
    <published>2018-10-26T03:32:22.000Z</published>
    <updated>2018-10-26T06:15:52.237Z</updated>
    
    <content type="html"><![CDATA[<p>经历了20多天的闭站备案，终于完成了网站备案，博客总算有了个合法的身份，这里简单分离下备案经历。</p><p>备案分两部分:</p><ul><li>域名备案</li><li>公安备案</li></ul><h1 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h1><p>原则上部署到国内服务器的网站都需要进行域名备案（部署到外海服务器不需要进行域名备案），到空间提供商备案即可，例如，我的博客部署在腾讯云主机，到腾讯云提交备案申请即可。</p><p>备案主要分为以下四个步骤：</p><ul><li>填写备案类型</li><li>填写备案信息</li><li>办理幕布拍照</li><li>提交管局审核</li></ul><p>其中前三个步骤较快，每一步仅需1-2工作日；第四步为提交管局审核，通常为20个工作日以内，我这次从提交管局审核到审批通过仅需要9个工作日，比预期快，整个域名备案大概花了15个工作日。</p><p>关于备案的详细信息， 参考 <a href="https://cloud.tencent.com/product/ba##" target="_blank" rel="noopener"><strong>域名备案参考</strong></a> 。</p><p>域名备案审核通过之后可以到 <a href="http://www.miitbeian.gov.cn/publish/query/indexFirst.action" target="_blank" rel="noopener"><strong>域名信息备案系统</strong></a> 进行验证，如下:</p><p><img src="/images/beian1.png" alt=""></p><h1 id="公安备案"><a href="#公安备案" class="headerlink" title="公安备案"></a>公安备案</h1><p>完成域名备案后，会提示请于备案完成后的30日内登陆全国公安机关互联网站安全管理服务平台办理公安备案，虽然是个人博客，建议做下公安备案 ，公安备案在 <a href="http://www.beian.gov.cn/portal/index?token=054de65f-4aa5-4942-8a3f-8c59168f51ce" target="_blank" rel="noopener"><strong>互联网安全管理服务平台</strong></a>  进行。</p><p>公安备案手册，详见 <a href="http://bbs.qcloud.com/thread-28158-1-1.html" target="_blank" rel="noopener"><strong>公安备案教程1</strong></a>  和 <a href="https://boke112.com/3338.html" target="_blank" rel="noopener"><strong>公安备案教程2</strong></a></p><p>公安备案审核通过之后可以到  <a href="http://www.beian.gov.cn/portal/recordQuery?token=054de65f-4aa5-4942-8a3f-8c59168f51ce" target="_blank" rel="noopener"><strong>互联网安全管理服务平台</strong></a>  进行查询，如下:</p><p><img src="/images/gongan1.png" alt=""></p><p>公安备案比较快，上午提交，下午就收到审核通过消息了，各地审批时间会有差异。</p><h1 id="添加备案信息到博客"><a href="#添加备案信息到博客" class="headerlink" title="添加备案信息到博客"></a>添加备案信息到博客</h1><p>备案完成后建议将网站备案号放到博客底部，具体操作如下:</p><p>修改 /d/hexo/themes/next/layout/_third-party/analytics/busuanzi-counter.swig 文件，底部添加如下一段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div &gt;</span><br><span class="line">&lt;a target=<span class="string">"_blank"</span> href=<span class="string">"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010402003707"</span> style=<span class="string">"display:inline-block;text-decoration:none;height:20px;line-height:20px;"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/gongan.png"</span> <span class="attr">style</span>=<span class="string">"float:left;"</span>/&gt;</span>浙公网安备 33010402003707号<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.miitbeian.gov.cn"</span>&gt;</span>浙ICP备18045927号<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src="/images/postgres_fun_beian.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://cloud.tencent.com/product/ba" target="_blank" rel="noopener">https://cloud.tencent.com/product/ba</a></li><li><a href="http://bbs.qcloud.com/thread-28158-1-1.html" target="_blank" rel="noopener">http://bbs.qcloud.com/thread-28158-1-1.html</a></li><li><a href="https://boke112.com/3338.html" target="_blank" rel="noopener">https://boke112.com/3338.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经历了20多天的闭站备案，终于完成了网站备案，博客总算有了个合法的身份，这里简单分离下备案经历。&lt;/p&gt;
&lt;p&gt;备案分两部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域名备案&lt;/li&gt;
&lt;li&gt;公安备案&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;域名备案&quot;&gt;&lt;a href=&quot;#域名备案&quot; 
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: psql 新增变量记录SQL语句的执行情况和错误</title>
    <link href="https://postgres.fun/20181018084300.html"/>
    <id>https://postgres.fun/20181018084300.html</id>
    <published>2018-10-18T00:43:41.000Z</published>
    <updated>2018-10-18T00:44:57.641Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本新增加 ERROR、SQLSTATE、ROW_COUNT、LAST_ERROR_MESSAGE、LAST_ERROR_SQLSTATE 五个变量用来记录SQL语句的执行结果状态和错误信息。</p><p>这些变量的值随着SQL执行后进行刷新，主要用来编写脚本时捕获SQL的执行结果。</p><h1 id="Release-说明"><a href="#Release-说明" class="headerlink" title="Release 说明"></a>Release 说明</h1><blockquote><p>Add psql variables to report query activity and errors (Fabien Coelho)<br>Specifically, the new variables are ERROR, SQLSTATE, ROW_COUNT, LAST_ERROR_MESSAGE, and LAST_ERROR_SQLSTATE.</p></blockquote><h1 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h1><p>关于这几个变量的说明如下:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**ERROR**</span><br><span class="line"><span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> <span class="keyword">last</span> SQL query failed, <span class="literal">false</span> <span class="keyword">if</span> <span class="keyword">it</span> succeeded. See also SQLSTATE.</span><br><span class="line"></span><br><span class="line">**SQLSTATE**</span><br><span class="line">The error code (see Appendix A) associated <span class="keyword">with</span> <span class="keyword">the</span> <span class="keyword">last</span> SQL query is failure, <span class="keyword">or</span> <span class="number">00000</span> <span class="keyword">if</span> <span class="keyword">it</span> succeeded.</span><br><span class="line"></span><br><span class="line">**ROW_COUNT**</span><br><span class="line">The <span class="built_in">number</span> <span class="keyword">of</span> rows returned <span class="keyword">or</span> affected <span class="keyword">by</span> <span class="keyword">the</span> <span class="keyword">last</span> SQL query, <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">the</span> query failed <span class="keyword">or</span> did <span class="keyword">not</span> report <span class="keyword">a</span> row count.</span><br><span class="line"></span><br><span class="line">**LAST_ERROR_MESSAGE**</span><br><span class="line">**LAST_ERROR_SQLSTATE**</span><br><span class="line">The primary error message <span class="keyword">and</span> associated SQLSTATE code <span class="keyword">for</span> <span class="keyword">the</span> most recent failed query <span class="keyword">in</span> <span class="keyword">the</span> current psql session, <span class="keyword">or</span> <span class="keyword">an</span> <span class="literal">empty</span> <span class="keyword">string</span> <span class="keyword">and</span> <span class="number">00000</span> <span class="keyword">if</span> no error has occurred <span class="keyword">in</span> <span class="keyword">the</span> current session.</span><br></pre></td></tr></table></figure><p>这几个变更的解释很容易理解，下面演示下。</p><h1 id="演示：SQL执行成功"><a href="#演示：SQL执行成功" class="headerlink" title="演示：SQL执行成功"></a>演示：SQL执行成功</h1><p>正常执行一条SQL,执行后查看 ERROR、SQLSTATE、ROW_COUNT 变量，如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; SELECT * <span class="keyword">FROM</span> generate_series(1,3);</span><br><span class="line"> generate_series</span><br><span class="line">-----------------</span><br><span class="line">               1</span><br><span class="line">               2</span><br><span class="line">               3</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo <span class="keyword">:ERROR</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :SQLSTATE</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :ROW_COUNT</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="演示：SQL执行失败"><a href="#演示：SQL执行失败" class="headerlink" title="演示：SQL执行失败"></a>演示：SQL执行失败</h1><p>SQL执行失败,执行后查看 ERROR、SQLSTATE、ROW_COUNT 变更，如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT *,afcd <span class="keyword">FROM</span> generate_series(1,3);</span><br><span class="line">ERROR:  column <span class="string">"afcd"</span> does <span class="keyword">not</span> exist</span><br><span class="line">LINE 1: SELECT *,afcd <span class="keyword">FROM</span> generate_series(1,3);</span><br><span class="line">                 ^</span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo <span class="keyword">:ERROR</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :SQLSTATE</span><br><span class="line">42703</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :ROW_COUNT</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :LAST_ERROR_MESSAGE</span><br><span class="line">column <span class="string">"afcd"</span> does <span class="keyword">not</span> exist</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :LAST_ERROR_SQLSTATE</span><br><span class="line">42703</span><br></pre></td></tr></table></figure><p>SQLSTATE 变量返回SQL报错代码，SQL报错代码可参考手册 <a href="https://www.postgresql.org/docs/11/static/errcodes-appendix.html" target="_blank" rel="noopener">PostgreSQL Error Codes</a> 。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/app-psql.html" target="_blank" rel="noopener">psql</a></li><li><a href="https://www.postgresql.org/docs/11/static/errcodes-appendix.html" target="_blank" rel="noopener">PostgreSQL Error Codes</a></li><li><a href="https://www.depesz.com/2017/09/21/waiting-for-postgresql-11-add-psql-variables-to-track-successfailure-of-sql-queries/" target="_blank" rel="noopener">Waiting for PostgreSQL 11 – Add psql variables to track success/failure of SQL queries.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本新增加 ERROR、SQLSTATE、ROW_COUNT、LAST_ERROR_MESSAGE、LAST_ERROR_SQLSTATE 五个变量用来记录SQL语句的执行结果状态和错误信息。&lt;/p&gt;
&lt;p&gt;这些变量的值随着SQL执行后进行刷新，
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="psql" scheme="https://postgres.fun/tags/psql/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: psql 新增 \gdesc 显示查询结果的列名和类型</title>
    <link href="https://postgres.fun/20181017123400.html"/>
    <id>https://postgres.fun/20181017123400.html</id>
    <published>2018-10-17T04:34:42.000Z</published>
    <updated>2018-10-17T13:10:53.928Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 的 <code>psql</code> 新增 \gdesc 选项，此选项可以返回查询结果的列名和类型，而不实际执行SQL。</p><h1 id="Release-说明"><a href="#Release-说明" class="headerlink" title="Release 说明"></a>Release 说明</h1><blockquote><p>psql<br>Add psql command \gdesc to display the column names and types of the query output (Pavel Stehule)</p></blockquote><h1 id="gdesc-选项说明"><a href="#gdesc-选项说明" class="headerlink" title="\gdesc 选项说明"></a>\gdesc 选项说明</h1><blockquote><p><strong>\gdesc</strong><br>Shows the description (that is, the column names and data types) of the result of the current query buffer. The query is not actually executed; however, if it contains some type of syntax error, that error will be reported in the normal way.<br>If the current query buffer is empty, the most recently sent query is described instea</p></blockquote><p>\gdesc 只是显示查询结果的列名和类型，并不实际执行SQL，下面演示下。</p><h1 id="gdesc-选项演示"><a href="#gdesc-选项演示" class="headerlink" title="\gdesc 选项演示"></a>\gdesc 选项演示</h1><p>数据库中存在一张大表big，结构如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \d big</span><br><span class="line">                                  Table <span class="string">"francs.big"</span></span><br><span class="line">  Column   |             <span class="built_in"> Type </span>             | Collation | Nullable |      Default</span><br><span class="line">-----------+--------------------------------+-----------+----------+-------------------</span><br><span class="line"> user_id   | integer                        |           |          |</span><br><span class="line"> user_name | text                           |           |          |</span><br><span class="line"> ctime     | timestamp(6) without time zone |           |          | clock_timestamp()</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"idx_big_ctime"</span> btree (ctime)</span><br><span class="line">    <span class="string">"idx_big_username"</span> btree (user_name)</span><br></pre></td></tr></table></figure><p>执行以下查询，如下:<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> \timing</span></span><br><span class="line">Timing is on.</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> SELECT count(<span class="name"><span class="builtin-name">*</span></span>),sum(<span class="name">hashtext</span>(<span class="name">user_name</span>)) FROM big<span class="comment">;</span></span></span><br><span class="line">  count   |      sum</span><br><span class="line">----------+----------------</span><br><span class="line"> 30000000 | 11924569894736</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 1347.527 ms (00:01.348)</span><br></pre></td></tr></table></figure></p><p>执行时间为 1347 ms 左右。</p><p>使用 \gdesc 选项查询，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT count(*),sum(hashtext(user_name)) <span class="keyword">FROM</span> big \gdesc</span><br><span class="line"> Column |  Type</span><br><span class="line">--------+--------</span><br><span class="line"> count  | bigint</span><br><span class="line"> sum    | bigint</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">Time: 0.634 ms</span><br></pre></td></tr></table></figure></p><p>以上返回了查询结果的列和数据类型，执行很快，只需要 0.634 ms，可见没有实际执行SQL。</p><p>另一个示例，查询 pg_class 系统表，如下:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM pg_class \gdesc</span><br><span class="line">       Column        <span class="string">|     Type</span></span><br><span class="line">---------------------+--------------</span><br><span class="line"> relname             <span class="string">| name</span></span><br><span class="line"> relnamespace        <span class="string">| oid</span></span><br><span class="line"> reltype             <span class="string">| oid</span></span><br><span class="line"> reloftype           <span class="string">| oid</span></span><br><span class="line"> relowner            <span class="string">| oid</span></span><br><span class="line"> relam               <span class="string">| oid</span></span><br><span class="line"> relfilenode         <span class="string">| oid</span></span><br><span class="line"> reltablespace       <span class="string">| oid</span></span><br><span class="line"> relpages            <span class="string">| integer</span></span><br><span class="line"> reltuples           <span class="string">| real</span></span><br><span class="line"> relallvisible       <span class="string">| integer</span></span><br><span class="line"> reltoastrelid       <span class="string">| oid</span></span><br><span class="line"> relhasindex         <span class="string">| boolean</span></span><br><span class="line"> relisshared         <span class="string">| boolean</span></span><br><span class="line"> relpersistence      <span class="string">| "</span>char<span class="string">"</span></span><br><span class="line"> relkind             <span class="string">| "</span>char<span class="string">"</span></span><br><span class="line"> relnatts            <span class="string">| smallint</span></span><br><span class="line"> relchecks           <span class="string">| smallint</span></span><br><span class="line"> relhasoids          <span class="string">| boolean</span></span><br><span class="line"> relhasrules         <span class="string">| boolean</span></span><br><span class="line"> relhastriggers      <span class="string">| boolean</span></span><br><span class="line"> relhassubclass      <span class="string">| boolean</span></span><br><span class="line"> relrowsecurity      <span class="string">| boolean</span></span><br><span class="line"> relforcerowsecurity <span class="string">| boolean</span></span><br><span class="line"> relispopulated      <span class="string">| boolean</span></span><br><span class="line"> relreplident        <span class="string">| "</span>char<span class="string">"</span></span><br><span class="line"> relispartition      <span class="string">| boolean</span></span><br><span class="line"> relrewrite          <span class="string">| oid</span></span><br><span class="line"> relfrozenxid        <span class="string">| xid</span></span><br><span class="line"> relminmxid          <span class="string">| xid</span></span><br><span class="line"> relacl              <span class="string">| aclitem[]</span></span><br><span class="line"> reloptions          <span class="string">| text[]</span></span><br><span class="line"> relpartbound        <span class="string">| pg_node_tree</span></span><br><span class="line">(<span class="number">33</span> rows)</span><br></pre></td></tr></table></figure></p><p>这个特性不需要实际执行SQL就能返回查询结果的列和数据类型，在某些特定场景比较有用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.depesz.com/2017/09/21/waiting-for-postgresql-11-add-gdesc-psql-command/" target="_blank" rel="noopener">Waiting for PostgreSQL 11 – Add \gdesc psql command</a></li><li><a href="https://www.postgresql.org/docs/11/static/app-psql.html" target="_blank" rel="noopener">psql</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 的 &lt;code&gt;psql&lt;/code&gt; 新增 \gdesc 选项，此选项可以返回查询结果的列名和类型，而不实际执行SQL。&lt;/p&gt;
&lt;h1 id=&quot;Release-说明&quot;&gt;&lt;a href=&quot;#Release-说明&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="psql" scheme="https://postgres.fun/tags/psql/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: Initdb/Pg_resetwal支持修改WAL文件大小</title>
    <link href="https://postgres.fun/20181016214500.html"/>
    <id>https://postgres.fun/20181016214500.html</id>
    <published>2018-10-16T13:45:25.000Z</published>
    <updated>2018-10-16T13:50:07.882Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本的一个重要调整是支持 <code>initdb</code> 和 <code>pg_resetwal</code> 修改 WAL 文件大小，而 11 版本之前只能在编译安装 PostgreSQL 时设置 WAL 文件大小。这一特性能够方便 WAL 文件的管理。</p><h1 id="Release-的说明"><a href="#Release-的说明" class="headerlink" title="Release 的说明"></a>Release 的说明</h1><blockquote><p>Allow the WAL file size to be set via initdb (Beena Emerson)<br>Previously the 16MB default could only be changed at compile time.</p></blockquote><p>下面分别演示通过 <code>initdb</code> 和 <code>pg_resetwal</code> 修改 WAL 文件大小。</p><h1 id="使用-initdb-调整WAL文件大小"><a href="#使用-initdb-调整WAL文件大小" class="headerlink" title="使用 initdb 调整WAL文件大小"></a>使用 initdb 调整WAL文件大小</h1><p><code>initdb</code> 命令关于修改 WAL 文件大小选项，如下: </p><blockquote><p><strong>–wal-segsize=size</strong><br>Set the WAL segment size, in megabytes. This is the size of each individual file in the WAL log. The default size is 16 megabytes. The value must be a power of 2 between 1 and 1024 (megabytes). This option can only be set during initialization, and cannot be changed later.<br>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</p></blockquote><p>WAL 日志文件大小默认为16MB，该值必须是1到1024之间的2的次方，增大WAL文件大小能够减少WAL日志文件的产生。</p><p>初始化一个新的 PostgreSQL 数据库实例，指定WAL文件大小64MB，如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ initdb -E UTF8 <span class="attribute">--locale</span>=C <span class="attribute">--wal-segsize</span>=64 -D /home/pg11/data01 -U postgres -W</span><br><span class="line">The files belonging <span class="keyword">to</span> this database<span class="built_in"> system </span>will be owned by<span class="built_in"> user </span><span class="string">"pg11"</span>.</span><br><span class="line">This<span class="built_in"> user </span>must also own the<span class="built_in"> server </span>process.</span><br><span class="line"></span><br><span class="line">The database cluster will be initialized with locale <span class="string">"C"</span>.</span><br><span class="line">The<span class="built_in"> default </span>text search configuration will be <span class="builtin-name">set</span> <span class="keyword">to</span> <span class="string">"english"</span>.</span><br><span class="line"></span><br><span class="line">Data<span class="built_in"> page </span>checksums are disabled.</span><br><span class="line"></span><br><span class="line">Enter new superuser password: </span><br><span class="line">Enter it again: </span><br><span class="line"></span><br><span class="line">creating directory /home/pg11/data01 <span class="built_in">..</span>. ok</span><br><span class="line">creating subdirectories <span class="built_in">..</span>. ok</span><br><span class="line">selecting<span class="built_in"> default </span>max_connections <span class="built_in">..</span>. 100</span><br><span class="line">selecting<span class="built_in"> default </span>shared_buffers <span class="built_in">..</span>. 128MB</span><br><span class="line">selecting dynamic shared memory implementation <span class="built_in">..</span>. posix</span><br><span class="line">creating configuration files <span class="built_in">..</span>. ok</span><br><span class="line">running bootstrap<span class="built_in"> script </span><span class="built_in">..</span>. ok</span><br><span class="line">performing post-bootstrap initialization <span class="built_in">..</span>. ok</span><br><span class="line">syncing data <span class="keyword">to</span> disk <span class="built_in">..</span>. ok</span><br><span class="line"></span><br><span class="line">WARNING: enabling <span class="string">"trust"</span> authentication <span class="keyword">for</span> local connections</span><br><span class="line">You can change this by editing pg_hba.conf <span class="keyword">or</span> using the option -A, <span class="keyword">or</span></span><br><span class="line">--auth-local <span class="keyword">and</span> --auth-host, the next time you <span class="builtin-name">run</span> initdb.</span><br><span class="line"></span><br><span class="line">Success. You can now start the database<span class="built_in"> server </span>using:</span><br><span class="line"></span><br><span class="line">    pg_ctl -D /home/pg11/data01 -l logfile start</span><br></pre></td></tr></table></figure><p>修改 postgresql.conf 相关配置，之后启动数据库。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 data01]$ pg_ctl start -D /home/pg11/data01</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-16 15:58:16.714 CST [10583] LOG:  listening on<span class="built_in"> IPv6 address </span><span class="string">"::1"</span>,<span class="built_in"> port </span>1950</span><br><span class="line">2018-10-16 15:58:16.714 CST [10583] LOG:  listening on IPv4<span class="built_in"> address </span><span class="string">"127.0.0.1"</span>,<span class="built_in"> port </span>1950</span><br><span class="line">2018-10-16 15:58:16.731 CST [10583] LOG:  listening on Unix socket <span class="string">"/tmp/.s.PGSQL.1950"</span></span><br><span class="line">2018-10-16 15:58:16.762 CST [10584] LOG:  database<span class="built_in"> system </span>was shut down at 2018-10-16 15:56:46 CST</span><br><span class="line">2018-10-16 15:58:16.782 CST [10583] LOG:  database<span class="built_in"> system </span>is ready <span class="keyword">to</span> accept connections</span><br><span class="line"> done</span><br><span class="line">server started</span><br></pre></td></tr></table></figure><p>验证WAL文件大小，如下:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p<span class="name">g11</span>@pghost<span class="number">2</span> ~]$ ll /home/p<span class="name">g11</span>/data<span class="number">01</span>/pg_wal</span><br><span class="line">total <span class="number">65</span>M</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span>  <span class="number">64</span>M Oct <span class="number">16</span> <span class="number">16</span>:<span class="number">03</span> <span class="number">000000010000000000000001</span></span><br><span class="line">drwx------ <span class="number">2</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">4.0</span>K Oct <span class="number">16</span> <span class="number">15</span>:<span class="number">56</span> archive_status</span><br></pre></td></tr></table></figure><p>可见WAL文件大小为64MB。</p><h1 id="使用-pg-resetwal-调整WAL文件大小"><a href="#使用-pg-resetwal-调整WAL文件大小" class="headerlink" title="使用 pg_resetwal 调整WAL文件大小"></a>使用 pg_resetwal 调整WAL文件大小</h1><p><code>pg_resetwal</code> 用来重置WAL日志和一些控制信息，常用于数据库恢复场景，不到万不得已不轻易使用，以下演示使用<code>pg_resetwal</code>命令调整WAL日志文件大小，仅供测试参考，生产环境慎用。</p><p><code>pg_resetwal</code> 命令关于调整WAL文件大小的选项，如下:</p><blockquote><p><strong>–wal-segsize=wal_segment_size</strong><br>Set the new WAL segment size, in megabytes. The value must be set to a power of 2 between 1 and 1024 (megabytes). See the same option of initdb for more information.</p></blockquote><p>以下演示在已有PostgreSQL实例基础上调整WAL日志文件大小。</p><p>查看当前数据库的 pg_wal 目录，如下:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[p<span class="name">g11</span>@pghost<span class="number">2</span> pg_wal]$ ll /database/p<span class="name">g11</span>/pg_root/pg_wal/</span><br><span class="line">total <span class="number">2.3</span>G</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000013</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000014</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000015</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000016</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000017</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000018</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000019</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">00000001000000170000001</span>A</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">00000001000000170000001</span>B</span><br><span class="line">...</span><br><span class="line">省略</span><br><span class="line">drwx------ <span class="number">2</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>K Oct <span class="number">16</span> <span class="number">08</span>:<span class="number">38</span> archive_status</span><br></pre></td></tr></table></figure><p>pg_wal 目录中已有大量WAL日志文件，WAL文件大小为16MB，计划将WAL日志文件调整成64MB。</p><p><code>pg_resetwal</code> 操作时需要关闭数据库，如下。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_ctl stop -m fast</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> shut down<span class="built_in">..</span><span class="built_in">..</span> done</span><br><span class="line">server stopped</span><br></pre></td></tr></table></figure><p><code>pg_resetwal</code> 命令调整WAL日志文件大小为 64MB:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_resetwal --wal-segsize=<span class="number">64</span> -D /database/pg11/pg_root</span><br><span class="line">Write-ahead <span class="keyword">log</span> <span class="keyword">reset</span></span><br></pre></td></tr></table></figure></p><p>验证WAL文件大小,如下:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p<span class="name">g11</span>@pghost<span class="number">2</span> ~]$ ll /database/p<span class="name">g11</span>/pg_root/pg_wal/</span><br><span class="line">total <span class="number">65</span>M</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">64</span>M Oct <span class="number">16</span> <span class="number">08</span>:<span class="number">55</span> <span class="number">000000010000001700000029</span></span><br><span class="line">drwx------ <span class="number">2</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>K Oct <span class="number">16</span> <span class="number">08</span>:<span class="number">55</span> archive_status</span><br></pre></td></tr></table></figure><p>发现 pg_wal 目录中原有的WAL日志被清理，同时生成了大小为64MB新的WAL文件。</p><p>启动数据库提示 min_wal_size 参数至少需设置成 wal_segment_size 大小为 2 倍。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_ctl start</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-16 09:01:26.096 CST [24318] FATAL:  <span class="string">"min_wal_size"</span> must be at least twice <span class="string">"wal_segment_size"</span>.</span><br><span class="line">2018-10-16 09:01:26.096 CST [24318] LOG:  database<span class="built_in"> system </span>is shut down</span><br><span class="line"> stopped waiting</span><br><span class="line">pg_ctl: could <span class="keyword">not</span> start server</span><br><span class="line">Examine the log output.</span><br></pre></td></tr></table></figure></p><p>根据提示调整 postgresql.conf，设置如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">min_wal_size</span> = <span class="number">128</span>MB</span><br></pre></td></tr></table></figure></p><p>启动数据库正常，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_ctl start</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-16 09:02:45.680 CST [24614] LOG:  listening on IPv4<span class="built_in"> address </span><span class="string">"0.0.0.0"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-16 09:02:45.680 CST [24614] LOG:  listening on<span class="built_in"> IPv6 address </span><span class="string">"::"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-16 09:02:45.687 CST [24614] LOG:  listening on Unix socket <span class="string">"/tmp/.s.PGSQL.1930"</span></span><br><span class="line">2018-10-16 09:02:45.715 CST [24614] LOG:  redirecting log output <span class="keyword">to</span><span class="built_in"> logging </span>collector process</span><br><span class="line">2018-10-16 09:02:45.715 CST [24614] HINT:  Future log output will appear <span class="keyword">in</span> directory <span class="string">"log"</span>.</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>以上演示了 11 版本通过 <code>initdb</code> 和 <code>pg_resetwal</code> 调整WAL文件大小。</li><li><code>pg_resetwal</code> 会清除pg_wal目录的WAL文件，本博客的测试样例仅供参考，生产环境使用需慎重。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/app-initdb.html" target="_blank" rel="noopener">initdb</a></li><li><a href="https://www.postgresql.org/docs/11/static/app-pgresetwal.html" target="_blank" rel="noopener">pg_resetwal</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本的一个重要调整是支持 &lt;code&gt;initdb&lt;/code&gt; 和 &lt;code&gt;pg_resetwal&lt;/code&gt; 修改 WAL 文件大小，而 11 版本之前只能在编译安装 PostgreSQL 时设置 WAL 文件大小。这一特性能够方便 W
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 可通过GRNAT权限下放的四个系统函数</title>
    <link href="https://postgres.fun/20181015113300.html"/>
    <id>https://postgres.fun/20181015113300.html</id>
    <published>2018-10-15T03:33:49.000Z</published>
    <updated>2018-10-15T03:40:53.253Z</updated>
    
    <content type="html"><![CDATA[<p>涉及到数据库服务端文件读取的系统函数通常需要管理员权限，例如 pg_ls_dir()等系统函数，PostgreSQL 11 版本支持少量文件读取的系统函数权限下放，可通过 GRANT/REVOKE 将权限赋给普通用户，目前以下四个文件读取系统函数支持权限下放：</p><ul><li><strong>pg_ls_dir():</strong> List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</li><li><strong>pg_read_file()</strong>: Return the contents of a text file. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</li><li><strong>pg_read_binary_file():</strong> Return the contents of a file. Restricted to superusers by default, but other users can be granted EXECUTE to run the functio</li><li><strong>pg_stat_file():</strong> Return information about a file. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</li></ul><p>这四个函数在11版本之前只有超级用户才有权限使用。</p><h1 id="一、Release说明"><a href="#一、Release说明" class="headerlink" title="一、Release说明"></a>一、Release说明</h1><blockquote><p>Allow access to file system functions to be controlled by GRANT/REVOKE permissions, rather than superuser checks (Stephen Frost)<br>Specifically, these functions were modified: pg_ls_dir(), pg_read_file(), pg_read_binary_file(), pg_stat_file().</p></blockquote><p>以上四个函数使用上差异不大，本文仅演示其中两个函数。</p><h1 id="二、pg-ls-dir"><a href="#二、pg-ls-dir" class="headerlink" title="二、pg_ls_dir()"></a>二、pg_ls_dir()</h1><p>pg_ls_dir()函数可以列出数据库服务端数据目录的文件，11版本前只有超级用户才有权限调用。</p><h2 id="PostgreSQL-10-测试"><a href="#PostgreSQL-10-测试" class="headerlink" title="PostgreSQL 10 测试"></a>PostgreSQL 10 测试</h2><p>10 版本测试如下:<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[postgres@pghost1 ~]$ psql mydb pguser</span><br><span class="line">psql (10.0)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">mydb=&gt; SELECT pg_ls_dir('pg_wal');</span><br><span class="line"><span class="keyword">ERROR:  </span>must be superuser to get directory listings</span><br></pre></td></tr></table></figure></p><p>以上显示只有超级用户才有权限。</p><p>尝试将函数 pg_ls_dir()的可执行权限赋给普通用户 pguser。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; \c mydb postgres</span><br><span class="line">You are <span class="built_in">now</span> connected <span class="keyword">to</span> database <span class="string">"mydb"</span> as user <span class="string">"postgres"</span>.</span><br><span class="line"></span><br><span class="line">mydb=# GRANT <span class="keyword">EXECUTE</span> <span class="keyword">ON</span> <span class="keyword">FUNCTION</span> pg_ls_dir(text) <span class="keyword">TO</span> pguser;</span><br><span class="line">GRANT</span><br><span class="line"></span><br><span class="line">mydb=# \c mydb pguser</span><br><span class="line">You are <span class="built_in">now</span> connected <span class="keyword">to</span> database <span class="string">"mydb"</span> as user <span class="string">"pguser"</span>.</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">select</span> pg_ls_dir(<span class="comment">'pg_wal');</span></span><br><span class="line"><span class="keyword">ERROR</span>:  must be superuser <span class="keyword">to</span> <span class="keyword">get</span> directory listings</span><br></pre></td></tr></table></figure><p>以上看出，将函数pg_ls_dir()的执行权限赋给普通用户后，普通用户依然没有权限执行。</p><h2 id="PostgreSQL-11-测试"><a href="#PostgreSQL-11-测试" class="headerlink" title="PostgreSQL 11 测试"></a>PostgreSQL 11 测试</h2><p>将函数 pg_ls_dir()的可执行权限赋给普通用户 role11 。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT EXECUTE ON FUNCTION pg_ls_dir(text) <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure><p>以 role11 用户登录 francs 库测试:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT pg<span class="emphasis">_ls_</span>dir(<span class="emphasis">'pg_wal'</span>);</span><br><span class="line"><span class="code">        pg_ls_dir</span></span><br><span class="line">--------------------------</span><br><span class="line"><span class="code"> 00000001000000170000002B</span></span><br><span class="line"><span class="code"> 000000010000001700000025</span></span><br><span class="line"><span class="code"> 000000010000001700000034</span></span><br><span class="line"><span class="code"> 000000010000001700000073</span></span><br><span class="line"><span class="code"> ...省略</span></span><br></pre></td></tr></table></figure></p><p>普通用户执行 pg_ls_dir(‘pg_wal’) 函数成功，已查看到数据库服务端的 pg_wal 目录文件。</p><h1 id="三、pg-read-file"><a href="#三、pg-read-file" class="headerlink" title="三、pg_read_file()"></a>三、pg_read_file()</h1><p>pg_read_file()函数可以显示数据库服务端文本文件的内容，11版本前只有超级用户才有权限调用。</p><h2 id="PostgreSQL-10-测试-1"><a href="#PostgreSQL-10-测试-1" class="headerlink" title="PostgreSQL 10 测试"></a>PostgreSQL 10 测试</h2><p>10 版本测试，如下:<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[postgres@pghost1 ~]$ psql mydb pguser</span><br><span class="line">psql (10.0)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">mydb=&gt; SELECT pg_read_file('/home/postgres/t_copy2.txt');</span><br><span class="line"><span class="keyword">ERROR:  </span>must be superuser to read files</span><br></pre></td></tr></table></figure></p><p>显示只有超级用户才有权限执行。</p><h2 id="PostgreSQL-11-测试-1"><a href="#PostgreSQL-11-测试-1" class="headerlink" title="PostgreSQL 11 测试"></a>PostgreSQL 11 测试</h2><p>将函数 pg_read_file()的可执行权限赋给普通用户 role11 。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT EXECUTE ON FUNCTION pg_read_file(text) <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure><p>以role11用户登录francs库测试，如下:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; select pg<span class="emphasis">_read_</span>file (<span class="emphasis">'/home/pg11/t_copy2.txt'</span>);</span><br><span class="line"><span class="code"> pg_read_file</span></span><br><span class="line">--------------</span><br><span class="line"><span class="code"> 1       a   +</span></span><br><span class="line"><span class="code"> 2       b   +</span></span><br><span class="line"></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>赋权后，普通用户role11有权限执行 pg_read_file() 函数查看数据库服务端文件内容。</p><h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/functions-admin.html#FUNCTIONS-ADMIN-GENFILE-TABLE" target="_blank" rel="noopener">Generic File Access Functions</a></li><li><a href="https://postgres.fun/20181013215100.html">PostgreSQL11: 新增三个默认角色</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;涉及到数据库服务端文件读取的系统函数通常需要管理员权限，例如 pg_ls_dir()等系统函数，PostgreSQL 11 版本支持少量文件读取的系统函数权限下放，可通过 GRANT/REVOKE 将权限赋给普通用户，目前以下四个文件读取系统函数支持权限下放：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 新增三个默认角色</title>
    <link href="https://postgres.fun/20181013215100.html"/>
    <id>https://postgres.fun/20181013215100.html</id>
    <published>2018-10-13T13:51:35.000Z</published>
    <updated>2018-10-13T13:55:36.147Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 新增三个默认系统角色，如下：</p><ul><li>pg_read_server_files</li><li>pg_write_server_files</li><li>pg_execute_server_program</li></ul><p>这三个角色主要涉及数据库服务端文件的读写权限，例如使用copy命令或file_fdw模块读写数据库端文件的权限。</p><p>这些权限之前版本只有超级用户才具备，这三个默认角色的出现，使得可以将数据库服务端的文件的访问权限（目前仅包含copy命令或file_fdw模块）下放给普通用户。</p><h1 id="Release说明"><a href="#Release说明" class="headerlink" title="Release说明"></a>Release说明</h1><blockquote><p>Add default roles which control file system access (Stephen Frost)<br>Specifically, the new roles are: pg_read_server_files, pg_write_server_files, pg_execute_server_program. These roles now also control who can use COPY and extension file_fdw. Previously only superusers could use these functions, and that is still the default behavior.</p></blockquote><p>手册中说明很清楚，下面演示这三种角色的权限。</p><h1 id="pg-read-server-files"><a href="#pg-read-server-files" class="headerlink" title="pg_read_server_files"></a>pg_read_server_files</h1><p>pg_read_server_files 角色具有数据库服务端文件的读权限，例如使用copy命令或file_fdw模块读数据库端文件的权限。</p><p>在数据库主机 pghost2 家目录创建 t_copy.txt 文件并写入两行数据，如下：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>      a</span><br><span class="line"><span class="symbol">2 </span>      b</span><br></pre></td></tr></table></figure></p><p>以 francs 用户登录数据库 francs 创建测试表 t_copy 如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; CREATE TABLE t_copy(id int4, name text);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure></p><p>创建 role11 用户，如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=# <span class="keyword">CREATE</span> <span class="keyword">ROLE</span> role11 NOSUPERUSER <span class="keyword">PASSWORD</span> <span class="string">'role11'</span> LOGIN;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span></span><br></pre></td></tr></table></figure></p><p>以 role11 用户登录到 francs 数据库，执行 copy 命令，尝试将数据库服务端文件 t_copy.txt 文件的数据加载到表 t_copy 中，如下:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (<span class="number">11beta</span>3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">francs=&gt; COPY t_copy FROM <span class="string">'/home/pg11/t_copy.txt'</span>;</span><br><span class="line">ERROR:  must be superuser <span class="keyword">or</span> a member <span class="keyword">of</span> the pg_read_server_files role <span class="keyword">to</span> COPY <span class="keyword">from</span> a file</span><br><span class="line">HINT:  Anyone can COPY <span class="keyword">to</span> stdout <span class="keyword">or</span> <span class="keyword">from</span> stdin. psql s <span class="string">\copy</span> command also works <span class="keyword">for</span> anyone.</span><br></pre></td></tr></table></figure></p><p>以上报错，提示需要超级用户或具有pg_read_server_files权限才能使用 COPY 命令读取数据库服务端文件。</p><p>给 role11 用户赋 pg_read_server_files 角色权限，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; \c francs postgres</span><br><span class="line">You are now connected <span class="keyword">to</span> database <span class="string">"francs"</span> as<span class="built_in"> user </span><span class="string">"postgres"</span>.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT pg_read_server_files <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT ROLE</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT USAGE ON SCHEMA francs <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT INSERT ON francs.t_copy <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure></p><p>francs库中创建了模式 francs ，因此也需要将模式的使用权限赋给 role11，否则访问表时会报没有使用模式权限的错误；之后再赋予表的写权限。</p><p>再次测试成功，如下。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (<span class="number">11</span>beta3)</span><br><span class="line">Type <span class="string">"help"</span> for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">COPY</span><span class="bash"> francs.t_copy FROM <span class="string">'/home/pg11/t_copy.txt'</span>;</span></span><br><span class="line"><span class="bash">COPY 2</span></span><br></pre></td></tr></table></figure></p><h1 id="pg-write-server-files"><a href="#pg-write-server-files" class="headerlink" title="pg_write_server_files"></a>pg_write_server_files</h1><p>pg_write_server_files  角色具有数据库服务端文件的写权限，例如使用copy命令或file_fdw模块写数据库端文件的权限，接着演示。</p><p>以 role11 用户登录数据库 francs ，尝试导出表数据到数据库服务端。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11;</span><br><span class="line">psql (<span class="number">11beta</span>3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">francs=&gt; COPY francs.t_copy TO <span class="string">'/home/pg11/t_copy2.txt'</span>;</span><br><span class="line">ERROR:  must be superuser <span class="keyword">or</span> a member <span class="keyword">of</span> the pg_write_server_files role <span class="keyword">to</span> COPY <span class="keyword">to</span> a file</span><br><span class="line">HINT:  Anyone can COPY <span class="keyword">to</span> stdout <span class="keyword">or</span> <span class="keyword">from</span> stdin. psql s <span class="string">\copy</span> command also works <span class="keyword">for</span> anyone.</span><br></pre></td></tr></table></figure></p><p>赋权如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT pg_write_server_files <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT ROLE</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT SELECT ON francs.t_copy <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure></p><p>再次测试成功，如下<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11;</span><br><span class="line">psql (<span class="number">11</span>beta3)</span><br><span class="line">Type <span class="string">"help"</span> for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">COPY</span><span class="bash"> francs.t_copy TO <span class="string">'/home/pg11/t_copy2.txt'</span>;</span></span><br><span class="line"><span class="bash">COPY 2</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">francs=&gt; \! cat <span class="string">'/home/pg11/t_copy2.txt'</span></span></span><br><span class="line"><span class="bash">1       a</span></span><br><span class="line"><span class="bash">2       b</span></span><br></pre></td></tr></table></figure></p><p>可见，已将数据导出到数据库服务端上的文件。</p><h1 id="pg-execute-server-program"><a href="#pg-execute-server-program" class="headerlink" title="pg_execute_server_program"></a>pg_execute_server_program</h1><p>pg_execute_server_program 角色具有执行数据库服务端的程序权限，以file_fdw外部表举例如下。</p><p>首先准备数据文件，将 t_copy 文件进行压缩，如下:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ cat t_copy<span class="selector-class">.txt</span> </span><br><span class="line"><span class="number">1</span>       a</span><br><span class="line"><span class="number">2</span>       b</span><br><span class="line"></span><br><span class="line">[pg11@pghost2 ~]$ gzip t_copy.txt</span><br></pre></td></tr></table></figure></p><p>创建 file_fdw 外部扩展和外部表，以超级用户postgres登录francs库，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# CREATE EXTENSION file_fdw;</span><br><span class="line">CREATE EXTENSION</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# CREATE<span class="built_in"> SERVER </span>srv_file FOREIGN DATA WRAPPER file_fdw ;</span><br><span class="line">CREATE SERVER</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT USAGE ON FOREIGN<span class="built_in"> SERVER </span>srv_file <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure></p><p>以普通用户role11登录francs库，创建带OPTIONS(program)选项的外部表，如下:<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; CREATE FOREIGN TABLE ft_t_copy(id int4,name text) SERVER srv_file OPTIONS(program 'gunzip &lt; /home/pg11/t_copy.txt.gz');</span><br><span class="line"><span class="keyword">ERROR:  </span>only superuser or a member of the pg_execute_server_program role may specify the program option of a file_fdw foreign table</span><br></pre></td></tr></table></figure></p><p>以上报错，提示需要 superuser 或 pg_execute_server_program 权限才有权限指定 file_fdw 外部表的 program 选项。</p><p>将 pg_execute_server_program 角色赋予 role11用户，注意以下以postgres超级用户执行。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=# GRANT pg_execute_server_program TO role11;</span><br><span class="line"><span class="attribute">GRANT ROLE</span></span><br></pre></td></tr></table></figure></p><p>再次以role11用户登录francs库测试，如下:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; CREATE FOREIGN TABLE ft<span class="emphasis">_t_</span>copy(id int4,name text) SERVER srv<span class="emphasis">_file OPTIONS(program 'gunzip &lt; /home/pg11/t_</span>copy.txt.gz');</span><br><span class="line">CREATE FOREIGN TABLE</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT * FROM ft<span class="emphasis">_t_</span>copy ;</span><br><span class="line"><span class="code"> id | name </span></span><br><span class="line">----+------</span><br><span class="line"><span class="code">  1 | a</span></span><br><span class="line"><span class="code">  2 | b</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></p><p>创建带带OPTIONS(program)选项的外部表成功。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> pg_read_server_files、pg_write_server_files、pg_execute_server_program 角色涉及到读写数据库服务端文件，权限较大，分配此角色权限给数据库用户时需谨慎考虑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/default-roles.html#DEFAULT-ROLES-TABLE" target="_blank" rel="noopener">Default Roles</a></li><li><a href="https://paquier.xyz/postgresql-2/postgres-11-new-system-roles/" target="_blank" rel="noopener">Postgres 11 highlight - New System Roles</a></li><li><a href="https://postgres.fun/20110915133126.html">PostgreSQL9.1新特性之三：基于文件访问的 SQL/MED</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 新增三个默认系统角色，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pg_read_server_files&lt;/li&gt;
&lt;li&gt;pg_write_server_files&lt;/li&gt;
&lt;li&gt;pg_execute_server_program&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: Indexs With Include Columns </title>
    <link href="https://postgres.fun/20180930094300.html"/>
    <id>https://postgres.fun/20180930094300.html</id>
    <published>2018-09-30T01:43:45.000Z</published>
    <updated>2018-09-30T02:29:43.004Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本索引方面一个显著的新特性是创建索引时支持 INCLUDE COLUMNS ，语法如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_name <span class="keyword">ON</span> table_name <span class="keyword">USING</span> BTREE (column_a) <span class="keyword">INCLUDE</span> (column_b);</span><br></pre></td></tr></table></figure></p><h1 id="一、Release-中的说明"><a href="#一、Release-中的说明" class="headerlink" title="一、Release 中的说明"></a>一、Release 中的说明</h1><blockquote><p>Allow indexes to INCLUDE columns that are not part of the unique constraint but are available for index-only scans (Anastasia Lubennikova, Alexander Korotkov, Teodor Sigaev)</p></blockquote><p> This is also useful for including columns that dont have btree support</p><p>此特性主要用途和使用场景：</p><ul><li>如果字段不支持btree索引，可以使用INCLUDE方式索引。</li><li>使表上的更多SQL能走 Index-Only Scans。</li></ul><p>以上描述颇为费力，以下通过实例演示。</p><h1 id="二、验证-不支持Btree索引的字段，使用Include方式索引"><a href="#二、验证-不支持Btree索引的字段，使用Include方式索引" class="headerlink" title="二、验证: 不支持Btree索引的字段，使用Include方式索引"></a>二、验证: 不支持Btree索引的字段，使用Include方式索引</h1><p>首先验证第一点：不支持Btree索引的字段支持使用INCLUDE方式索引，创建测试表。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; CREATE <span class="keyword">TABLE</span> t_json1(a <span class="comment">serial, user_info json)</span>;</span><br><span class="line">CREATE <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure></p><p>在(a,user_info) 字段上创建 btree 索引，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt;  CREATE INDEX t_json1_idx1 ON t_json1 USING BTREE(a,user_info);</span><br><span class="line">ERROR:  data<span class="built_in"> type </span>json has <span class="literal">no</span><span class="built_in"> default </span>operator class <span class="keyword">for</span> access method <span class="string">"btree"</span></span><br><span class="line">HINT:  You must specify an operator class <span class="keyword">for</span> the index <span class="keyword">or</span> define a<span class="built_in"> default </span>operator class <span class="keyword">for</span> the data type.</span><br></pre></td></tr></table></figure></p><p>以上创建索引报错，是由于 json 不支持 btree 索引。</p><p>使用 INCLUDE 方式创建索引成功，如下:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> t_json1_idx_include <span class="keyword">ON</span> t_json1 <span class="keyword">USING</span> btree(a) <span class="keyword">INCLUDE</span>(user_info);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><h1 id="三、验证-Include-Columns-支持-Index-Only-Scans"><a href="#三、验证-Include-Columns-支持-Index-Only-Scans" class="headerlink" title="三、验证: Include Columns 支持 Index-Only Scans"></a>三、验证: Include Columns 支持 Index-Only Scans</h1><p>创建测试表并插入300万数据，如下：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CREATE TABLE t_include(<span class="name">a</span> int4, name text)<span class="comment">;</span></span></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> INSERT INTO t_include(<span class="name">a</span>,name) SELECT n,n || '_INCLUDE TEST' FROM generate_series(<span class="number">1</span>,<span class="number">3000000</span>) n<span class="comment">;</span></span></span><br><span class="line">INSERT 0 3000000</span><br></pre></td></tr></table></figure></p><p>在字段a上创建索引，如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_include_a <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>where条件中只包含a，查询a字段，以下SQL走了 Index Only Scan。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt;  EXPLAIN ANALYZE SELECT a <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                           QUERY PLAN</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Only Scan using idx_t_include_a on t_include  (<span class="attribute">cost</span>=0.43..8.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.017..0.018 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line">   Heap Fetches: 4</span><br><span class="line"> Planning Time: 0.272 ms</span><br><span class="line"> Execution Time: 0.038 ms</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure></p><p>加入 name 字段后，不走 Index Only Scan，如下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt;  EXPLAIN ANALYZE SELECT a,name <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                         QUERY PLAN</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Scan using idx_t_include_a on t_include  (<span class="attribute">cost</span>=0.43..8.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=24) (actual <span class="attribute">time</span>=0.005..0.007 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line"> Planning Time: 0.125 ms</span><br><span class="line"> Execution Time: 0.025 ms</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure></p><p>加入 name 后走了 Index Scan using ，根据索引回表查询name字段。</p><p>创建索引时使用 INCLUDE(name)，如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_include <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a) <span class="keyword">INCLUDE</span> (name);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>再次执行查询，走了 Index Only Scan</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; VACUUM ANALYZE t_include;</span><br><span class="line">VACUUM</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT a,name <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                          QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Only Scan using idx_t_include on t_include  (<span class="attribute">cost</span>=0.43..4.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=24) (actual <span class="attribute">time</span>=0.017..0.018 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line">   Heap Fetches: 0</span><br><span class="line"> Planning Time: 0.175 ms</span><br><span class="line"> Execution Time: 0.038 ms</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure><p>只查询name字段，也走了 Index Only Scan，如下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT name <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                          QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Only Scan using idx_t_include on t_include  (<span class="attribute">cost</span>=0.43..4.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=20) (actual <span class="attribute">time</span>=0.012..0.014 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line">   Heap Fetches: 0</span><br><span class="line"> Planning Time: 0.163 ms</span><br><span class="line"> Execution Time: 0.038 ms</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure></p><h1 id="四、Include-索引的限制"><a href="#四、Include-索引的限制" class="headerlink" title="四、Include 索引的限制"></a>四、Include 索引的限制</h1><ul><li>目前只有 Btree 索引支持 INCLUDE COLUMNS(INCLUDE中的字段物理上位于btree索引叶子节点)。</li><li>INCLUDE COLUMNS 中的字段不支持函数索引。</li><li>INCLUDE COLUMNS 中的字段数据类型可以不支持 btree 索引，例如 JSON 等数据类型。</li></ul><h1 id="五、两种索引方式差异"><a href="#五、两种索引方式差异" class="headerlink" title="五、两种索引方式差异"></a>五、两种索引方式差异</h1><p>或许有朋友问以下两种索引方式有啥区别？ 这个问题欢迎大家留言讨论。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_not_include <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a,<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_include <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a) <span class="keyword">INCLUDE</span> (<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></p><h1 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/sql-createindex.html" target="_blank" rel="noopener">CREATE INDEX</a></li><li><a href="https://paquier.xyz/postgresql-2/postgres-11-covering-indexes/" target="_blank" rel="noopener">Postgres 11 highlight - Covering Indexes</a></li><li><a href="https://www.depesz.com/2018/04/26/waiting-for-postgresql-11-indexes-with-include-columns-and-their-support-in-b-tree/" target="_blank" rel="noopener">WAITING FOR POSTGRESQL 11 – INDEXES WITH INCLUDE COLUMNS AND THEIR SUPPORT IN B-TREE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本索引方面一个显著的新特性是创建索引时支持 INCLUDE COLUMNS ，语法如下&lt;br&gt;&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 新增非空默认值字段不需要重写表</title>
    <link href="https://postgres.fun/20180929100400.html"/>
    <id>https://postgres.fun/20180929100400.html</id>
    <published>2018-09-29T02:04:49.000Z</published>
    <updated>2018-09-30T07:17:57.405Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 10 版本前表新增不带默认值的DDL不需要重写表，只需要更新数据字典，因此DDL能瞬间执行，如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> flag <span class="built_in">text</span>;</span><br></pre></td></tr></table></figure><p>如果新增的字段带默认值，则需要重写表，表越大，执行时间越长，如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> flag <span class="built_in">text</span> <span class="keyword">DEFAULT</span> <span class="string">'default values'</span>;</span><br></pre></td></tr></table></figure><p>生产环境下给大表添加带 Default 值的字段将非常吃力，通常分两步进行：</p><ol><li>第一步: 先添加不带 Default值的字段。</li><li>第二步: 写函数批量刷新新增字段的默认值。</li></ol><p>上述第二步比较麻烦，也可以在业务低谷或申请停服窗口一次性完成带DEFAUL值字段的新增。</p><p>PostgreSQL 11 版本这方面进一步增强，表新增带非空默认值的字段不再需要重写表，Release 中的说明如下：</p><h1 id="Release中的说明"><a href="#Release中的说明" class="headerlink" title="Release中的说明"></a>Release中的说明</h1><blockquote><p>Allow ALTER TABLE to add a column with a non-null default without a table rewrite</p></blockquote><p>本文分别在 10 版本和 11 版本进行测试。</p><h1 id="PostgreSQL-10-版本"><a href="#PostgreSQL-10-版本" class="headerlink" title="PostgreSQL 10 版本"></a>PostgreSQL 10 版本</h1><p>创建测试表并插入1000万数据，如下。<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg10@pghost1 ~]$ psql mydb pguser</span><br><span class="line">psql (10.<span class="number">0</span>)</span><br><span class="line"><span class="built_in">Type</span> <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">CREATE</span> TABLE t1(id int4, name text);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (id,name ) <span class="keyword">SELECT</span> n, n || <span class="string">'_ALTER TABLE TEST '</span> <span class="keyword">FROM</span> generate_series (<span class="number">1</span>,<span class="number">10000000</span>) n;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">ANALYZE</span> t1;</span><br><span class="line">ANALYZE</span><br></pre></td></tr></table></figure></p><p>查看表的 relfilenode 和 relpages 信息，relfilenode 表示表的物理文件号。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       25672 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>新增带默认值的非空字段，如下。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; \timing</span><br><span class="line">Timing is on.</span><br><span class="line"></span><br><span class="line">mydb=&gt; ALTER TABLE t1 ADD COLUMN flag text DEFAULT 'abcdefg';</span><br><span class="line">ALTER TABLE</span><br><span class="line"><span class="keyword">Time:</span> 15540.002 ms (00:15.540)</span><br></pre></td></tr></table></figure></p><p>执行时间较长，需要15秒左右。</p><p>表分析后再次查看表的 relfilenode 和 relpages信息<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; ANALYZE t1;</span><br><span class="line">ANALYZE</span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       25679 |    83334</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>发现 relfilenode 有变化 ，之前的 relfilenode 值为 25672 ，说明表被重写。另一方面 relpages 变大了。</p><h1 id="PostgreSQL-11-版本"><a href="#PostgreSQL-11-版本" class="headerlink" title="PostgreSQL 11 版本"></a>PostgreSQL 11 版本</h1><p>创建测试表并插入1000万数据，如下。<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CREATE TABLE t<span class="number">1</span>(<span class="name">id</span> int4, name text)<span class="comment">;</span></span></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> INSERT INTO t<span class="number">1</span> (<span class="name">id</span>,name ) SELECT n, n || '_ALTER TABLE TEST ' FROM generate_series (<span class="number">1</span>,<span class="number">10000000</span>) n<span class="comment">;</span></span></span><br><span class="line">INSERT 0 10000000</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> ANALYZE t<span class="number">1</span><span class="comment">;</span></span></span><br><span class="line">ANALYZE</span><br></pre></td></tr></table></figure></p><p>查看表的 relfilenode 和 relpages信息，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       16802 |    73530</span><br></pre></td></tr></table></figure></p><p>新增带默认值的非空字段，如下。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; \timing</span><br><span class="line">Timing is on.</span><br><span class="line"></span><br><span class="line">francs=&gt; ALTER TABLE t1 ADD COLUMN flag text DEFAULT 'abcdefg';</span><br><span class="line">ALTER TABLE</span><br><span class="line"><span class="keyword">Time:</span> 40.743 ms</span><br></pre></td></tr></table></figure></p><p>执行时间只需要 40 ms，瞬间完成。</p><p>表分析后再次查看表的 relfilenode 和 relpages信息<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; ANALYZE t1;</span><br><span class="line">ANALYZE</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       16802 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>发现 relfilenode 没有变化，依然是 16802，同时 relpages 也没有变化。</p><h1 id="增加1000字段"><a href="#增加1000字段" class="headerlink" title="增加1000字段"></a>增加1000字段</h1><p>PostgreSQL 11 版本给表 t1 增加了一个带默认值的字段后表占用空间没有变化，是不是增加的字段数不够多？接着往下测试，增加1000个带默认值的字段，看看情况如何？</p><p>创建测试表并插入1000万测试数据，如下:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">DROP</span> TABLE t1;</span><br><span class="line"><span class="keyword">DROP</span> TABLE</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">CREATE</span> TABLE t1(id int4, name text);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (id,name ) <span class="keyword">SELECT</span> n, n || <span class="string">'_ALTER TABLE TEST '</span> <span class="keyword">FROM</span> generate_series (<span class="number">1</span>,<span class="number">10000000</span>) n;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">ANALYZE</span> t1;</span><br><span class="line">ANALYZE</span><br></pre></td></tr></table></figure></p><p>查看表的 relfilenode 和 relpages信息，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       34187 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>查看表大小，如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT pg<span class="emphasis">_size_</span>pretty(pg<span class="emphasis">_relation_</span>size(<span class="emphasis">'t1'</span>));</span><br><span class="line"><span class="code"> pg_size_pretty</span></span><br><span class="line">----------------</span><br><span class="line"><span class="code"> 574 MB</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>创建函数，此函数用来给表 t1 添加 1000 个带默认值的字段，如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span>  add_column() <span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  <span class="keyword">AS</span>  $<span class="keyword">BODY</span>$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    column_name       <span class="built_in">text</span>;</span><br><span class="line">    default_value     text;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">     default_value:= <span class="keyword">repeat</span>(<span class="keyword">md5</span>(<span class="string">'1'</span>),<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">       FOR i in 1..1000 LOOP</span><br><span class="line">         column_name:= 'flag' || i;</span><br><span class="line">         <span class="keyword">EXECUTE</span>  $$ <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> $$ || column_name  || $$ <span class="built_in">text</span> <span class="keyword">default</span><span class="string">' $$ || default_value  || $$'</span>$$ ;</span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">       RETURN 1;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$<span class="keyword">BODY</span>$  <span class="keyword">LANGUAGE</span> <span class="string">'plpgsql'</span>;</span><br></pre></td></tr></table></figure></p><p>执行函数，如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">francs</span>=&gt; <span class="keyword">SELECT </span><span class="keyword">add_column();</span></span><br><span class="line"><span class="keyword"> </span><span class="keyword">add_column</span></span><br><span class="line"><span class="keyword">------------</span></span><br><span class="line"><span class="keyword"> </span>         <span class="number">1</span></span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>这时表t1已增加了1000个字段，如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM t1 LIMIT <span class="number">1</span>;</span><br><span class="line">-----------------------------------------[ RECORD <span class="number">1</span> ]-----------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">id       | <span class="type">1</span></span><br><span class="line">name     | <span class="type">1_ALTER</span> TABLE TEST</span><br><span class="line">flag1    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag2    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag3    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag4    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag5    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag6    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag7    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">...省略</span><br></pre></td></tr></table></figure></p><p>查看表 relfilenode 和 relpages，没有变化。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       34187 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>再次确认表大小，依然还是 574MB。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT pg<span class="emphasis">_size_</span>pretty(pg<span class="emphasis">_relation_</span>size(<span class="emphasis">'t1'</span>));</span><br><span class="line"><span class="code"> pg_size_pretty</span></span><br><span class="line">----------------</span><br><span class="line"><span class="code"> 574 MB</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>从以上看出给表t1增加了1000个带默认值的字段后，t1表大小依然没有变化。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.depesz.com/2018/04/04/waiting-for-postgresql-11-fast-alter-table-add-column-with-a-non-null-default/" target="_blank" rel="noopener">WAITING FOR POSTGRESQL 11 – FAST ALTER TABLE ADD COLUMN WITH A NON-NULL DEFAULT</a></li><li><a href="https://github.com/digoal/blog/blob/master/201805/20180518_01.md" target="_blank" rel="noopener">PostgreSQL 11 preview - 添加非空默认值不需要 rewrite table - online add column with default value</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 10 版本前表新增不带默认值的DDL不需要重写表，只需要更新数据字典，因此DDL能瞬间执行，如下:&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 支持存储过程(SQL Stored Procedures)</title>
    <link href="https://postgres.fun/20180925162500.html"/>
    <id>https://postgres.fun/20180925162500.html</id>
    <published>2018-09-25T08:25:48.000Z</published>
    <updated>2018-09-25T09:00:25.654Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本一个重量级新特性是对存储过程的支持，同时支持存储过程嵌入事务，存储过程是很多 PostgreSQL 从业者期待已久的特性，尤其是很多从Oracle转到PostgreSQL朋友，尽管PostgreSQL提供函数可以实现大多数存储过程的功能，但在函数中无法执行事务实现部分提交，换句话说，函数中的SQL要么都执行成功，要不全部返回失败。</p><p>PostgreSQL 11 版本对存储过程的支持，从兼容层面考虑和Oracle的兼容性进一步增强，本文演示下PostgreSQL存储过程的创建和调用，并且演示存储过程支持嵌入事务样例。</p><h1 id="发行说明"><a href="#发行说明" class="headerlink" title="发行说明"></a>发行说明</h1><blockquote><p>SQL stored procedures, with support for embedded transactions</p></blockquote><h1 id="存储过程创建语法"><a href="#存储过程创建语法" class="headerlink" title="存储过程创建语法"></a>存储过程创建语法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span> ] <span class="keyword">PROCEDURE</span></span><br><span class="line">    <span class="keyword">name</span> ( [ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> | = &#125; default_expr ] [, ...] ] )</span><br><span class="line">  &#123; <span class="keyword">LANGUAGE</span> lang_name</span><br><span class="line">    | TRANSFORM &#123; <span class="keyword">FOR</span> <span class="keyword">TYPE</span> type_name &#125; [, ... ]</span><br><span class="line">    | [ <span class="keyword">EXTERNAL</span> ] <span class="keyword">SECURITY</span> INVOKER | [ <span class="keyword">EXTERNAL</span> ] <span class="keyword">SECURITY</span> DEFINER</span><br><span class="line">    | <span class="keyword">SET</span> configuration_parameter &#123; <span class="keyword">TO</span> <span class="keyword">value</span> | = <span class="keyword">value</span> | <span class="keyword">FROM</span> <span class="keyword">CURRENT</span> &#125;</span><br><span class="line">    | <span class="keyword">AS</span> <span class="string">'definition'</span></span><br><span class="line">    | <span class="keyword">AS</span> <span class="string">'obj_file'</span>, <span class="string">'link_symbol'</span></span><br><span class="line">  &#125; ...</span><br></pre></td></tr></table></figure><h1 id="存储过程调用语法"><a href="#存储过程调用语法" class="headerlink" title="存储过程调用语法"></a>存储过程调用语法</h1><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL name ( <span class="string">[ argument ]</span> <span class="string">[, ...]</span> )</span><br></pre></td></tr></table></figure><p>存储过程调用比较简单，使用 <code>CALL</code> 命令即可，而函数的调用是使用 <code>SELECT</code> 命令。</p><h1 id="存储过程嵌入事务测试"><a href="#存储过程嵌入事务测试" class="headerlink" title="存储过程嵌入事务测试"></a>存储过程嵌入事务测试</h1><p>创建一个简单的存储过程演示下。</p><h2 id="创建测试表"><a href="#创建测试表" class="headerlink" title="创建测试表"></a>创建测试表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (<span class="keyword">id</span> int4);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1_log (ctime <span class="keyword">timestamp</span>(<span class="number">6</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone , operation <span class="built_in">text</span>,ins_values int4);</span><br></pre></td></tr></table></figure><h2 id="创建存储过程-ins-t1"><a href="#创建存储过程-ins-t1" class="headerlink" title="创建存储过程 ins_t1"></a>创建存储过程 ins_t1</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> ins_t1(a <span class="built_in">integer</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(<span class="keyword">id</span>) <span class="keyword">VALUES</span>(a);</span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1_log(ctime,operation,ins_values) <span class="keyword">VALUES</span> (clock_timestamp(),<span class="string">'INSERT'</span>,a);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> <span class="string">'plpgsql'</span>;</span><br></pre></td></tr></table></figure><p>调用存储过程 ins_t1()，如下<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CALL ins_t<span class="number">1</span>(<span class="number">1</span>)<span class="comment">;</span></span></span><br><span class="line">CALL</span><br></pre></td></tr></table></figure></p><p>查看表 t1 和 t1_log 记录。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM t1;</span><br><span class="line"><span class="code"> id</span></span><br><span class="line">----</span><br><span class="line"><span class="code">  1</span></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT * FROM t1<span class="emphasis">_log;</span></span><br><span class="line"><span class="emphasis">           ctime            | operation | ins_</span>values</span><br><span class="line">----------------------------<span class="code">+-----------+</span>------------</span><br><span class="line"><span class="code"> 2018-09-25 15:08:16.026122 | INSERT    |          1</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>以上看出两条SQL都已提交。</p><h2 id="创建存储过程-ins-t1-part"><a href="#创建存储过程-ins-t1-part" class="headerlink" title="创建存储过程  ins_t1_part"></a>创建存储过程  ins_t1_part</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> ins_t1_part(a <span class="built_in">integer</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(<span class="keyword">id</span>) <span class="keyword">VALUES</span>(a);</span><br><span class="line">      <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1_log(ctime,operation,ins_values) <span class="keyword">VALUES</span> (clock_timestamp(),<span class="string">'INSERT'</span>,a);</span><br><span class="line">      <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> <span class="string">'plpgsql'</span>;</span><br></pre></td></tr></table></figure><p>调用存储过程 ins_t1_part()，如下<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CALL ins_t<span class="number">1</span>_part(<span class="number">2</span>)<span class="comment">;</span></span></span><br><span class="line">CALL</span><br></pre></td></tr></table></figure></p><p>查看表 t1 和 t1_log 记录。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM t1;</span><br><span class="line"><span class="code"> id</span></span><br><span class="line">----</span><br><span class="line"><span class="code">  1</span></span><br><span class="line"><span class="code">  2</span></span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT * FROM t1<span class="emphasis">_log;</span></span><br><span class="line"><span class="emphasis">           ctime            | operation | ins_</span>values</span><br><span class="line">----------------------------<span class="code">+-----------+</span>------------</span><br><span class="line"><span class="code"> 2018-09-25 15:08:16.026122 | INSERT    |          1</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>发现 t1 表的数据已提交，而 t1_log 表的数据没有提交，验证了存储过程支持嵌入式事务。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/sql-createprocedure.html" target="_blank" rel="noopener">CREATE PROCEDURE</a></li><li><a href="https://www.cybertec-postgresql.com/en/tech-preview-postgresql-11-create-procedure/" target="_blank" rel="noopener">TECH PREVIEW: POSTGRESQL 11 – CREATE PROCEDURE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本一个重量级新特性是对存储过程的支持，同时支持存储过程嵌入事务，存储过程是很多 PostgreSQL 从业者期待已久的特性，尤其是很多从Oracle转到PostgreSQL朋友，尽管PostgreSQL提供函数可以实现大多数存储过程的功能，但在
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11：支持并行哈希连接(Parallel Hash Joins)</title>
    <link href="https://postgres.fun/20180924134200.html"/>
    <id>https://postgres.fun/20180924134200.html</id>
    <published>2018-09-24T05:42:27.000Z</published>
    <updated>2018-09-24T05:52:42.159Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本在并行方面得到增强，例如支持并行创建索引(Parallel Index Build)、并行哈希连接(Parallel Hash Join)、并行 <code>CREATE TABLE .. AS</code>等，<a href="https://postgres.fun/20180922222100.html">上篇博客</a>介绍了并行创建索引，本文介绍并行 Hash Join。</p><h1 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h1><p>创建大表t_big并插入5000万条数据。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_big(</span><br><span class="line"><span class="keyword">id</span> int4,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">create_time <span class="keyword">timestamp</span> <span class="keyword">without</span> <span class="keyword">time</span> zone );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_big(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time)</span><br><span class="line"><span class="keyword">SELECT</span> n, n|| <span class="string">'_test'</span>,clock_timestamp() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">50000000</span>) n ;</span><br></pre></td></tr></table></figure></p><p>创建小表t_small并插入800万条数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_small(<span class="keyword">id</span> int4, <span class="keyword">name</span> <span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_small(<span class="keyword">id</span>,<span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">SELECT</span> n, n|| <span class="string">'_small'</span> <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">8000000</span>) n ;</span><br></pre></td></tr></table></figure></p><h1 id="验证并行哈希连接"><a href="#验证并行哈希连接" class="headerlink" title="验证并行哈希连接"></a>验证并行哈希连接</h1><p>PostgreSQL 10 版本查看以下SQL执行计划，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">des</span>=&gt; EXPLAIN SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                      QUERY PLAN</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=151870.58..661385.28 <span class="attribute">rows</span>=4143 <span class="attribute">width</span>=13)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   -&gt;  Hash Join  (<span class="attribute">cost</span>=150870.58..659970.98 <span class="attribute">rows</span>=1036 <span class="attribute">width</span>=13)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..470246.58 <span class="attribute">rows</span>=10358258 <span class="attribute">width</span>=4)</span><br><span class="line">         -&gt;  Hash  (<span class="attribute">cost</span>=150860.58..150860.58 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17)</span><br><span class="line">               -&gt;  Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..150860.58 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure><p>PostgreSQL 11 版本查看以下SQL执行计划，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                       QUERY PLAN</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=76862.42..615477.60 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=13)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   -&gt;  Parallel Hash Join  (<span class="attribute">cost</span>=75862.42..614397.60 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=13)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..491660.86 <span class="attribute">rows</span>=12499686 <span class="attribute">width</span>=4)</span><br><span class="line">         -&gt;  Parallel Hash  (<span class="attribute">cost</span>=75859.92..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17)</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure></p><p>对比10版本的执行计划，不同之处为11版本走了 <strong>Parallel Hash Join</strong>，而 10 版本走的 <strong>Hash Join</strong>，<strong>Parallel Hash Join</strong> 为 11 版本的新特性。</p><h1 id="并行哈希连接性能测试"><a href="#并行哈希连接性能测试" class="headerlink" title="并行哈希连接性能测试"></a>并行哈希连接性能测试</h1><p>开启并行哈希连接相比不开启性能上有何变化？接着测试。</p><h2 id="开启并行哈希连接"><a href="#开启并行哈希连接" class="headerlink" title="开启并行哈希连接"></a>开启并行哈希连接</h2><p>PostgreSQL 11 版本执行以下SQL，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                                                QUERY PLAN</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=76862.42..615477.60 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=197.399..2738.010 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=1)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   Workers Launched: 4</span><br><span class="line">   -&gt;  Parallel Hash Join  (<span class="attribute">cost</span>=75862.42..614397.60 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=2222.347..2729.943 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..491660.86 <span class="attribute">rows</span>=12499686 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.038..1330.836 <span class="attribute">rows</span>=10000000 <span class="attribute">loops</span>=5)</span><br><span class="line">         -&gt;  Parallel Hash  (<span class="attribute">cost</span>=75859.92..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=191.484..191.484 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">               Buckets: 1024  Batches: 1  Memory Usage: 40kB</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=152.436..191.385 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">                     Rows Removed by Filter: 1599980</span><br><span class="line"> Planning Time: 0.183 ms</span><br><span class="line"> Execution Time: 2738.068 ms</span><br><span class="line">(13 rows)</span><br></pre></td></tr></table></figure></p><p>以上SQL执行多次，取最快时间，执行时间为 2738.068 ms。</p><h2 id="关闭并行哈希连接"><a href="#关闭并行哈希连接" class="headerlink" title="关闭并行哈希连接"></a>关闭并行哈希连接</h2><p>会话级设置enable_parallel_hash参数为off表示关闭并行哈希连接，测试性能有何变化，如下。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; <span class="builtin-name">set</span> enable_parallel_hash = off;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                                                QUERY PLAN</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=151869.66..690486.34 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=996.137..3496.940 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=1)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   Workers Launched: 4</span><br><span class="line">   -&gt;  Hash Join  (<span class="attribute">cost</span>=150869.66..689406.34 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=2990.847..3490.557 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..491660.86 <span class="attribute">rows</span>=12499686 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.240..1392.062 <span class="attribute">rows</span>=10000000 <span class="attribute">loops</span>=5)</span><br><span class="line">         -&gt;  Hash  (<span class="attribute">cost</span>=150859.66..150859.66 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=890.943..890.943 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=5)</span><br><span class="line">               Buckets: 1024  Batches: 1  Memory Usage: 13kB</span><br><span class="line">               -&gt;  Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..150859.66 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=884.288..890.906 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">                     Rows Removed by Filter: 7999901</span><br><span class="line"> Planning Time: 0.154 ms</span><br><span class="line"> Execution Time: 3496.982 ms</span><br><span class="line">(13 rows)</span><br></pre></td></tr></table></figure><p>以上SQL执行多次，取最快时间，从以上看出，关闭并行哈希连接时SQL的执行时间为 3496.982 ms ，相比开启并行哈希连接执行时间长了 27%。</p><p>可见开启并行哈希连接后，性能有较大幅度提升。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://postgres.fun/20180922222100.html">PostgreSQL11：支持并行创建索引(Parallel Index Builds)</a></li><li><a href="https://postgres.fun/20170521162007.html">PostgreSQL10：Parallel Queries 增强</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本在并行方面得到增强，例如支持并行创建索引(Parallel Index Build)、并行哈希连接(Parallel Hash Join)、并行 &lt;code&gt;CREATE TABLE .. AS&lt;/code&gt;等，&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Parallel Query" scheme="https://postgres.fun/tags/Parallel-Query/"/>
    
  </entry>
  
</feed>
