<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PostgreSQL 中文网</title>
  
  <subtitle>francs&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://postgres.fun/"/>
  <updated>2018-11-02T00:53:45.529Z</updated>
  <id>https://postgres.fun/</id>
  
  <author>
    <name>francs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PostgreSQL 11 有哪些引人瞩目的新特性？</title>
    <link href="https://postgres.fun/20181102084300.html"/>
    <id>https://postgres.fun/20181102084300.html</id>
    <published>2018-11-02T00:43:12.000Z</published>
    <updated>2018-11-02T00:53:45.529Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 有哪些引人瞩目的新特性？</p><p>2018-10-18 <a href="https://www.postgresql.org/about/news/1894/" target="_blank" rel="noopener">PostgreSQL官网</a> 宣布 PostgreSQL 11 正式版发行，PostgreSQL 11 重点对性能进行了提升和功能完善，特别是对大数据库和高计算负载的情况下进行了增强，主要包括以下:</p><ul><li>对分区表进行了大幅的改进和增强。</li><li>增加了对存储过程的支持，存储过程支持事务。</li><li>增强了并行查询能力和并行数据定义能力。</li><li>增加了对 just-in-time (JIT) 编译的支持，加速SQL中的表达式执行效率。</li></ul><p>最近对PostgreSQL以上新特性和其它功能完善做了演示，希望对PostgreSQL从业者有帮助，详见以下。</p><h1 id="分区表的改进"><a href="#分区表的改进" class="headerlink" title="分区表的改进"></a>分区表的改进</h1><p>PostgreSQL 11 对分区表进行了重大的改进，例如增加了哈希分区、支持创建主键、外键、索引、支持UPDATE分区键以及增加了默认分区，这些功能的完善极大的增强了分区表的可用性，详见以下:</p><ul><li><a href="https://postgres.fun/20180920082700.html">PostgreSQL11: 分区表增加哈希分区</a></li><li><a href="https://postgres.fun/20180920155600.html">PostgreSQL11：分区表支持创建主键、外键、索引</a></li><li><a href="https://postgres.fun/20180920214600.html">PostgreSQL11: 分区表支持UPDATE分区键</a></li><li><a href="https://postgres.fun/20180921101300.html">PostgreSQL11: 分区表增加 Default Partition</a></li></ul><h1 id="支持存储过程"><a href="#支持存储过程" class="headerlink" title="支持存储过程"></a>支持存储过程</h1><p>PostgreSQL 11 版本一个重量级新特性是对存储过程的支持，同时支持存储过程嵌入事务，存储过程是很多 PostgreSQL 从业者期待已久的特性，尤其是很多从Oracle转到PostgreSQL朋友。</p><p>尽管PostgreSQL提供函数可以实现大多数存储过程的功能，但函数不支持部分提交，换句话说，函数中的SQL要么都执行成功，要不全部返回失败，详见以下:</p><ul><li><a href="https://postgres.fun/20180925162500.html">PostgreSQL11: 支持存储过程(SQL Stored Procedures)</a></li></ul><h1 id="并行能力的增强"><a href="#并行能力的增强" class="headerlink" title="并行能力的增强"></a>并行能力的增强</h1><p>PostgreSQL 11 版本在并行方面得到较大增强，例如支持并行创建索引、并行Hash Join、并行 CREATE TABLE .. AS等，详见以下:</p><ul><li><a href="https://postgres.fun/20180922222100.html">PostgreSQL11：支持并行创建索引(Parallel Index Builds)</a></li><li><a href="https://postgres.fun/20180924134200.html">PostgreSQL11：支持并行哈希连接(Parallel Hash Joins)</a></li></ul><h1 id="增加对Just-in-Time-JIT-编译的支持"><a href="#增加对Just-in-Time-JIT-编译的支持" class="headerlink" title="增加对Just-in-Time (JIT)编译的支持"></a>增加对Just-in-Time (JIT)编译的支持</h1><p>PostgreSQL 11 版本的一个重量级新特性是引入了 JIT (Just-in-Time) 编译来加速SQL中的表达式计算效率。</p><p>JIT 表达式的编译使用LLVM项目编译器来提升在WHERE条件、指定列表、聚合以及一些内部操作表达式的编译执行，详见以下:</p><ul><li><a href="https://postgres.fun/20181031161700.html">PostgreSQL11: 增加对JIT(just-in-time)编译的支持提升分析型SQL执行效率</a></li></ul><h1 id="其它功能完善"><a href="#其它功能完善" class="headerlink" title="其它功能完善"></a>其它功能完善</h1><p>此外， PostgreSQL 11 增强了其它新特性以增加用户体验，以下列举了主要的几点，详见以下:</p><ul><li><a href="https://postgres.fun/20180929100400.html">PostgreSQL11: 新增非空默认值字段不需要重写表</a></li><li><a href="https://postgres.fun/20180930094300.html">PostgreSQL11: Indexs With Include Columns</a></li><li><a href="https://postgres.fun/20181013215100.html">PostgreSQL11: 新增三个默认角色</a></li><li><a href="https://postgres.fun/20181015113300.html">PostgreSQL11: 可通过GRNAT权限下放的四个系统函数</a></li><li><a href="https://postgres.fun/20181016214500.html">PostgreSQL11: Initdb/Pg_resetwal支持修改WAL文件大小</a></li><li><a href="https://postgres.fun/20181017123400.html">PostgreSQL11: psql 新增 \gdesc 显示查询结果的列名和类型</a></li><li><a href="https://postgres.fun/20181018084300.html">PostgreSQL11: psql 新增变量记录SQL语句的执行情况和错误</a></li></ul><h1 id="关于PostgreSQL"><a href="#关于PostgreSQL" class="headerlink" title="关于PostgreSQL"></a>关于PostgreSQL</h1><p>PostgreSQL 号称世界上最先进的开源关系型数据库，PostgreSQL 全球社区是一个由数千名用户、开发人员、公司或其他组织组成。 PostgreSQL 起源于加利福利亚的伯克利大学，有30年以上历史，经历了无数次开发升级。</p><p>PostgreSQL 的出众之处在于不仅具有商业数据库的功能特性，同时在扩展性、安全性、稳定性等高级数据库特性方面超越了它们。</p><p>若想获取到更多关于PostgreSQL的信息或者加入PostgreSQL社区，请浏览官网 <a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL.org</a> 。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/about/news/1894/" target="_blank" rel="noopener">PostgreSQL 11 Released!</a></li><li><a href="http://postgres.cn/release/v/49" target="_blank" rel="noopener">PostgreSQL 11.0 正式版更新版本发布说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 有哪些引人瞩目的新特性？&lt;/p&gt;
&lt;p&gt;2018-10-18 &lt;a href=&quot;https://www.postgresql.org/about/news/1894/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Postgre
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 增加对JIT(just-in-time)编译的支持提升分析型SQL执行效率</title>
    <link href="https://postgres.fun/20181031161700.html"/>
    <id>https://postgres.fun/20181031161700.html</id>
    <published>2018-10-31T08:17:15.000Z</published>
    <updated>2018-11-02T00:40:01.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-JIT"><a href="#关于-JIT" class="headerlink" title="关于 JIT"></a>关于 JIT</h1><p>PostgreSQL 11 版本的一个重量级新特性是引入了 <a href="https://www.postgresql.org/docs/11/static/jit.html" target="_blank" rel="noopener"><strong>JIT (Just-in-Time)</strong></a> 编译来加速SQL中的表达式计算效率。</p><p>JIT 表达式的编译使用LLVM项目编译器的架构来提升在WHERE条件、指定列表、聚合以及一些内部操作表达式的编译执行。</p><p>使用 JIT 必须在首先编译安装 <a href="https://llvm.org/" target="_blank" rel="noopener"><strong>LLVM</strong></a> ，之后编译安装 PostgreSQL 时设置 <code>--with-llvm</code> 选项，本文主要包括两部分，如下:</p><ul><li>CentOS7 编译安装 LLVM。</li><li>CentOS7 编译安装PostgreSQL 11，启用并演示 JIT。</li></ul><h1 id="JIT-使用场景"><a href="#JIT-使用场景" class="headerlink" title="JIT 使用场景"></a>JIT 使用场景</h1><p>JIT 常用于CPU密集型SQL(分析统计SQL)，执行很快的SQL使用JIT由于产生一定开销，反而可能引起性能下降。</p><h1 id="手册-Release说明"><a href="#手册-Release说明" class="headerlink" title="手册 Release说明"></a>手册 Release说明</h1><blockquote><p>Add <strong>Just-in-Time (JIT)</strong> compilation of some parts of query plans to improve execution speed (Andres Freund)<br>This feature requires LLVM to be available. It is not currently enabled by default, even in builds that support it.</p></blockquote><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>操作系统: CentOS Linux release 7.4.1708 (Core)<br>硬件环境: 8核4G/80G 的云主机</p><h1 id="LLVM安装前提条件"><a href="#LLVM安装前提条件" class="headerlink" title="LLVM安装前提条件"></a>LLVM安装前提条件</h1><p>LLVM 安装依赖较多，如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The minimum required <span class="built_in">version</span> <span class="keyword">of</span> LLVM <span class="keyword">is</span> currently <span class="number">3.9</span>  <span class="comment">--本实验使用 LLVM5.0</span></span><br><span class="line">CMake. Version <span class="number">3.4</span><span class="number">.3</span> <span class="keyword">is</span> <span class="keyword">the</span> minimum required.          <span class="comment">--本实验使用 cmake 3.12.3</span></span><br><span class="line">Python <span class="number">2.7</span> <span class="keyword">or</span> newer <span class="keyword">is</span> required                        <span class="comment">--本实验使用 Python 2.7.5</span></span><br><span class="line">GCC <span class="built_in">version</span> must be <span class="keyword">at</span> least <span class="number">4.8</span>!                      <span class="comment">--本实验使用 gcc 4.8.5</span></span><br></pre></td></tr></table></figure><h1 id="安装-Cmake-3-9-6"><a href="#安装-Cmake-3-9-6" class="headerlink" title="安装 Cmake 3.9.6"></a>安装 Cmake 3.9.6</h1><p>下载并编译安装 cmake 3.9.6，如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget -c https://cmake.org/files/v3.12/cmake-3.12.3.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xvf cmake-3.12.3.tar.gz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> cmake-3.12.3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./bootstrap</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make -j 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p><h1 id="安装Python-2-7-9"><a href="#安装Python-2-7-9" class="headerlink" title="安装Python 2.7.9"></a>安装Python 2.7.9</h1><p>下载并编译安装 python 2.7.9，如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget -c https://www.python.org/downloads/release/python-279/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar jxvf Python-2.7.9.tgz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> Python-2.7.9</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><h1 id="安装-LLVM-5-0-2"><a href="#安装-LLVM-5-0-2" class="headerlink" title="安装 LLVM 5.0.2"></a>安装 LLVM 5.0.2</h1><p>LLVM 的安装步骤较繁琐，并且编译安装过程时间较长，性能好的机器能减少编译时间，注意操作系统需启用 <code>swap</code>，否则编译过程中会报错,本人开始编译安装时没有启用 <code>swap</code>，折腾了很久。</p><h2 id="下载LLVM安装介质"><a href="#下载LLVM安装介质" class="headerlink" title="下载LLVM安装介质"></a>下载LLVM安装介质</h2><p>在 <a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener"><strong>LLVM官网</strong></a>下载安装介质，如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">llvm-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">cfe-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">clang-tools-extra-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">compiler-rt-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">libcxx-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">libcxxabi-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br><span class="line"><span class="selector-tag">libunwind-5</span><span class="selector-class">.0</span><span class="selector-class">.2</span><span class="selector-class">.src</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span></span><br></pre></td></tr></table></figure><h2 id="编译安装LLVM"><a href="#编译安装LLVM" class="headerlink" title="编译安装LLVM"></a>编译安装LLVM</h2><p>解压 llvm-7.0.0.src.tar.xz<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /opt/soft_bak/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xvf llvm-7.0.0.src.tar.xz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mv llvm-7.0.0.src llvm</span></span><br></pre></td></tr></table></figure></p><p>解压安装包并重命名，目录结构对应如下，如下:</p><table><thead><tr><th style="text-align:left">安装包</th><th style="text-align:left">安装目录</th></tr></thead><tbody><tr><td style="text-align:left">llvm-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/llvm</td></tr><tr><td style="text-align:left">cfe-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/tools/clang</td></tr><tr><td style="text-align:left">clang-tools-extra-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/tools/clang/tools/extra</td></tr><tr><td style="text-align:left">compiler-rt-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/compiler-rt</td></tr><tr><td style="text-align:left">libcxx-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/libcxx</td></tr><tr><td style="text-align:left">libcxxabi-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/libcxxabi</td></tr><tr><td style="text-align:left">libunwind-5.0.2.src.tar.xz</td><td style="text-align:left">/opt/soft_bak/projects/libunwind</td></tr></tbody></table><p>LLVM 官网的其它安装包非必须，可根据情况选择。</p><p>编译安装 LLVM，如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /opt/soft_bak/llvm_build/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> /opt/soft_bak/llvm_build/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> cmake -G <span class="string">"Unix Makefiles"</span> -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span>/llvm -DCLANG_DEFAULT_CXX_STDLIB=libc++ -DCMAKE_BUILD_TYPE=<span class="string">"Release"</span> /opt/soft_bak/llvm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make -j 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure></p><p>设置环境变量，如下:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/usr/local/llvm/bin</span></span><br><span class="line">export LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span><span class="symbol">:/usr/local/llvm/lib</span></span><br></pre></td></tr></table></figure></p><p>查看版本<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@pghost7 ~]</span># <span class="selector-tag">llvm-cat</span> <span class="selector-tag">--version</span></span><br><span class="line"><span class="selector-tag">LLVM</span> (<span class="attribute">http</span>:<span class="comment">//llvm.org/):</span></span><br><span class="line">  LLVM version <span class="number">5.0</span>.<span class="number">2</span></span><br><span class="line">  Optimized build.</span><br><span class="line">  Default <span class="attribute">target</span>: x86_64-unknown-linux-gnu</span><br><span class="line">  Host <span class="attribute">CPU</span>: broadwell</span><br><span class="line"></span><br><span class="line">[root<span class="variable">@pghost7</span> ~]# clang --version</span><br><span class="line">clang version <span class="number">5.0</span>.<span class="number">2</span> (tags/RELEASE_502/final)</span><br><span class="line"><span class="attribute">Target</span>: x86_64-unknown-linux-gnu</span><br><span class="line">Thread <span class="attribute">model</span>: posix</span><br><span class="line"><span class="attribute">InstalledDir</span>: /usr/local/llvm/bin</span><br></pre></td></tr></table></figure></p><p>至此 LLVM 已安装成功。</p><h1 id="PostgreSQL-11-安装"><a href="#PostgreSQL-11-安装" class="headerlink" title="PostgreSQL 11 安装"></a>PostgreSQL 11 安装</h1><p>安装相关包，如下:<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum -y install gcc <span class="built_in">readline</span> <span class="built_in">readline</span>-devel zlib zlib-devel python-devel</span><br></pre></td></tr></table></figure></p><p>下载PostgreSQL 11 并编译安装，如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget -c https://ftp.postgresql.org/pub/<span class="built_in">source</span>/v11.0/postgresql-11.0.tar.bz2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tar xvf postgresql-11.0.tar.bz2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">./configure --prefix=/opt/pgsql_11.0 --with-wal-blocksize=16 -with-pgport=1930 --with-llvm LLVM_CONFIG=<span class="string">'/usr/local/llvm/bin/llvm-config'</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make wolrd -j 4</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make install-world</span></span><br></pre></td></tr></table></figure></p><p>设置 <code>.bash_profile</code> ，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGPORT</span>=1930</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGUSER</span>=postgres</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGDATA</span>=/database/pg11/pg_root</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">LANG</span>=en_US.utf8</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PGHOME</span>=/opt/pgsql_11.0</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">LD_LIBRARY_PATH</span>=<span class="variable">$PGHOME</span>/lib:/lib64:/usr/lib64:/usr/local/lib64:/lib:/usr/lib:/usr/local/lib</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DATE</span>=`date +<span class="string">"%Y%m%d%H%M"</span>`</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PGHOME</span>/bin:$PATH:.</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">MANPATH</span>=<span class="variable">$PGHOME</span>/share/man:$MANPATH</span><br><span class="line">alias <span class="attribute">rm</span>=<span class="string">'rm -i'</span></span><br><span class="line">alias <span class="attribute">ll</span>=<span class="string">'ls -lh'</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>initdb</code> 初始化数据库，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost7 pg_root]$ initdb -D /database/pg11/pg_root <span class="attribute">-E</span>=UTF8 <span class="attribute">--locale</span>=C -U postgres -W</span><br></pre></td></tr></table></figure></p><p>postgresql.conf 设置以下 JIT 配置参数，其它参数按需配置，这里不贴出，如下:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - Other Defaults -</span></span><br><span class="line"><span class="comment">#dynamic_library_path = '$libdir'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jit</span> = <span class="literal">on</span>                                # allow JIT compilation</span><br><span class="line"><span class="attr">jit_provider</span> = <span class="string">'llvmjit'</span>                # JIT implementation to use</span><br></pre></td></tr></table></figure><p>设置 pg_hba.conf，如下:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host all        all     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span>       md5</span><br></pre></td></tr></table></figure></p><p>之后启动数据库，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost7 pg_root]$ pg_ctl start</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-31 11:13:26.154 CST [19742] LOG:  listening on IPv4<span class="built_in"> address </span><span class="string">"0.0.0.0"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-31 11:13:26.154 CST [19742] LOG:  listening on<span class="built_in"> IPv6 address </span><span class="string">"::"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-31 11:13:26.159 CST [19742] LOG:  listening on Unix socket <span class="string">"/tmp/.s.PGSQL.1930"</span></span><br><span class="line">2018-10-31 11:13:26.185 CST [19742] LOG:  redirecting log output <span class="keyword">to</span><span class="built_in"> logging </span>collector process</span><br><span class="line">2018-10-31 11:13:26.185 CST [19742] HINT:  Future log output will appear <span class="keyword">in</span> directory <span class="string">"log"</span>.</span><br><span class="line"> done</span><br><span class="line">server started</span><br></pre></td></tr></table></figure></p><h1 id="JIT-测试"><a href="#JIT-测试" class="headerlink" title="JIT 测试"></a>JIT 测试</h1><p>以下大致演示 JIT，测试样例很简单，不做充分的性能测试，有兴趣的朋友可以做 TPC-H 性能测试。</p><h2 id="测试数据准备"><a href="#测试数据准备" class="headerlink" title="测试数据准备"></a>测试数据准备</h2><p>创建一张5千万的数据表，如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_llvm1(a int4, b int4, info <span class="built_in">text</span>, ctime <span class="keyword">timestamp</span>(<span class="number">6</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_llvm1 (a,b,info,ctime) <span class="keyword">SELECT</span> n,n*<span class="number">2</span>,n||<span class="string">'_llvm1'</span>,clock_timestamp() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">50000000</span>) n;</span><br></pre></td></tr></table></figure><h2 id="查看-JIT-相关参数"><a href="#查看-JIT-相关参数" class="headerlink" title="查看 JIT 相关参数"></a>查看 JIT 相关参数</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT name,setting FROM pg_settings WHERE name LIKE 'jit%';</span></span><br><span class="line">          name           |<span class="string"> setting</span></span><br><span class="line"><span class="string">-------------------------+---------</span></span><br><span class="line"><span class="string"> jit                     </span>|<span class="string"> on</span></span><br><span class="line"><span class="string"> jit_above_cost          </span>|<span class="string"> 100000</span></span><br><span class="line"><span class="string"> jit_debugging_support   </span>|<span class="string"> off</span></span><br><span class="line"><span class="string"> jit_dump_bitcode        </span>|<span class="string"> off</span></span><br><span class="line"><span class="string"> jit_expressions         </span>|<span class="string"> on</span></span><br><span class="line"><span class="string"> jit_inline_above_cost   </span>|<span class="string"> 500000</span></span><br><span class="line"><span class="string"> jit_optimize_above_cost </span>|<span class="string"> 500000</span></span><br><span class="line"><span class="string"> jit_profiling_support   </span>|<span class="string"> off</span></span><br><span class="line"><span class="string"> jit_provider            </span>|<span class="string"> llvmjit</span></span><br><span class="line"><span class="string"> jit_tuple_deforming     </span>|<span class="string"> on</span></span><br><span class="line"><span class="string">(10 rows)</span></span><br></pre></td></tr></table></figure><h2 id="开启-JIT"><a href="#开启-JIT" class="headerlink" title="开启 JIT"></a>开启 JIT</h2><p>开启 JIT，执行计划如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">postgres</span>=# <span class="builtin-name">SET</span> JIT = on;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="attribute">postgres</span>=# EXPLAIN ANALYZE SELECT count(*),sum(a) <span class="keyword">FROM</span> t_llvm1 WHERE (a+b) &gt; 10;</span><br><span class="line">                                                                    QUERY PLAN</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Finalize Aggregate  (<span class="attribute">cost</span>=576982.30..576982.31 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2148.607..2148.608 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=1)</span><br><span class="line">   -&gt;  Gather  (<span class="attribute">cost</span>=576981.86..576982.28 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2148.457..2153.185 <span class="attribute">rows</span>=5 <span class="attribute">loops</span>=1)</span><br><span class="line">         Workers Planned: 4</span><br><span class="line">         Workers Launched: 4</span><br><span class="line">         -&gt;  Partial Aggregate  (<span class="attribute">cost</span>=575981.86..575981.88 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2134.919..2134.919 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=5)</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_llvm1  (<span class="attribute">cost</span>=0.00..555148.48 <span class="attribute">rows</span>=4166677 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=105.597..1516.253 <span class="attribute">rows</span>=9999999 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: ((a + b) &gt; 10)</span><br><span class="line">                     Rows Removed by Filter: 1</span><br><span class="line"> Planning Time: 0.078 ms</span><br><span class="line"> JIT:</span><br><span class="line">   Functions: 28</span><br><span class="line">   Options: Inlining <span class="literal">true</span>, Optimization <span class="literal">true</span>, Expressions <span class="literal">true</span>, Deforming <span class="literal">true</span></span><br><span class="line">   Timing: Generation 5.842 ms, Inlining 226.589 ms, Optimization 191.071 ms, Emission 107.027 ms, Total 530.529 ms</span><br><span class="line"> Execution Time: 2154.870 ms</span><br><span class="line">(14 rows)</span><br></pre></td></tr></table></figure><p>从以上看出执行计划中包含 JIT 编译信息，执行时间为 2154 ms 左右。</p><h2 id="关闭-JIT"><a href="#关闭-JIT" class="headerlink" title="关闭 JIT"></a>关闭 JIT</h2><p>关闭 JIT,查看执行计划和扫行时间，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">postgres</span>=# <span class="builtin-name">SET</span> JIT = off;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="attribute">postgres</span>=# EXPLAIN ANALYZE SELECT count(*),sum(a) <span class="keyword">FROM</span> t_llvm1 WHERE (a+b) &gt; 10;</span><br><span class="line">                                                                   QUERY PLAN</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Finalize Aggregate  (<span class="attribute">cost</span>=576982.30..576982.31 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2382.035..2382.035 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=1)</span><br><span class="line">   -&gt;  Gather  (<span class="attribute">cost</span>=576981.86..576982.28 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2381.939..2385.143 <span class="attribute">rows</span>=5 <span class="attribute">loops</span>=1)</span><br><span class="line">         Workers Planned: 4</span><br><span class="line">         Workers Launched: 4</span><br><span class="line">         -&gt;  Partial Aggregate  (<span class="attribute">cost</span>=575981.86..575981.88 <span class="attribute">rows</span>=1 <span class="attribute">width</span>=16) (actual <span class="attribute">time</span>=2371.143..2371.143 <span class="attribute">rows</span>=1 <span class="attribute">loops</span>=5)</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_llvm1  (<span class="attribute">cost</span>=0.00..555148.48 <span class="attribute">rows</span>=4166677 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.560..1600.125 <span class="attribute">rows</span>=9999999 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: ((a + b) &gt; 10)</span><br><span class="line">                     Rows Removed by Filter: 1</span><br><span class="line"> Planning Time: 0.083 ms</span><br><span class="line"> Execution Time: 2385.209 ms</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure></p><p>从以上看出执行计划中没有包含 JIT 信息，执行时间为 2385 ms 左右，开启JIT性能提升了9.7% 左右。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/jit.html" target="_blank" rel="noopener">Chapter 32. Just-in-Time Compilation (JIT)</a></li><li><a href="https://llvm.org/" target="_blank" rel="noopener">The LLVM Compiler Infrastructure</a></li><li><a href="https://www.oschina.net/news/94492/postgresql-llvm-jit-landing" target="_blank" rel="noopener">PostgreSQL 已包含对 LLVM JIT 支持的提交性能将飙升</a></li><li><a href="https://blog.dbi-services.com/how-to-compile-postgresql-11-with-support-for-jit-compilation-on-rhelcentos-7/" target="_blank" rel="noopener">How to compile PostgreSQL 11 with support for JIT compilation on RHEL/CentOS 7</a></li><li><a href="https://www.citusdata.com/blog/2018/09/11/postgresql-11-just-in-time/" target="_blank" rel="noopener">PostgreSQL 11 and Just In Time Compilation of Queries</a></li><li><a href="https://llvm.org/devmtg/2016-09/slides/Melnik-PostgreSQLLLVM.pdf" target="_blank" rel="noopener">Speeding up query execution in PostgreSQL using LLVM JIT compiler</a></li><li><a href="http://postgres.cn/release/v/49" target="_blank" rel="noopener">PostgreSQL 11.0 正式版更新版本发布说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于-JIT&quot;&gt;&lt;a href=&quot;#关于-JIT&quot; class=&quot;headerlink&quot; title=&quot;关于 JIT&quot;&gt;&lt;/a&gt;关于 JIT&lt;/h1&gt;&lt;p&gt;PostgreSQL 11 版本的一个重量级新特性是引入了 &lt;a href=&quot;https://www.pos
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: 声明博客的许可协议</title>
    <link href="https://postgres.fun/20181028211900.html"/>
    <id>https://postgres.fun/20181028211900.html</id>
    <published>2018-10-28T13:19:09.000Z</published>
    <updated>2018-10-28T13:27:17.605Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 博客可以声明许可协议，在 <a href="https://creativecommons.org/" target="_blank" rel="noopener"><strong>creativecommons</strong></a> 网站上找适合自己的许可。</p><p>常用的许可协议如下:</p><ul><li>CC BY(署名)</li><li>CC BY-SA(署名-相同方式共享)</li><li>CC BY-ND(署名-禁止演绎)</li><li>CC BY-NC(署名-非商业性使用)</li><li>CC BY-NC-SA(署名-非商业性使用-相同方式共享 )</li><li>CC BY-NC-ND(署名-非商业性使用-禁止演绎)</li></ul><p>关于以上协议的解释详见 <a href="https://creativecommons.org/licenses/" target="_blank" rel="noopener">https://creativecommons.org/licenses/</a> 。</p><p>本博客计划使用 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"><strong>CC BY-SA</strong></a> 协议。</p><h1 id="关于CC-BY-SA协议"><a href="#关于CC-BY-SA协议" class="headerlink" title="关于CC BY-SA协议"></a>关于CC BY-SA协议</h1><p><strong> You are free to:</strong></p><blockquote><p><strong>Attribution</strong> — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.<br><strong>ShareAlike</strong> — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</p></blockquote><p><strong>Under the following terms:</strong></p><blockquote><p><strong>Attribution</strong> — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.<br><strong>ShareAlike</strong> — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.</p></blockquote><p>简单的说， CC BY-SA 协议允许其它人下载、发行、修改，即使是出于商业目的，但必须给出原创出处并指明原创身份，他人发行此作品采取的许可必须和原创作者采取的许可相同。</p><h1 id="设置网站的许可协议"><a href="#设置网站的许可协议" class="headerlink" title="设置网站的许可协议"></a>设置网站的许可协议</h1><p>修改主题配置文件 /d/hexo/themes/next/_config.yml 如下参数:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  license:</span> <span class="string">CC</span> <span class="string">BY-SA</span> <span class="number">4.0</span></span><br><span class="line"><span class="attr">  license_url:</span> <span class="attr">https://creativecommons.org/licenses/by-sa/4.0/</span></span><br></pre></td></tr></table></figure><p>之后刷新博客，如下。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>之后博客的每篇文章的底部显示许可信息，如下:</p><p><img src="/images/xuke.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://creativecommons.org/licenses/" target="_blank" rel="noopener">creativecommons</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hexo 博客可以声明许可协议，在 &lt;a href=&quot;https://creativecommons.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;creativecommons&lt;/strong&gt;&lt;/a&gt; 网站上找适合自己的许可。
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo: 给博客添加百度统计</title>
    <link href="https://postgres.fun/20181027203300.html"/>
    <id>https://postgres.fun/20181027203300.html</id>
    <published>2018-10-27T12:33:52.000Z</published>
    <updated>2018-10-28T12:21:56.387Z</updated>
    
    <content type="html"><![CDATA[<p>当Hexo博客被百度、必应、谷歌搜索引擎收录以后，有件重要的工作是统计博客的访问情况，比如博客的历史访问量、搜索关键字、访问来源、访问地域等统计数据。</p><p> <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener"><strong>百度统计</strong></a> 能方便的完成网站访问量分析统计，本文简单演示下Hexo+Next博客配置百度统计功能。</p><h1 id="开通百度统计帐号"><a href="#开通百度统计帐号" class="headerlink" title="开通百度统计帐号"></a>开通百度统计帐号</h1><p>在 <a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener"><strong>百度统计</strong></a> 注册帐号。</p><p>帐号注册成功后，在网站列表中添加目标网站。</p><h1 id="获取跟踪代码"><a href="#获取跟踪代码" class="headerlink" title="获取跟踪代码"></a>获取跟踪代码</h1><p>网站添加之后在代码管理模块选择代码获取，可以看到如下代码:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> _hmt = _hmt || [];</span></span><br><span class="line"><span class="actionscript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></span><br><span class="line"><span class="actionscript">  hm.src = <span class="string">"https://hm.baidu.com/hm.js?____________________"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="undefined">  s.parentNode.insertBefore(hm, s);</span></span><br><span class="line"><span class="undefined">&#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码需要用户添加到网站全部页面的 <code>&lt;/head&gt;</code> 标签前，Next主题已对百度统计进行配置优化，只需要配置主题配置文件即可，下面会详细介绍。</p><p>其中 hm.js? 后面的字符串为用户的 key 值，将 key 值记录下来，后面会用到。</p><h1 id="配置主题配置文件"><a href="#配置主题配置文件" class="headerlink" title="配置主题配置文件"></a>配置主题配置文件</h1><p>配置主题配置文件 /d/hexo/themes/next/_config.yml ，配置 baidu_analytics 参数，如下:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Baidu </span>Analytics ID</span><br><span class="line"><span class="keyword">baidu_analytics: </span>上面步骤中记录的百度统计里用户的key值。</span><br></pre></td></tr></table></figure><p>修改完参数后执行 <code>hexo g</code> 和 <code>hexo d</code> 命令部署博客。</p><h1 id="验证百度统计"><a href="#验证百度统计" class="headerlink" title="验证百度统计"></a>验证百度统计</h1><p>之后仍然在代码管理模块的代码获取页面进行验证，如下图:</p><p><img src="/images/baidu_tongji_check.png" alt=""></p><p>上图表示验证通过。</p><p>一般过20分钟左右就可以看到网站分析数据，过了几小时后，已经看到博客的访问统计分析数据，如下图:</p><p><img src="/images/baidu_tongji_report1.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.jcsama.com/2016/01/25/hexo-baido-analytics/" target="_blank" rel="noopener">Hexo添加百度统计</a></li><li><a href="http://visugar.com/2017/08/01/20170801HexoPlugins/" target="_blank" rel="noopener">Hexo博客添加SEO-评论系统-阅读统计-站长统计</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当Hexo博客被百度、必应、谷歌搜索引擎收录以后，有件重要的工作是统计博客的访问情况，比如博客的历史访问量、搜索关键字、访问来源、访问地域等统计数据。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://tongji.baidu.com/web/welcome/login&quot; 
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>经历了20多天的闭站备案，终于完成了网站备案。</title>
    <link href="https://postgres.fun/20181026113200.html"/>
    <id>https://postgres.fun/20181026113200.html</id>
    <published>2018-10-26T03:32:22.000Z</published>
    <updated>2018-10-26T06:15:52.237Z</updated>
    
    <content type="html"><![CDATA[<p>经历了20多天的闭站备案，终于完成了网站备案，博客总算有了个合法的身份，这里简单分离下备案经历。</p><p>备案分两部分:</p><ul><li>域名备案</li><li>公安备案</li></ul><h1 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h1><p>原则上部署到国内服务器的网站都需要进行域名备案（部署到外海服务器不需要进行域名备案），到空间提供商备案即可，例如，我的博客部署在腾讯云主机，到腾讯云提交备案申请即可。</p><p>备案主要分为以下四个步骤：</p><ul><li>填写备案类型</li><li>填写备案信息</li><li>办理幕布拍照</li><li>提交管局审核</li></ul><p>其中前三个步骤较快，每一步仅需1-2工作日；第四步为提交管局审核，通常为20个工作日以内，我这次从提交管局审核到审批通过仅需要9个工作日，比预期快，整个域名备案大概花了15个工作日。</p><p>关于备案的详细信息， 参考 <a href="https://cloud.tencent.com/product/ba##" target="_blank" rel="noopener"><strong>域名备案参考</strong></a> 。</p><p>域名备案审核通过之后可以到 <a href="http://www.miitbeian.gov.cn/publish/query/indexFirst.action" target="_blank" rel="noopener"><strong>域名信息备案系统</strong></a> 进行验证，如下:</p><p><img src="/images/beian1.png" alt=""></p><h1 id="公安备案"><a href="#公安备案" class="headerlink" title="公安备案"></a>公安备案</h1><p>完成域名备案后，会提示请于备案完成后的30日内登陆全国公安机关互联网站安全管理服务平台办理公安备案，虽然是个人博客，建议做下公安备案 ，公安备案在 <a href="http://www.beian.gov.cn/portal/index?token=054de65f-4aa5-4942-8a3f-8c59168f51ce" target="_blank" rel="noopener"><strong>互联网安全管理服务平台</strong></a>  进行。</p><p>公安备案手册，详见 <a href="http://bbs.qcloud.com/thread-28158-1-1.html" target="_blank" rel="noopener"><strong>公安备案教程1</strong></a>  和 <a href="https://boke112.com/3338.html" target="_blank" rel="noopener"><strong>公安备案教程2</strong></a></p><p>公安备案审核通过之后可以到  <a href="http://www.beian.gov.cn/portal/recordQuery?token=054de65f-4aa5-4942-8a3f-8c59168f51ce" target="_blank" rel="noopener"><strong>互联网安全管理服务平台</strong></a>  进行查询，如下:</p><p><img src="/images/gongan1.png" alt=""></p><p>公安备案比较快，上午提交，下午就收到审核通过消息了，各地审批时间会有差异。</p><h1 id="添加备案信息到博客"><a href="#添加备案信息到博客" class="headerlink" title="添加备案信息到博客"></a>添加备案信息到博客</h1><p>备案完成后建议将网站备案号放到博客底部，具体操作如下:</p><p>修改 /d/hexo/themes/next/layout/_third-party/analytics/busuanzi-counter.swig 文件，底部添加如下一段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div &gt;</span><br><span class="line">&lt;a target=<span class="string">"_blank"</span> href=<span class="string">"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33010402003707"</span> style=<span class="string">"display:inline-block;text-decoration:none;height:20px;line-height:20px;"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/images/gongan.png"</span> <span class="attr">style</span>=<span class="string">"float:left;"</span>/&gt;</span>浙公网安备 33010402003707号<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.miitbeian.gov.cn"</span>&gt;</span>浙ICP备18045927号<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src="/images/postgres_fun_beian.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://cloud.tencent.com/product/ba" target="_blank" rel="noopener">https://cloud.tencent.com/product/ba</a></li><li><a href="http://bbs.qcloud.com/thread-28158-1-1.html" target="_blank" rel="noopener">http://bbs.qcloud.com/thread-28158-1-1.html</a></li><li><a href="https://boke112.com/3338.html" target="_blank" rel="noopener">https://boke112.com/3338.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经历了20多天的闭站备案，终于完成了网站备案，博客总算有了个合法的身份，这里简单分离下备案经历。&lt;/p&gt;
&lt;p&gt;备案分两部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域名备案&lt;/li&gt;
&lt;li&gt;公安备案&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;域名备案&quot;&gt;&lt;a href=&quot;#域名备案&quot; 
      
    
    </summary>
    
      <category term="Hexo" scheme="https://postgres.fun/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://postgres.fun/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: psql 新增变量记录SQL语句的执行情况和错误</title>
    <link href="https://postgres.fun/20181018084300.html"/>
    <id>https://postgres.fun/20181018084300.html</id>
    <published>2018-10-18T00:43:41.000Z</published>
    <updated>2018-10-18T00:44:57.641Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本新增加 ERROR、SQLSTATE、ROW_COUNT、LAST_ERROR_MESSAGE、LAST_ERROR_SQLSTATE 五个变量用来记录SQL语句的执行结果状态和错误信息。</p><p>这些变量的值随着SQL执行后进行刷新，主要用来编写脚本时捕获SQL的执行结果。</p><h1 id="Release-说明"><a href="#Release-说明" class="headerlink" title="Release 说明"></a>Release 说明</h1><blockquote><p>Add psql variables to report query activity and errors (Fabien Coelho)<br>Specifically, the new variables are ERROR, SQLSTATE, ROW_COUNT, LAST_ERROR_MESSAGE, and LAST_ERROR_SQLSTATE.</p></blockquote><h1 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h1><p>关于这几个变量的说明如下:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**ERROR**</span><br><span class="line"><span class="literal">true</span> <span class="keyword">if</span> <span class="keyword">the</span> <span class="keyword">last</span> SQL query failed, <span class="literal">false</span> <span class="keyword">if</span> <span class="keyword">it</span> succeeded. See also SQLSTATE.</span><br><span class="line"></span><br><span class="line">**SQLSTATE**</span><br><span class="line">The error code (see Appendix A) associated <span class="keyword">with</span> <span class="keyword">the</span> <span class="keyword">last</span> SQL query is failure, <span class="keyword">or</span> <span class="number">00000</span> <span class="keyword">if</span> <span class="keyword">it</span> succeeded.</span><br><span class="line"></span><br><span class="line">**ROW_COUNT**</span><br><span class="line">The <span class="built_in">number</span> <span class="keyword">of</span> rows returned <span class="keyword">or</span> affected <span class="keyword">by</span> <span class="keyword">the</span> <span class="keyword">last</span> SQL query, <span class="keyword">or</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">the</span> query failed <span class="keyword">or</span> did <span class="keyword">not</span> report <span class="keyword">a</span> row count.</span><br><span class="line"></span><br><span class="line">**LAST_ERROR_MESSAGE**</span><br><span class="line">**LAST_ERROR_SQLSTATE**</span><br><span class="line">The primary error message <span class="keyword">and</span> associated SQLSTATE code <span class="keyword">for</span> <span class="keyword">the</span> most recent failed query <span class="keyword">in</span> <span class="keyword">the</span> current psql session, <span class="keyword">or</span> <span class="keyword">an</span> <span class="literal">empty</span> <span class="keyword">string</span> <span class="keyword">and</span> <span class="number">00000</span> <span class="keyword">if</span> no error has occurred <span class="keyword">in</span> <span class="keyword">the</span> current session.</span><br></pre></td></tr></table></figure><p>这几个变更的解释很容易理解，下面演示下。</p><h1 id="演示：SQL执行成功"><a href="#演示：SQL执行成功" class="headerlink" title="演示：SQL执行成功"></a>演示：SQL执行成功</h1><p>正常执行一条SQL,执行后查看 ERROR、SQLSTATE、ROW_COUNT 变量，如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; SELECT * <span class="keyword">FROM</span> generate_series(1,3);</span><br><span class="line"> generate_series</span><br><span class="line">-----------------</span><br><span class="line">               1</span><br><span class="line">               2</span><br><span class="line">               3</span><br><span class="line">(3 rows)</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo <span class="keyword">:ERROR</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :SQLSTATE</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :ROW_COUNT</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="演示：SQL执行失败"><a href="#演示：SQL执行失败" class="headerlink" title="演示：SQL执行失败"></a>演示：SQL执行失败</h1><p>SQL执行失败,执行后查看 ERROR、SQLSTATE、ROW_COUNT 变更，如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT *,afcd <span class="keyword">FROM</span> generate_series(1,3);</span><br><span class="line">ERROR:  column <span class="string">"afcd"</span> does <span class="keyword">not</span> exist</span><br><span class="line">LINE 1: SELECT *,afcd <span class="keyword">FROM</span> generate_series(1,3);</span><br><span class="line">                 ^</span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo <span class="keyword">:ERROR</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :SQLSTATE</span><br><span class="line">42703</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :ROW_COUNT</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :LAST_ERROR_MESSAGE</span><br><span class="line">column <span class="string">"afcd"</span> does <span class="keyword">not</span> exist</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \echo :LAST_ERROR_SQLSTATE</span><br><span class="line">42703</span><br></pre></td></tr></table></figure><p>SQLSTATE 变量返回SQL报错代码，SQL报错代码可参考手册 <a href="https://www.postgresql.org/docs/11/static/errcodes-appendix.html" target="_blank" rel="noopener">PostgreSQL Error Codes</a> 。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/app-psql.html" target="_blank" rel="noopener">psql</a></li><li><a href="https://www.postgresql.org/docs/11/static/errcodes-appendix.html" target="_blank" rel="noopener">PostgreSQL Error Codes</a></li><li><a href="https://www.depesz.com/2017/09/21/waiting-for-postgresql-11-add-psql-variables-to-track-successfailure-of-sql-queries/" target="_blank" rel="noopener">Waiting for PostgreSQL 11 – Add psql variables to track success/failure of SQL queries.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本新增加 ERROR、SQLSTATE、ROW_COUNT、LAST_ERROR_MESSAGE、LAST_ERROR_SQLSTATE 五个变量用来记录SQL语句的执行结果状态和错误信息。&lt;/p&gt;
&lt;p&gt;这些变量的值随着SQL执行后进行刷新，
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="psql" scheme="https://postgres.fun/tags/psql/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: psql 新增 \gdesc 显示查询结果的列名和类型</title>
    <link href="https://postgres.fun/20181017123400.html"/>
    <id>https://postgres.fun/20181017123400.html</id>
    <published>2018-10-17T04:34:42.000Z</published>
    <updated>2018-10-17T13:10:53.928Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 的 <code>psql</code> 新增 \gdesc 选项，此选项可以返回查询结果的列名和类型，而不实际执行SQL。</p><h1 id="Release-说明"><a href="#Release-说明" class="headerlink" title="Release 说明"></a>Release 说明</h1><blockquote><p>psql<br>Add psql command \gdesc to display the column names and types of the query output (Pavel Stehule)</p></blockquote><h1 id="gdesc-选项说明"><a href="#gdesc-选项说明" class="headerlink" title="\gdesc 选项说明"></a>\gdesc 选项说明</h1><blockquote><p><strong>\gdesc</strong><br>Shows the description (that is, the column names and data types) of the result of the current query buffer. The query is not actually executed; however, if it contains some type of syntax error, that error will be reported in the normal way.<br>If the current query buffer is empty, the most recently sent query is described instea</p></blockquote><p>\gdesc 只是显示查询结果的列名和类型，并不实际执行SQL，下面演示下。</p><h1 id="gdesc-选项演示"><a href="#gdesc-选项演示" class="headerlink" title="\gdesc 选项演示"></a>\gdesc 选项演示</h1><p>数据库中存在一张大表big，结构如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \d big</span><br><span class="line">                                  Table <span class="string">"francs.big"</span></span><br><span class="line">  Column   |             <span class="built_in"> Type </span>             | Collation | Nullable |      Default</span><br><span class="line">-----------+--------------------------------+-----------+----------+-------------------</span><br><span class="line"> user_id   | integer                        |           |          |</span><br><span class="line"> user_name | text                           |           |          |</span><br><span class="line"> ctime     | timestamp(6) without time zone |           |          | clock_timestamp()</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"idx_big_ctime"</span> btree (ctime)</span><br><span class="line">    <span class="string">"idx_big_username"</span> btree (user_name)</span><br></pre></td></tr></table></figure><p>执行以下查询，如下:<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> \timing</span></span><br><span class="line">Timing is on.</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> SELECT count(<span class="name"><span class="builtin-name">*</span></span>),sum(<span class="name">hashtext</span>(<span class="name">user_name</span>)) FROM big<span class="comment">;</span></span></span><br><span class="line">  count   |      sum</span><br><span class="line">----------+----------------</span><br><span class="line"> 30000000 | 11924569894736</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 1347.527 ms (00:01.348)</span><br></pre></td></tr></table></figure></p><p>执行时间为 1347 ms 左右。</p><p>使用 \gdesc 选项查询，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT count(*),sum(hashtext(user_name)) <span class="keyword">FROM</span> big \gdesc</span><br><span class="line"> Column |  Type</span><br><span class="line">--------+--------</span><br><span class="line"> count  | bigint</span><br><span class="line"> sum    | bigint</span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">Time: 0.634 ms</span><br></pre></td></tr></table></figure></p><p>以上返回了查询结果的列和数据类型，执行很快，只需要 0.634 ms，可见没有实际执行SQL。</p><p>另一个示例，查询 pg_class 系统表，如下:<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM pg_class \gdesc</span><br><span class="line">       Column        <span class="string">|     Type</span></span><br><span class="line">---------------------+--------------</span><br><span class="line"> relname             <span class="string">| name</span></span><br><span class="line"> relnamespace        <span class="string">| oid</span></span><br><span class="line"> reltype             <span class="string">| oid</span></span><br><span class="line"> reloftype           <span class="string">| oid</span></span><br><span class="line"> relowner            <span class="string">| oid</span></span><br><span class="line"> relam               <span class="string">| oid</span></span><br><span class="line"> relfilenode         <span class="string">| oid</span></span><br><span class="line"> reltablespace       <span class="string">| oid</span></span><br><span class="line"> relpages            <span class="string">| integer</span></span><br><span class="line"> reltuples           <span class="string">| real</span></span><br><span class="line"> relallvisible       <span class="string">| integer</span></span><br><span class="line"> reltoastrelid       <span class="string">| oid</span></span><br><span class="line"> relhasindex         <span class="string">| boolean</span></span><br><span class="line"> relisshared         <span class="string">| boolean</span></span><br><span class="line"> relpersistence      <span class="string">| "</span>char<span class="string">"</span></span><br><span class="line"> relkind             <span class="string">| "</span>char<span class="string">"</span></span><br><span class="line"> relnatts            <span class="string">| smallint</span></span><br><span class="line"> relchecks           <span class="string">| smallint</span></span><br><span class="line"> relhasoids          <span class="string">| boolean</span></span><br><span class="line"> relhasrules         <span class="string">| boolean</span></span><br><span class="line"> relhastriggers      <span class="string">| boolean</span></span><br><span class="line"> relhassubclass      <span class="string">| boolean</span></span><br><span class="line"> relrowsecurity      <span class="string">| boolean</span></span><br><span class="line"> relforcerowsecurity <span class="string">| boolean</span></span><br><span class="line"> relispopulated      <span class="string">| boolean</span></span><br><span class="line"> relreplident        <span class="string">| "</span>char<span class="string">"</span></span><br><span class="line"> relispartition      <span class="string">| boolean</span></span><br><span class="line"> relrewrite          <span class="string">| oid</span></span><br><span class="line"> relfrozenxid        <span class="string">| xid</span></span><br><span class="line"> relminmxid          <span class="string">| xid</span></span><br><span class="line"> relacl              <span class="string">| aclitem[]</span></span><br><span class="line"> reloptions          <span class="string">| text[]</span></span><br><span class="line"> relpartbound        <span class="string">| pg_node_tree</span></span><br><span class="line">(<span class="number">33</span> rows)</span><br></pre></td></tr></table></figure></p><p>这个特性不需要实际执行SQL就能返回查询结果的列和数据类型，在某些特定场景比较有用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.depesz.com/2017/09/21/waiting-for-postgresql-11-add-gdesc-psql-command/" target="_blank" rel="noopener">Waiting for PostgreSQL 11 – Add \gdesc psql command</a></li><li><a href="https://www.postgresql.org/docs/11/static/app-psql.html" target="_blank" rel="noopener">psql</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 的 &lt;code&gt;psql&lt;/code&gt; 新增 \gdesc 选项，此选项可以返回查询结果的列名和类型，而不实际执行SQL。&lt;/p&gt;
&lt;h1 id=&quot;Release-说明&quot;&gt;&lt;a href=&quot;#Release-说明&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="psql" scheme="https://postgres.fun/tags/psql/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: Initdb/Pg_resetwal支持修改WAL文件大小</title>
    <link href="https://postgres.fun/20181016214500.html"/>
    <id>https://postgres.fun/20181016214500.html</id>
    <published>2018-10-16T13:45:25.000Z</published>
    <updated>2018-10-16T13:50:07.882Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本的一个重要调整是支持 <code>initdb</code> 和 <code>pg_resetwal</code> 修改 WAL 文件大小，而 11 版本之前只能在编译安装 PostgreSQL 时设置 WAL 文件大小。这一特性能够方便 WAL 文件的管理。</p><h1 id="Release-的说明"><a href="#Release-的说明" class="headerlink" title="Release 的说明"></a>Release 的说明</h1><blockquote><p>Allow the WAL file size to be set via initdb (Beena Emerson)<br>Previously the 16MB default could only be changed at compile time.</p></blockquote><p>下面分别演示通过 <code>initdb</code> 和 <code>pg_resetwal</code> 修改 WAL 文件大小。</p><h1 id="使用-initdb-调整WAL文件大小"><a href="#使用-initdb-调整WAL文件大小" class="headerlink" title="使用 initdb 调整WAL文件大小"></a>使用 initdb 调整WAL文件大小</h1><p><code>initdb</code> 命令关于修改 WAL 文件大小选项，如下: </p><blockquote><p><strong>–wal-segsize=size</strong><br>Set the WAL segment size, in megabytes. This is the size of each individual file in the WAL log. The default size is 16 megabytes. The value must be a power of 2 between 1 and 1024 (megabytes). This option can only be set during initialization, and cannot be changed later.<br>It may be useful to adjust this size to control the granularity of WAL log shipping or archiving. Also, in databases with a high volume of WAL, the sheer number of WAL files per directory can become a performance and management problem. Increasing the WAL file size will reduce the number of WAL files.</p></blockquote><p>WAL 日志文件大小默认为16MB，该值必须是1到1024之间的2的次方，增大WAL文件大小能够减少WAL日志文件的产生。</p><p>初始化一个新的 PostgreSQL 数据库实例，指定WAL文件大小64MB，如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ initdb -E UTF8 <span class="attribute">--locale</span>=C <span class="attribute">--wal-segsize</span>=64 -D /home/pg11/data01 -U postgres -W</span><br><span class="line">The files belonging <span class="keyword">to</span> this database<span class="built_in"> system </span>will be owned by<span class="built_in"> user </span><span class="string">"pg11"</span>.</span><br><span class="line">This<span class="built_in"> user </span>must also own the<span class="built_in"> server </span>process.</span><br><span class="line"></span><br><span class="line">The database cluster will be initialized with locale <span class="string">"C"</span>.</span><br><span class="line">The<span class="built_in"> default </span>text search configuration will be <span class="builtin-name">set</span> <span class="keyword">to</span> <span class="string">"english"</span>.</span><br><span class="line"></span><br><span class="line">Data<span class="built_in"> page </span>checksums are disabled.</span><br><span class="line"></span><br><span class="line">Enter new superuser password: </span><br><span class="line">Enter it again: </span><br><span class="line"></span><br><span class="line">creating directory /home/pg11/data01 <span class="built_in">..</span>. ok</span><br><span class="line">creating subdirectories <span class="built_in">..</span>. ok</span><br><span class="line">selecting<span class="built_in"> default </span>max_connections <span class="built_in">..</span>. 100</span><br><span class="line">selecting<span class="built_in"> default </span>shared_buffers <span class="built_in">..</span>. 128MB</span><br><span class="line">selecting dynamic shared memory implementation <span class="built_in">..</span>. posix</span><br><span class="line">creating configuration files <span class="built_in">..</span>. ok</span><br><span class="line">running bootstrap<span class="built_in"> script </span><span class="built_in">..</span>. ok</span><br><span class="line">performing post-bootstrap initialization <span class="built_in">..</span>. ok</span><br><span class="line">syncing data <span class="keyword">to</span> disk <span class="built_in">..</span>. ok</span><br><span class="line"></span><br><span class="line">WARNING: enabling <span class="string">"trust"</span> authentication <span class="keyword">for</span> local connections</span><br><span class="line">You can change this by editing pg_hba.conf <span class="keyword">or</span> using the option -A, <span class="keyword">or</span></span><br><span class="line">--auth-local <span class="keyword">and</span> --auth-host, the next time you <span class="builtin-name">run</span> initdb.</span><br><span class="line"></span><br><span class="line">Success. You can now start the database<span class="built_in"> server </span>using:</span><br><span class="line"></span><br><span class="line">    pg_ctl -D /home/pg11/data01 -l logfile start</span><br></pre></td></tr></table></figure><p>修改 postgresql.conf 相关配置，之后启动数据库。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 data01]$ pg_ctl start -D /home/pg11/data01</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-16 15:58:16.714 CST [10583] LOG:  listening on<span class="built_in"> IPv6 address </span><span class="string">"::1"</span>,<span class="built_in"> port </span>1950</span><br><span class="line">2018-10-16 15:58:16.714 CST [10583] LOG:  listening on IPv4<span class="built_in"> address </span><span class="string">"127.0.0.1"</span>,<span class="built_in"> port </span>1950</span><br><span class="line">2018-10-16 15:58:16.731 CST [10583] LOG:  listening on Unix socket <span class="string">"/tmp/.s.PGSQL.1950"</span></span><br><span class="line">2018-10-16 15:58:16.762 CST [10584] LOG:  database<span class="built_in"> system </span>was shut down at 2018-10-16 15:56:46 CST</span><br><span class="line">2018-10-16 15:58:16.782 CST [10583] LOG:  database<span class="built_in"> system </span>is ready <span class="keyword">to</span> accept connections</span><br><span class="line"> done</span><br><span class="line">server started</span><br></pre></td></tr></table></figure><p>验证WAL文件大小，如下:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p<span class="name">g11</span>@pghost<span class="number">2</span> ~]$ ll /home/p<span class="name">g11</span>/data<span class="number">01</span>/pg_wal</span><br><span class="line">total <span class="number">65</span>M</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span>  <span class="number">64</span>M Oct <span class="number">16</span> <span class="number">16</span>:<span class="number">03</span> <span class="number">000000010000000000000001</span></span><br><span class="line">drwx------ <span class="number">2</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">4.0</span>K Oct <span class="number">16</span> <span class="number">15</span>:<span class="number">56</span> archive_status</span><br></pre></td></tr></table></figure><p>可见WAL文件大小为64MB。</p><h1 id="使用-pg-resetwal-调整WAL文件大小"><a href="#使用-pg-resetwal-调整WAL文件大小" class="headerlink" title="使用 pg_resetwal 调整WAL文件大小"></a>使用 pg_resetwal 调整WAL文件大小</h1><p><code>pg_resetwal</code> 用来重置WAL日志和一些控制信息，常用于数据库恢复场景，不到万不得已不轻易使用，以下演示使用<code>pg_resetwal</code>命令调整WAL日志文件大小，仅供测试参考，生产环境慎用。</p><p><code>pg_resetwal</code> 命令关于调整WAL文件大小的选项，如下:</p><blockquote><p><strong>–wal-segsize=wal_segment_size</strong><br>Set the new WAL segment size, in megabytes. The value must be set to a power of 2 between 1 and 1024 (megabytes). See the same option of initdb for more information.</p></blockquote><p>以下演示在已有PostgreSQL实例基础上调整WAL日志文件大小。</p><p>查看当前数据库的 pg_wal 目录，如下:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[p<span class="name">g11</span>@pghost<span class="number">2</span> pg_wal]$ ll /database/p<span class="name">g11</span>/pg_root/pg_wal/</span><br><span class="line">total <span class="number">2.3</span>G</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000013</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000014</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000015</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000016</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000017</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000018</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">000000010000001700000019</span></span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">00000001000000170000001</span>A</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>M Sep <span class="number">30</span> <span class="number">14</span>:<span class="number">45</span> <span class="number">00000001000000170000001</span>B</span><br><span class="line">...</span><br><span class="line">省略</span><br><span class="line">drwx------ <span class="number">2</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>K Oct <span class="number">16</span> <span class="number">08</span>:<span class="number">38</span> archive_status</span><br></pre></td></tr></table></figure><p>pg_wal 目录中已有大量WAL日志文件，WAL文件大小为16MB，计划将WAL日志文件调整成64MB。</p><p><code>pg_resetwal</code> 操作时需要关闭数据库，如下。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_ctl stop -m fast</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> shut down<span class="built_in">..</span><span class="built_in">..</span> done</span><br><span class="line">server stopped</span><br></pre></td></tr></table></figure><p><code>pg_resetwal</code> 命令调整WAL日志文件大小为 64MB:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_resetwal --wal-segsize=<span class="number">64</span> -D /database/pg11/pg_root</span><br><span class="line">Write-ahead <span class="keyword">log</span> <span class="keyword">reset</span></span><br></pre></td></tr></table></figure></p><p>验证WAL文件大小,如下:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[p<span class="name">g11</span>@pghost<span class="number">2</span> ~]$ ll /database/p<span class="name">g11</span>/pg_root/pg_wal/</span><br><span class="line">total <span class="number">65</span>M</span><br><span class="line">-rw------- <span class="number">1</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">64</span>M Oct <span class="number">16</span> <span class="number">08</span>:<span class="number">55</span> <span class="number">000000010000001700000029</span></span><br><span class="line">drwx------ <span class="number">2</span> p<span class="name">g11</span> p<span class="name">g11</span> <span class="number">16</span>K Oct <span class="number">16</span> <span class="number">08</span>:<span class="number">55</span> archive_status</span><br></pre></td></tr></table></figure><p>发现 pg_wal 目录中原有的WAL日志被清理，同时生成了大小为64MB新的WAL文件。</p><p>启动数据库提示 min_wal_size 参数至少需设置成 wal_segment_size 大小为 2 倍。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_ctl start</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-16 09:01:26.096 CST [24318] FATAL:  <span class="string">"min_wal_size"</span> must be at least twice <span class="string">"wal_segment_size"</span>.</span><br><span class="line">2018-10-16 09:01:26.096 CST [24318] LOG:  database<span class="built_in"> system </span>is shut down</span><br><span class="line"> stopped waiting</span><br><span class="line">pg_ctl: could <span class="keyword">not</span> start server</span><br><span class="line">Examine the log output.</span><br></pre></td></tr></table></figure></p><p>根据提示调整 postgresql.conf，设置如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">min_wal_size</span> = <span class="number">128</span>MB</span><br></pre></td></tr></table></figure></p><p>启动数据库正常，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ pg_ctl start</span><br><span class="line">waiting <span class="keyword">for</span><span class="built_in"> server </span><span class="keyword">to</span> start<span class="built_in">..</span><span class="built_in">..</span>2018-10-16 09:02:45.680 CST [24614] LOG:  listening on IPv4<span class="built_in"> address </span><span class="string">"0.0.0.0"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-16 09:02:45.680 CST [24614] LOG:  listening on<span class="built_in"> IPv6 address </span><span class="string">"::"</span>,<span class="built_in"> port </span>1930</span><br><span class="line">2018-10-16 09:02:45.687 CST [24614] LOG:  listening on Unix socket <span class="string">"/tmp/.s.PGSQL.1930"</span></span><br><span class="line">2018-10-16 09:02:45.715 CST [24614] LOG:  redirecting log output <span class="keyword">to</span><span class="built_in"> logging </span>collector process</span><br><span class="line">2018-10-16 09:02:45.715 CST [24614] HINT:  Future log output will appear <span class="keyword">in</span> directory <span class="string">"log"</span>.</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>以上演示了 11 版本通过 <code>initdb</code> 和 <code>pg_resetwal</code> 调整WAL文件大小。</li><li><code>pg_resetwal</code> 会清除pg_wal目录的WAL文件，本博客的测试样例仅供参考，生产环境使用需慎重。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/app-initdb.html" target="_blank" rel="noopener">initdb</a></li><li><a href="https://www.postgresql.org/docs/11/static/app-pgresetwal.html" target="_blank" rel="noopener">pg_resetwal</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本的一个重要调整是支持 &lt;code&gt;initdb&lt;/code&gt; 和 &lt;code&gt;pg_resetwal&lt;/code&gt; 修改 WAL 文件大小，而 11 版本之前只能在编译安装 PostgreSQL 时设置 WAL 文件大小。这一特性能够方便 W
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 可通过GRNAT权限下放的四个系统函数</title>
    <link href="https://postgres.fun/20181015113300.html"/>
    <id>https://postgres.fun/20181015113300.html</id>
    <published>2018-10-15T03:33:49.000Z</published>
    <updated>2018-10-15T03:40:53.253Z</updated>
    
    <content type="html"><![CDATA[<p>涉及到数据库服务端文件读取的系统函数通常需要管理员权限，例如 pg_ls_dir()等系统函数，PostgreSQL 11 版本支持少量文件读取的系统函数权限下放，可通过 GRANT/REVOKE 将权限赋给普通用户，目前以下四个文件读取系统函数支持权限下放：</p><ul><li><strong>pg_ls_dir():</strong> List the contents of a directory. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</li><li><strong>pg_read_file()</strong>: Return the contents of a text file. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</li><li><strong>pg_read_binary_file():</strong> Return the contents of a file. Restricted to superusers by default, but other users can be granted EXECUTE to run the functio</li><li><strong>pg_stat_file():</strong> Return information about a file. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</li></ul><p>这四个函数在11版本之前只有超级用户才有权限使用。</p><h1 id="一、Release说明"><a href="#一、Release说明" class="headerlink" title="一、Release说明"></a>一、Release说明</h1><blockquote><p>Allow access to file system functions to be controlled by GRANT/REVOKE permissions, rather than superuser checks (Stephen Frost)<br>Specifically, these functions were modified: pg_ls_dir(), pg_read_file(), pg_read_binary_file(), pg_stat_file().</p></blockquote><p>以上四个函数使用上差异不大，本文仅演示其中两个函数。</p><h1 id="二、pg-ls-dir"><a href="#二、pg-ls-dir" class="headerlink" title="二、pg_ls_dir()"></a>二、pg_ls_dir()</h1><p>pg_ls_dir()函数可以列出数据库服务端数据目录的文件，11版本前只有超级用户才有权限调用。</p><h2 id="PostgreSQL-10-测试"><a href="#PostgreSQL-10-测试" class="headerlink" title="PostgreSQL 10 测试"></a>PostgreSQL 10 测试</h2><p>10 版本测试如下:<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[postgres@pghost1 ~]$ psql mydb pguser</span><br><span class="line">psql (10.0)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">mydb=&gt; SELECT pg_ls_dir('pg_wal');</span><br><span class="line"><span class="keyword">ERROR:  </span>must be superuser to get directory listings</span><br></pre></td></tr></table></figure></p><p>以上显示只有超级用户才有权限。</p><p>尝试将函数 pg_ls_dir()的可执行权限赋给普通用户 pguser。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; \c mydb postgres</span><br><span class="line">You are <span class="built_in">now</span> connected <span class="keyword">to</span> database <span class="string">"mydb"</span> as user <span class="string">"postgres"</span>.</span><br><span class="line"></span><br><span class="line">mydb=# GRANT <span class="keyword">EXECUTE</span> <span class="keyword">ON</span> <span class="keyword">FUNCTION</span> pg_ls_dir(text) <span class="keyword">TO</span> pguser;</span><br><span class="line">GRANT</span><br><span class="line"></span><br><span class="line">mydb=# \c mydb pguser</span><br><span class="line">You are <span class="built_in">now</span> connected <span class="keyword">to</span> database <span class="string">"mydb"</span> as user <span class="string">"pguser"</span>.</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">select</span> pg_ls_dir(<span class="comment">'pg_wal');</span></span><br><span class="line"><span class="keyword">ERROR</span>:  must be superuser <span class="keyword">to</span> <span class="keyword">get</span> directory listings</span><br></pre></td></tr></table></figure><p>以上看出，将函数pg_ls_dir()的执行权限赋给普通用户后，普通用户依然没有权限执行。</p><h2 id="PostgreSQL-11-测试"><a href="#PostgreSQL-11-测试" class="headerlink" title="PostgreSQL 11 测试"></a>PostgreSQL 11 测试</h2><p>将函数 pg_ls_dir()的可执行权限赋给普通用户 role11 。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT EXECUTE ON FUNCTION pg_ls_dir(text) <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure><p>以 role11 用户登录 francs 库测试:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT pg<span class="emphasis">_ls_</span>dir(<span class="emphasis">'pg_wal'</span>);</span><br><span class="line"><span class="code">        pg_ls_dir</span></span><br><span class="line">--------------------------</span><br><span class="line"><span class="code"> 00000001000000170000002B</span></span><br><span class="line"><span class="code"> 000000010000001700000025</span></span><br><span class="line"><span class="code"> 000000010000001700000034</span></span><br><span class="line"><span class="code"> 000000010000001700000073</span></span><br><span class="line"><span class="code"> ...省略</span></span><br></pre></td></tr></table></figure></p><p>普通用户执行 pg_ls_dir(‘pg_wal’) 函数成功，已查看到数据库服务端的 pg_wal 目录文件。</p><h1 id="三、pg-read-file"><a href="#三、pg-read-file" class="headerlink" title="三、pg_read_file()"></a>三、pg_read_file()</h1><p>pg_read_file()函数可以显示数据库服务端文本文件的内容，11版本前只有超级用户才有权限调用。</p><h2 id="PostgreSQL-10-测试-1"><a href="#PostgreSQL-10-测试-1" class="headerlink" title="PostgreSQL 10 测试"></a>PostgreSQL 10 测试</h2><p>10 版本测试，如下:<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[postgres@pghost1 ~]$ psql mydb pguser</span><br><span class="line">psql (10.0)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">mydb=&gt; SELECT pg_read_file('/home/postgres/t_copy2.txt');</span><br><span class="line"><span class="keyword">ERROR:  </span>must be superuser to read files</span><br></pre></td></tr></table></figure></p><p>显示只有超级用户才有权限执行。</p><h2 id="PostgreSQL-11-测试-1"><a href="#PostgreSQL-11-测试-1" class="headerlink" title="PostgreSQL 11 测试"></a>PostgreSQL 11 测试</h2><p>将函数 pg_read_file()的可执行权限赋给普通用户 role11 。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT EXECUTE ON FUNCTION pg_read_file(text) <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure><p>以role11用户登录francs库测试，如下:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; select pg<span class="emphasis">_read_</span>file (<span class="emphasis">'/home/pg11/t_copy2.txt'</span>);</span><br><span class="line"><span class="code"> pg_read_file</span></span><br><span class="line">--------------</span><br><span class="line"><span class="code"> 1       a   +</span></span><br><span class="line"><span class="code"> 2       b   +</span></span><br><span class="line"></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>赋权后，普通用户role11有权限执行 pg_read_file() 函数查看数据库服务端文件内容。</p><h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/functions-admin.html#FUNCTIONS-ADMIN-GENFILE-TABLE" target="_blank" rel="noopener">Generic File Access Functions</a></li><li><a href="https://postgres.fun/20181013215100.html">PostgreSQL11: 新增三个默认角色</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;涉及到数据库服务端文件读取的系统函数通常需要管理员权限，例如 pg_ls_dir()等系统函数，PostgreSQL 11 版本支持少量文件读取的系统函数权限下放，可通过 GRANT/REVOKE 将权限赋给普通用户，目前以下四个文件读取系统函数支持权限下放：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 新增三个默认角色</title>
    <link href="https://postgres.fun/20181013215100.html"/>
    <id>https://postgres.fun/20181013215100.html</id>
    <published>2018-10-13T13:51:35.000Z</published>
    <updated>2018-10-13T13:55:36.147Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 新增三个默认系统角色，如下：</p><ul><li>pg_read_server_files</li><li>pg_write_server_files</li><li>pg_execute_server_program</li></ul><p>这三个角色主要涉及数据库服务端文件的读写权限，例如使用copy命令或file_fdw模块读写数据库端文件的权限。</p><p>这些权限之前版本只有超级用户才具备，这三个默认角色的出现，使得可以将数据库服务端的文件的访问权限（目前仅包含copy命令或file_fdw模块）下放给普通用户。</p><h1 id="Release说明"><a href="#Release说明" class="headerlink" title="Release说明"></a>Release说明</h1><blockquote><p>Add default roles which control file system access (Stephen Frost)<br>Specifically, the new roles are: pg_read_server_files, pg_write_server_files, pg_execute_server_program. These roles now also control who can use COPY and extension file_fdw. Previously only superusers could use these functions, and that is still the default behavior.</p></blockquote><p>手册中说明很清楚，下面演示这三种角色的权限。</p><h1 id="pg-read-server-files"><a href="#pg-read-server-files" class="headerlink" title="pg_read_server_files"></a>pg_read_server_files</h1><p>pg_read_server_files 角色具有数据库服务端文件的读权限，例如使用copy命令或file_fdw模块读数据库端文件的权限。</p><p>在数据库主机 pghost2 家目录创建 t_copy.txt 文件并写入两行数据，如下：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>      a</span><br><span class="line"><span class="symbol">2 </span>      b</span><br></pre></td></tr></table></figure></p><p>以 francs 用户登录数据库 francs 创建测试表 t_copy 如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; CREATE TABLE t_copy(id int4, name text);</span><br><span class="line">CREATE TABLE</span><br></pre></td></tr></table></figure></p><p>创建 role11 用户，如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres=# <span class="keyword">CREATE</span> <span class="keyword">ROLE</span> role11 NOSUPERUSER <span class="keyword">PASSWORD</span> <span class="string">'role11'</span> LOGIN;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span></span><br></pre></td></tr></table></figure></p><p>以 role11 用户登录到 francs 数据库，执行 copy 命令，尝试将数据库服务端文件 t_copy.txt 文件的数据加载到表 t_copy 中，如下:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (<span class="number">11beta</span>3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">francs=&gt; COPY t_copy FROM <span class="string">'/home/pg11/t_copy.txt'</span>;</span><br><span class="line">ERROR:  must be superuser <span class="keyword">or</span> a member <span class="keyword">of</span> the pg_read_server_files role <span class="keyword">to</span> COPY <span class="keyword">from</span> a file</span><br><span class="line">HINT:  Anyone can COPY <span class="keyword">to</span> stdout <span class="keyword">or</span> <span class="keyword">from</span> stdin. psql s <span class="string">\copy</span> command also works <span class="keyword">for</span> anyone.</span><br></pre></td></tr></table></figure></p><p>以上报错，提示需要超级用户或具有pg_read_server_files权限才能使用 COPY 命令读取数据库服务端文件。</p><p>给 role11 用户赋 pg_read_server_files 角色权限，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; \c francs postgres</span><br><span class="line">You are now connected <span class="keyword">to</span> database <span class="string">"francs"</span> as<span class="built_in"> user </span><span class="string">"postgres"</span>.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT pg_read_server_files <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT ROLE</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT USAGE ON SCHEMA francs <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT INSERT ON francs.t_copy <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure></p><p>francs库中创建了模式 francs ，因此也需要将模式的使用权限赋给 role11，否则访问表时会报没有使用模式权限的错误；之后再赋予表的写权限。</p><p>再次测试成功，如下。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (<span class="number">11</span>beta3)</span><br><span class="line">Type <span class="string">"help"</span> for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">COPY</span><span class="bash"> francs.t_copy FROM <span class="string">'/home/pg11/t_copy.txt'</span>;</span></span><br><span class="line"><span class="bash">COPY 2</span></span><br></pre></td></tr></table></figure></p><h1 id="pg-write-server-files"><a href="#pg-write-server-files" class="headerlink" title="pg_write_server_files"></a>pg_write_server_files</h1><p>pg_write_server_files  角色具有数据库服务端文件的写权限，例如使用copy命令或file_fdw模块写数据库端文件的权限，接着演示。</p><p>以 role11 用户登录数据库 francs ，尝试导出表数据到数据库服务端。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11;</span><br><span class="line">psql (<span class="number">11beta</span>3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">francs=&gt; COPY francs.t_copy TO <span class="string">'/home/pg11/t_copy2.txt'</span>;</span><br><span class="line">ERROR:  must be superuser <span class="keyword">or</span> a member <span class="keyword">of</span> the pg_write_server_files role <span class="keyword">to</span> COPY <span class="keyword">to</span> a file</span><br><span class="line">HINT:  Anyone can COPY <span class="keyword">to</span> stdout <span class="keyword">or</span> <span class="keyword">from</span> stdin. psql s <span class="string">\copy</span> command also works <span class="keyword">for</span> anyone.</span><br></pre></td></tr></table></figure></p><p>赋权如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT pg_write_server_files <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT ROLE</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT SELECT ON francs.t_copy <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure></p><p>再次测试成功，如下<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11;</span><br><span class="line">psql (<span class="number">11</span>beta3)</span><br><span class="line">Type <span class="string">"help"</span> for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">COPY</span><span class="bash"> francs.t_copy TO <span class="string">'/home/pg11/t_copy2.txt'</span>;</span></span><br><span class="line"><span class="bash">COPY 2</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">francs=&gt; \! cat <span class="string">'/home/pg11/t_copy2.txt'</span></span></span><br><span class="line"><span class="bash">1       a</span></span><br><span class="line"><span class="bash">2       b</span></span><br></pre></td></tr></table></figure></p><p>可见，已将数据导出到数据库服务端上的文件。</p><h1 id="pg-execute-server-program"><a href="#pg-execute-server-program" class="headerlink" title="pg_execute_server_program"></a>pg_execute_server_program</h1><p>pg_execute_server_program 角色具有执行数据库服务端的程序权限，以file_fdw外部表举例如下。</p><p>首先准备数据文件，将 t_copy 文件进行压缩，如下:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ cat t_copy<span class="selector-class">.txt</span> </span><br><span class="line"><span class="number">1</span>       a</span><br><span class="line"><span class="number">2</span>       b</span><br><span class="line"></span><br><span class="line">[pg11@pghost2 ~]$ gzip t_copy.txt</span><br></pre></td></tr></table></figure></p><p>创建 file_fdw 外部扩展和外部表，以超级用户postgres登录francs库，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs postgres</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# CREATE EXTENSION file_fdw;</span><br><span class="line">CREATE EXTENSION</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# CREATE<span class="built_in"> SERVER </span>srv_file FOREIGN DATA WRAPPER file_fdw ;</span><br><span class="line">CREATE SERVER</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=# GRANT USAGE ON FOREIGN<span class="built_in"> SERVER </span>srv_file <span class="keyword">TO</span> role11;</span><br><span class="line">GRANT</span><br></pre></td></tr></table></figure></p><p>以普通用户role11登录francs库，创建带OPTIONS(program)选项的外部表，如下:<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs role11</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line">francs=&gt; CREATE FOREIGN TABLE ft_t_copy(id int4,name text) SERVER srv_file OPTIONS(program 'gunzip &lt; /home/pg11/t_copy.txt.gz');</span><br><span class="line"><span class="keyword">ERROR:  </span>only superuser or a member of the pg_execute_server_program role may specify the program option of a file_fdw foreign table</span><br></pre></td></tr></table></figure></p><p>以上报错，提示需要 superuser 或 pg_execute_server_program 权限才有权限指定 file_fdw 外部表的 program 选项。</p><p>将 pg_execute_server_program 角色赋予 role11用户，注意以下以postgres超级用户执行。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=# GRANT pg_execute_server_program TO role11;</span><br><span class="line"><span class="attribute">GRANT ROLE</span></span><br></pre></td></tr></table></figure></p><p>再次以role11用户登录francs库测试，如下:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; CREATE FOREIGN TABLE ft<span class="emphasis">_t_</span>copy(id int4,name text) SERVER srv<span class="emphasis">_file OPTIONS(program 'gunzip &lt; /home/pg11/t_</span>copy.txt.gz');</span><br><span class="line">CREATE FOREIGN TABLE</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT * FROM ft<span class="emphasis">_t_</span>copy ;</span><br><span class="line"><span class="code"> id | name </span></span><br><span class="line">----+------</span><br><span class="line"><span class="code">  1 | a</span></span><br><span class="line"><span class="code">  2 | b</span></span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure></p><p>创建带带OPTIONS(program)选项的外部表成功。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> pg_read_server_files、pg_write_server_files、pg_execute_server_program 角色涉及到读写数据库服务端文件，权限较大，分配此角色权限给数据库用户时需谨慎考虑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/default-roles.html#DEFAULT-ROLES-TABLE" target="_blank" rel="noopener">Default Roles</a></li><li><a href="https://paquier.xyz/postgresql-2/postgres-11-new-system-roles/" target="_blank" rel="noopener">Postgres 11 highlight - New System Roles</a></li><li><a href="https://postgres.fun/20110915133126.html">PostgreSQL9.1新特性之三：基于文件访问的 SQL/MED</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 新增三个默认系统角色，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pg_read_server_files&lt;/li&gt;
&lt;li&gt;pg_write_server_files&lt;/li&gt;
&lt;li&gt;pg_execute_server_program&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: Indexs With Include Columns </title>
    <link href="https://postgres.fun/20180930094300.html"/>
    <id>https://postgres.fun/20180930094300.html</id>
    <published>2018-09-30T01:43:45.000Z</published>
    <updated>2018-09-30T02:29:43.004Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本索引方面一个显著的新特性是创建索引时支持 INCLUDE COLUMNS ，语法如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_name <span class="keyword">ON</span> table_name <span class="keyword">USING</span> BTREE (column_a) <span class="keyword">INCLUDE</span> (column_b);</span><br></pre></td></tr></table></figure></p><h1 id="一、Release-中的说明"><a href="#一、Release-中的说明" class="headerlink" title="一、Release 中的说明"></a>一、Release 中的说明</h1><blockquote><p>Allow indexes to INCLUDE columns that are not part of the unique constraint but are available for index-only scans (Anastasia Lubennikova, Alexander Korotkov, Teodor Sigaev)</p></blockquote><p> This is also useful for including columns that dont have btree support</p><p>此特性主要用途和使用场景：</p><ul><li>如果字段不支持btree索引，可以使用INCLUDE方式索引。</li><li>使表上的更多SQL能走 Index-Only Scans。</li></ul><p>以上描述颇为费力，以下通过实例演示。</p><h1 id="二、验证-不支持Btree索引的字段，使用Include方式索引"><a href="#二、验证-不支持Btree索引的字段，使用Include方式索引" class="headerlink" title="二、验证: 不支持Btree索引的字段，使用Include方式索引"></a>二、验证: 不支持Btree索引的字段，使用Include方式索引</h1><p>首先验证第一点：不支持Btree索引的字段支持使用INCLUDE方式索引，创建测试表。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; CREATE <span class="keyword">TABLE</span> t_json1(a <span class="comment">serial, user_info json)</span>;</span><br><span class="line">CREATE <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure></p><p>在(a,user_info) 字段上创建 btree 索引，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt;  CREATE INDEX t_json1_idx1 ON t_json1 USING BTREE(a,user_info);</span><br><span class="line">ERROR:  data<span class="built_in"> type </span>json has <span class="literal">no</span><span class="built_in"> default </span>operator class <span class="keyword">for</span> access method <span class="string">"btree"</span></span><br><span class="line">HINT:  You must specify an operator class <span class="keyword">for</span> the index <span class="keyword">or</span> define a<span class="built_in"> default </span>operator class <span class="keyword">for</span> the data type.</span><br></pre></td></tr></table></figure></p><p>以上创建索引报错，是由于 json 不支持 btree 索引。</p><p>使用 INCLUDE 方式创建索引成功，如下:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> t_json1_idx_include <span class="keyword">ON</span> t_json1 <span class="keyword">USING</span> btree(a) <span class="keyword">INCLUDE</span>(user_info);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><h1 id="三、验证-Include-Columns-支持-Index-Only-Scans"><a href="#三、验证-Include-Columns-支持-Index-Only-Scans" class="headerlink" title="三、验证: Include Columns 支持 Index-Only Scans"></a>三、验证: Include Columns 支持 Index-Only Scans</h1><p>创建测试表并插入300万数据，如下：<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CREATE TABLE t_include(<span class="name">a</span> int4, name text)<span class="comment">;</span></span></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> INSERT INTO t_include(<span class="name">a</span>,name) SELECT n,n || '_INCLUDE TEST' FROM generate_series(<span class="number">1</span>,<span class="number">3000000</span>) n<span class="comment">;</span></span></span><br><span class="line">INSERT 0 3000000</span><br></pre></td></tr></table></figure></p><p>在字段a上创建索引，如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_include_a <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>where条件中只包含a，查询a字段，以下SQL走了 Index Only Scan。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt;  EXPLAIN ANALYZE SELECT a <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                           QUERY PLAN</span><br><span class="line">--------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Only Scan using idx_t_include_a on t_include  (<span class="attribute">cost</span>=0.43..8.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.017..0.018 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line">   Heap Fetches: 4</span><br><span class="line"> Planning Time: 0.272 ms</span><br><span class="line"> Execution Time: 0.038 ms</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure></p><p>加入 name 字段后，不走 Index Only Scan，如下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt;  EXPLAIN ANALYZE SELECT a,name <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                         QUERY PLAN</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Scan using idx_t_include_a on t_include  (<span class="attribute">cost</span>=0.43..8.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=24) (actual <span class="attribute">time</span>=0.005..0.007 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line"> Planning Time: 0.125 ms</span><br><span class="line"> Execution Time: 0.025 ms</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure></p><p>加入 name 后走了 Index Scan using ，根据索引回表查询name字段。</p><p>创建索引时使用 INCLUDE(name)，如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_include <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a) <span class="keyword">INCLUDE</span> (name);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>再次执行查询，走了 Index Only Scan</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; VACUUM ANALYZE t_include;</span><br><span class="line">VACUUM</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT a,name <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                          QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Only Scan using idx_t_include on t_include  (<span class="attribute">cost</span>=0.43..4.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=24) (actual <span class="attribute">time</span>=0.017..0.018 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line">   Heap Fetches: 0</span><br><span class="line"> Planning Time: 0.175 ms</span><br><span class="line"> Execution Time: 0.038 ms</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure><p>只查询name字段，也走了 Index Only Scan，如下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT name <span class="keyword">FROM</span> t_include WHERE a&lt;5;</span><br><span class="line">                                                          QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Index Only Scan using idx_t_include on t_include  (<span class="attribute">cost</span>=0.43..4.50 <span class="attribute">rows</span>=4 <span class="attribute">width</span>=20) (actual <span class="attribute">time</span>=0.012..0.014 <span class="attribute">rows</span>=4 <span class="attribute">loops</span>=1)</span><br><span class="line">   Index Cond: (a &lt; 5)</span><br><span class="line">   Heap Fetches: 0</span><br><span class="line"> Planning Time: 0.163 ms</span><br><span class="line"> Execution Time: 0.038 ms</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure></p><h1 id="四、Include-索引的限制"><a href="#四、Include-索引的限制" class="headerlink" title="四、Include 索引的限制"></a>四、Include 索引的限制</h1><ul><li>目前只有 Btree 索引支持 INCLUDE COLUMNS(INCLUDE中的字段物理上位于btree索引叶子节点)。</li><li>INCLUDE COLUMNS 中的字段不支持函数索引。</li><li>INCLUDE COLUMNS 中的字段数据类型可以不支持 btree 索引，例如 JSON 等数据类型。</li></ul><h1 id="五、两种索引方式差异"><a href="#五、两种索引方式差异" class="headerlink" title="五、两种索引方式差异"></a>五、两种索引方式差异</h1><p>或许有朋友问以下两种索引方式有啥区别？ 这个问题欢迎大家留言讨论。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_not_include <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a,<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t_include <span class="keyword">ON</span> t_include <span class="keyword">USING</span> BTREE (a) <span class="keyword">INCLUDE</span> (<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></p><h1 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/sql-createindex.html" target="_blank" rel="noopener">CREATE INDEX</a></li><li><a href="https://paquier.xyz/postgresql-2/postgres-11-covering-indexes/" target="_blank" rel="noopener">Postgres 11 highlight - Covering Indexes</a></li><li><a href="https://www.depesz.com/2018/04/26/waiting-for-postgresql-11-indexes-with-include-columns-and-their-support-in-b-tree/" target="_blank" rel="noopener">WAITING FOR POSTGRESQL 11 – INDEXES WITH INCLUDE COLUMNS AND THEIR SUPPORT IN B-TREE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本索引方面一个显著的新特性是创建索引时支持 INCLUDE COLUMNS ，语法如下&lt;br&gt;&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 新增非空默认值字段不需要重写表</title>
    <link href="https://postgres.fun/20180929100400.html"/>
    <id>https://postgres.fun/20180929100400.html</id>
    <published>2018-09-29T02:04:49.000Z</published>
    <updated>2018-09-30T07:17:57.405Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 10 版本前表新增不带默认值的DDL不需要重写表，只需要更新数据字典，因此DDL能瞬间执行，如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> flag <span class="built_in">text</span>;</span><br></pre></td></tr></table></figure><p>如果新增的字段带默认值，则需要重写表，表越大，执行时间越长，如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> flag <span class="built_in">text</span> <span class="keyword">DEFAULT</span> <span class="string">'default values'</span>;</span><br></pre></td></tr></table></figure><p>生产环境下给大表添加带 Default 值的字段将非常吃力，通常分两步进行：</p><ol><li>第一步: 先添加不带 Default值的字段。</li><li>第二步: 写函数批量刷新新增字段的默认值。</li></ol><p>上述第二步比较麻烦，也可以在业务低谷或申请停服窗口一次性完成带DEFAUL值字段的新增。</p><p>PostgreSQL 11 版本这方面进一步增强，表新增带非空默认值的字段不再需要重写表，Release 中的说明如下：</p><h1 id="Release中的说明"><a href="#Release中的说明" class="headerlink" title="Release中的说明"></a>Release中的说明</h1><blockquote><p>Allow ALTER TABLE to add a column with a non-null default without a table rewrite</p></blockquote><p>本文分别在 10 版本和 11 版本进行测试。</p><h1 id="PostgreSQL-10-版本"><a href="#PostgreSQL-10-版本" class="headerlink" title="PostgreSQL 10 版本"></a>PostgreSQL 10 版本</h1><p>创建测试表并插入1000万数据，如下。<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg10@pghost1 ~]$ psql mydb pguser</span><br><span class="line">psql (10.<span class="number">0</span>)</span><br><span class="line"><span class="built_in">Type</span> <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">CREATE</span> TABLE t1(id int4, name text);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (id,name ) <span class="keyword">SELECT</span> n, n || <span class="string">'_ALTER TABLE TEST '</span> <span class="keyword">FROM</span> generate_series (<span class="number">1</span>,<span class="number">10000000</span>) n;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">mydb=&gt; <span class="keyword">ANALYZE</span> t1;</span><br><span class="line">ANALYZE</span><br></pre></td></tr></table></figure></p><p>查看表的 relfilenode 和 relpages 信息，relfilenode 表示表的物理文件号。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       25672 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>新增带默认值的非空字段，如下。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; \timing</span><br><span class="line">Timing is on.</span><br><span class="line"></span><br><span class="line">mydb=&gt; ALTER TABLE t1 ADD COLUMN flag text DEFAULT 'abcdefg';</span><br><span class="line">ALTER TABLE</span><br><span class="line"><span class="keyword">Time:</span> 15540.002 ms (00:15.540)</span><br></pre></td></tr></table></figure></p><p>执行时间较长，需要15秒左右。</p><p>表分析后再次查看表的 relfilenode 和 relpages信息<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; ANALYZE t1;</span><br><span class="line">ANALYZE</span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       25679 |    83334</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>发现 relfilenode 有变化 ，之前的 relfilenode 值为 25672 ，说明表被重写。另一方面 relpages 变大了。</p><h1 id="PostgreSQL-11-版本"><a href="#PostgreSQL-11-版本" class="headerlink" title="PostgreSQL 11 版本"></a>PostgreSQL 11 版本</h1><p>创建测试表并插入1000万数据，如下。<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[pg11@pghost2 ~]$ psql francs francs</span><br><span class="line">psql (11beta3)</span><br><span class="line">Type "help" for help.</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CREATE TABLE t<span class="number">1</span>(<span class="name">id</span> int4, name text)<span class="comment">;</span></span></span><br><span class="line">CREATE TABLE</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> INSERT INTO t<span class="number">1</span> (<span class="name">id</span>,name ) SELECT n, n || '_ALTER TABLE TEST ' FROM generate_series (<span class="number">1</span>,<span class="number">10000000</span>) n<span class="comment">;</span></span></span><br><span class="line">INSERT 0 10000000</span><br><span class="line"></span><br><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> ANALYZE t<span class="number">1</span><span class="comment">;</span></span></span><br><span class="line">ANALYZE</span><br></pre></td></tr></table></figure></p><p>查看表的 relfilenode 和 relpages信息，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       16802 |    73530</span><br></pre></td></tr></table></figure></p><p>新增带默认值的非空字段，如下。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; \timing</span><br><span class="line">Timing is on.</span><br><span class="line"></span><br><span class="line">francs=&gt; ALTER TABLE t1 ADD COLUMN flag text DEFAULT 'abcdefg';</span><br><span class="line">ALTER TABLE</span><br><span class="line"><span class="keyword">Time:</span> 40.743 ms</span><br></pre></td></tr></table></figure></p><p>执行时间只需要 40 ms，瞬间完成。</p><p>表分析后再次查看表的 relfilenode 和 relpages信息<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; ANALYZE t1;</span><br><span class="line">ANALYZE</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       16802 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>发现 relfilenode 没有变化，依然是 16802，同时 relpages 也没有变化。</p><h1 id="增加1000字段"><a href="#增加1000字段" class="headerlink" title="增加1000字段"></a>增加1000字段</h1><p>PostgreSQL 11 版本给表 t1 增加了一个带默认值的字段后表占用空间没有变化，是不是增加的字段数不够多？接着往下测试，增加1000个带默认值的字段，看看情况如何？</p><p>创建测试表并插入1000万测试数据，如下:<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">DROP</span> TABLE t1;</span><br><span class="line"><span class="keyword">DROP</span> TABLE</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">CREATE</span> TABLE t1(id int4, name text);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (id,name ) <span class="keyword">SELECT</span> n, n || <span class="string">'_ALTER TABLE TEST '</span> <span class="keyword">FROM</span> generate_series (<span class="number">1</span>,<span class="number">10000000</span>) n;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">ANALYZE</span> t1;</span><br><span class="line">ANALYZE</span><br></pre></td></tr></table></figure></p><p>查看表的 relfilenode 和 relpages信息，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       34187 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>查看表大小，如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT pg<span class="emphasis">_size_</span>pretty(pg<span class="emphasis">_relation_</span>size(<span class="emphasis">'t1'</span>));</span><br><span class="line"><span class="code"> pg_size_pretty</span></span><br><span class="line">----------------</span><br><span class="line"><span class="code"> 574 MB</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>创建函数，此函数用来给表 t1 添加 1000 个带默认值的字段，如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span>  add_column() <span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span>  <span class="keyword">AS</span>  $<span class="keyword">BODY</span>$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    column_name       <span class="built_in">text</span>;</span><br><span class="line">    default_value     text;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">     default_value:= <span class="keyword">repeat</span>(<span class="keyword">md5</span>(<span class="string">'1'</span>),<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">       FOR i in 1..1000 LOOP</span><br><span class="line">         column_name:= 'flag' || i;</span><br><span class="line">         <span class="keyword">EXECUTE</span>  $$ <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> $$ || column_name  || $$ <span class="built_in">text</span> <span class="keyword">default</span><span class="string">' $$ || default_value  || $$'</span>$$ ;</span><br><span class="line">       <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">       RETURN 1;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$<span class="keyword">BODY</span>$  <span class="keyword">LANGUAGE</span> <span class="string">'plpgsql'</span>;</span><br></pre></td></tr></table></figure></p><p>执行函数，如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">francs</span>=&gt; <span class="keyword">SELECT </span><span class="keyword">add_column();</span></span><br><span class="line"><span class="keyword"> </span><span class="keyword">add_column</span></span><br><span class="line"><span class="keyword">------------</span></span><br><span class="line"><span class="keyword"> </span>         <span class="number">1</span></span><br><span class="line">(<span class="number">1</span> row)</span><br></pre></td></tr></table></figure></p><p>这时表t1已增加了1000个字段，如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM t1 LIMIT <span class="number">1</span>;</span><br><span class="line">-----------------------------------------[ RECORD <span class="number">1</span> ]-----------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">id       | <span class="type">1</span></span><br><span class="line">name     | <span class="type">1_ALTER</span> TABLE TEST</span><br><span class="line">flag1    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag2    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag3    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag4    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag5    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag6    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">flag7    |  <span class="type">c4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849bc4ca4238a0b923820dcc509a6f75849b</span></span><br><span class="line">...省略</span><br></pre></td></tr></table></figure></p><p>查看表 relfilenode 和 relpages，没有变化。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT relname,relfilenode, relpages <span class="keyword">FROM</span> pg_class WHERE <span class="attribute">relname</span>=<span class="string">'t1'</span>;</span><br><span class="line"> relname | relfilenode | relpages</span><br><span class="line">---------+-------------+----------</span><br><span class="line"> t1      |       34187 |    73530</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>再次确认表大小，依然还是 574MB。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT pg<span class="emphasis">_size_</span>pretty(pg<span class="emphasis">_relation_</span>size(<span class="emphasis">'t1'</span>));</span><br><span class="line"><span class="code"> pg_size_pretty</span></span><br><span class="line">----------------</span><br><span class="line"><span class="code"> 574 MB</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>从以上看出给表t1增加了1000个带默认值的字段后，t1表大小依然没有变化。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.depesz.com/2018/04/04/waiting-for-postgresql-11-fast-alter-table-add-column-with-a-non-null-default/" target="_blank" rel="noopener">WAITING FOR POSTGRESQL 11 – FAST ALTER TABLE ADD COLUMN WITH A NON-NULL DEFAULT</a></li><li><a href="https://github.com/digoal/blog/blob/master/201805/20180518_01.md" target="_blank" rel="noopener">PostgreSQL 11 preview - 添加非空默认值不需要 rewrite table - online add column with default value</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 10 版本前表新增不带默认值的DDL不需要重写表，只需要更新数据字典，因此DDL能瞬间执行，如下:&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 支持存储过程(SQL Stored Procedures)</title>
    <link href="https://postgres.fun/20180925162500.html"/>
    <id>https://postgres.fun/20180925162500.html</id>
    <published>2018-09-25T08:25:48.000Z</published>
    <updated>2018-09-25T09:00:25.654Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本一个重量级新特性是对存储过程的支持，同时支持存储过程嵌入事务，存储过程是很多 PostgreSQL 从业者期待已久的特性，尤其是很多从Oracle转到PostgreSQL朋友，尽管PostgreSQL提供函数可以实现大多数存储过程的功能，但在函数中无法执行事务实现部分提交，换句话说，函数中的SQL要么都执行成功，要不全部返回失败。</p><p>PostgreSQL 11 版本对存储过程的支持，从兼容层面考虑和Oracle的兼容性进一步增强，本文演示下PostgreSQL存储过程的创建和调用，并且演示存储过程支持嵌入事务样例。</p><h1 id="发行说明"><a href="#发行说明" class="headerlink" title="发行说明"></a>发行说明</h1><blockquote><p>SQL stored procedures, with support for embedded transactions</p></blockquote><h1 id="存储过程创建语法"><a href="#存储过程创建语法" class="headerlink" title="存储过程创建语法"></a>存储过程创建语法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span> ] <span class="keyword">PROCEDURE</span></span><br><span class="line">    <span class="keyword">name</span> ( [ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> | = &#125; default_expr ] [, ...] ] )</span><br><span class="line">  &#123; <span class="keyword">LANGUAGE</span> lang_name</span><br><span class="line">    | TRANSFORM &#123; <span class="keyword">FOR</span> <span class="keyword">TYPE</span> type_name &#125; [, ... ]</span><br><span class="line">    | [ <span class="keyword">EXTERNAL</span> ] <span class="keyword">SECURITY</span> INVOKER | [ <span class="keyword">EXTERNAL</span> ] <span class="keyword">SECURITY</span> DEFINER</span><br><span class="line">    | <span class="keyword">SET</span> configuration_parameter &#123; <span class="keyword">TO</span> <span class="keyword">value</span> | = <span class="keyword">value</span> | <span class="keyword">FROM</span> <span class="keyword">CURRENT</span> &#125;</span><br><span class="line">    | <span class="keyword">AS</span> <span class="string">'definition'</span></span><br><span class="line">    | <span class="keyword">AS</span> <span class="string">'obj_file'</span>, <span class="string">'link_symbol'</span></span><br><span class="line">  &#125; ...</span><br></pre></td></tr></table></figure><h1 id="存储过程调用语法"><a href="#存储过程调用语法" class="headerlink" title="存储过程调用语法"></a>存储过程调用语法</h1><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL name ( <span class="string">[ argument ]</span> <span class="string">[, ...]</span> )</span><br></pre></td></tr></table></figure><p>存储过程调用比较简单，使用 <code>CALL</code> 命令即可，而函数的调用是使用 <code>SELECT</code> 命令。</p><h1 id="存储过程嵌入事务测试"><a href="#存储过程嵌入事务测试" class="headerlink" title="存储过程嵌入事务测试"></a>存储过程嵌入事务测试</h1><p>创建一个简单的存储过程演示下。</p><h2 id="创建测试表"><a href="#创建测试表" class="headerlink" title="创建测试表"></a>创建测试表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (<span class="keyword">id</span> int4);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1_log (ctime <span class="keyword">timestamp</span>(<span class="number">6</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone , operation <span class="built_in">text</span>,ins_values int4);</span><br></pre></td></tr></table></figure><h2 id="创建存储过程-ins-t1"><a href="#创建存储过程-ins-t1" class="headerlink" title="创建存储过程 ins_t1"></a>创建存储过程 ins_t1</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> ins_t1(a <span class="built_in">integer</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(<span class="keyword">id</span>) <span class="keyword">VALUES</span>(a);</span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1_log(ctime,operation,ins_values) <span class="keyword">VALUES</span> (clock_timestamp(),<span class="string">'INSERT'</span>,a);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> <span class="string">'plpgsql'</span>;</span><br></pre></td></tr></table></figure><p>调用存储过程 ins_t1()，如下<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CALL ins_t<span class="number">1</span>(<span class="number">1</span>)<span class="comment">;</span></span></span><br><span class="line">CALL</span><br></pre></td></tr></table></figure></p><p>查看表 t1 和 t1_log 记录。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM t1;</span><br><span class="line"><span class="code"> id</span></span><br><span class="line">----</span><br><span class="line"><span class="code">  1</span></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT * FROM t1<span class="emphasis">_log;</span></span><br><span class="line"><span class="emphasis">           ctime            | operation | ins_</span>values</span><br><span class="line">----------------------------<span class="code">+-----------+</span>------------</span><br><span class="line"><span class="code"> 2018-09-25 15:08:16.026122 | INSERT    |          1</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>以上看出两条SQL都已提交。</p><h2 id="创建存储过程-ins-t1-part"><a href="#创建存储过程-ins-t1-part" class="headerlink" title="创建存储过程  ins_t1_part"></a>创建存储过程  ins_t1_part</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> ins_t1_part(a <span class="built_in">integer</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1(<span class="keyword">id</span>) <span class="keyword">VALUES</span>(a);</span><br><span class="line">      <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1_log(ctime,operation,ins_values) <span class="keyword">VALUES</span> (clock_timestamp(),<span class="string">'INSERT'</span>,a);</span><br><span class="line">      <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> <span class="string">'plpgsql'</span>;</span><br></pre></td></tr></table></figure><p>调用存储过程 ins_t1_part()，如下<br><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">francs=&gt;</span><span class="clojure"> CALL ins_t<span class="number">1</span>_part(<span class="number">2</span>)<span class="comment">;</span></span></span><br><span class="line">CALL</span><br></pre></td></tr></table></figure></p><p>查看表 t1 和 t1_log 记录。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM t1;</span><br><span class="line"><span class="code"> id</span></span><br><span class="line">----</span><br><span class="line"><span class="code">  1</span></span><br><span class="line"><span class="code">  2</span></span><br><span class="line">(2 rows)</span><br><span class="line"></span><br><span class="line">francs=&gt; SELECT * FROM t1<span class="emphasis">_log;</span></span><br><span class="line"><span class="emphasis">           ctime            | operation | ins_</span>values</span><br><span class="line">----------------------------<span class="code">+-----------+</span>------------</span><br><span class="line"><span class="code"> 2018-09-25 15:08:16.026122 | INSERT    |          1</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>发现 t1 表的数据已提交，而 t1_log 表的数据没有提交，验证了存储过程支持嵌入式事务。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/sql-createprocedure.html" target="_blank" rel="noopener">CREATE PROCEDURE</a></li><li><a href="https://www.cybertec-postgresql.com/en/tech-preview-postgresql-11-create-procedure/" target="_blank" rel="noopener">TECH PREVIEW: POSTGRESQL 11 – CREATE PROCEDURE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本一个重量级新特性是对存储过程的支持，同时支持存储过程嵌入事务，存储过程是很多 PostgreSQL 从业者期待已久的特性，尤其是很多从Oracle转到PostgreSQL朋友，尽管PostgreSQL提供函数可以实现大多数存储过程的功能，但在
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="PostgreSQL" scheme="https://postgres.fun/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11：支持并行哈希连接(Parallel Hash Joins)</title>
    <link href="https://postgres.fun/20180924134200.html"/>
    <id>https://postgres.fun/20180924134200.html</id>
    <published>2018-09-24T05:42:27.000Z</published>
    <updated>2018-09-24T05:52:42.159Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本在并行方面得到增强，例如支持并行创建索引(Parallel Index Build)、并行哈希连接(Parallel Hash Join)、并行 <code>CREATE TABLE .. AS</code>等，<a href="https://postgres.fun/20180922222100.html">上篇博客</a>介绍了并行创建索引，本文介绍并行 Hash Join。</p><h1 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h1><p>创建大表t_big并插入5000万条数据。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_big(</span><br><span class="line"><span class="keyword">id</span> int4,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">create_time <span class="keyword">timestamp</span> <span class="keyword">without</span> <span class="keyword">time</span> zone );</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_big(<span class="keyword">id</span>,<span class="keyword">name</span>,create_time)</span><br><span class="line"><span class="keyword">SELECT</span> n, n|| <span class="string">'_test'</span>,clock_timestamp() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">50000000</span>) n ;</span><br></pre></td></tr></table></figure></p><p>创建小表t_small并插入800万条数据<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_small(<span class="keyword">id</span> int4, <span class="keyword">name</span> <span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_small(<span class="keyword">id</span>,<span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">SELECT</span> n, n|| <span class="string">'_small'</span> <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">8000000</span>) n ;</span><br></pre></td></tr></table></figure></p><h1 id="验证并行哈希连接"><a href="#验证并行哈希连接" class="headerlink" title="验证并行哈希连接"></a>验证并行哈希连接</h1><p>PostgreSQL 10 版本查看以下SQL执行计划，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">des</span>=&gt; EXPLAIN SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                      QUERY PLAN</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=151870.58..661385.28 <span class="attribute">rows</span>=4143 <span class="attribute">width</span>=13)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   -&gt;  Hash Join  (<span class="attribute">cost</span>=150870.58..659970.98 <span class="attribute">rows</span>=1036 <span class="attribute">width</span>=13)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..470246.58 <span class="attribute">rows</span>=10358258 <span class="attribute">width</span>=4)</span><br><span class="line">         -&gt;  Hash  (<span class="attribute">cost</span>=150860.58..150860.58 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17)</span><br><span class="line">               -&gt;  Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..150860.58 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure><p>PostgreSQL 11 版本查看以下SQL执行计划，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                       QUERY PLAN</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=76862.42..615477.60 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=13)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   -&gt;  Parallel Hash Join  (<span class="attribute">cost</span>=75862.42..614397.60 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=13)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..491660.86 <span class="attribute">rows</span>=12499686 <span class="attribute">width</span>=4)</span><br><span class="line">         -&gt;  Parallel Hash  (<span class="attribute">cost</span>=75859.92..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17)</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">(8 rows)</span><br></pre></td></tr></table></figure></p><p>对比10版本的执行计划，不同之处为11版本走了 <strong>Parallel Hash Join</strong>，而 10 版本走的 <strong>Hash Join</strong>，<strong>Parallel Hash Join</strong> 为 11 版本的新特性。</p><h1 id="并行哈希连接性能测试"><a href="#并行哈希连接性能测试" class="headerlink" title="并行哈希连接性能测试"></a>并行哈希连接性能测试</h1><p>开启并行哈希连接相比不开启性能上有何变化？接着测试。</p><h2 id="开启并行哈希连接"><a href="#开启并行哈希连接" class="headerlink" title="开启并行哈希连接"></a>开启并行哈希连接</h2><p>PostgreSQL 11 版本执行以下SQL，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                                                QUERY PLAN</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=76862.42..615477.60 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=197.399..2738.010 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=1)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   Workers Launched: 4</span><br><span class="line">   -&gt;  Parallel Hash Join  (<span class="attribute">cost</span>=75862.42..614397.60 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=2222.347..2729.943 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..491660.86 <span class="attribute">rows</span>=12499686 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.038..1330.836 <span class="attribute">rows</span>=10000000 <span class="attribute">loops</span>=5)</span><br><span class="line">         -&gt;  Parallel Hash  (<span class="attribute">cost</span>=75859.92..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=191.484..191.484 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">               Buckets: 1024  Batches: 1  Memory Usage: 40kB</span><br><span class="line">               -&gt;  Parallel Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..75859.92 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=152.436..191.385 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">                     Rows Removed by Filter: 1599980</span><br><span class="line"> Planning Time: 0.183 ms</span><br><span class="line"> Execution Time: 2738.068 ms</span><br><span class="line">(13 rows)</span><br></pre></td></tr></table></figure></p><p>以上SQL执行多次，取最快时间，执行时间为 2738.068 ms。</p><h2 id="关闭并行哈希连接"><a href="#关闭并行哈希连接" class="headerlink" title="关闭并行哈希连接"></a>关闭并行哈希连接</h2><p>会话级设置enable_parallel_hash参数为off表示关闭并行哈希连接，测试性能有何变化，如下。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; <span class="builtin-name">set</span> enable_parallel_hash = off;</span><br><span class="line">SET</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; EXPLAIN ANALYZE SELECT t_small.name</span><br><span class="line">  <span class="keyword">FROM</span> t_big JOIN t_small ON (t_big.id = t_small.id)</span><br><span class="line">       <span class="keyword">AND</span> t_small.id &lt; 100;</span><br><span class="line">                                                                QUERY PLAN</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attribute">cost</span>=151869.66..690486.34 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=996.137..3496.940 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=1)</span><br><span class="line">   Workers Planned: 4</span><br><span class="line">   Workers Launched: 4</span><br><span class="line">   -&gt;  Hash Join  (<span class="attribute">cost</span>=150869.66..689406.34 <span class="attribute">rows</span>=200 <span class="attribute">width</span>=13) (actual <span class="attribute">time</span>=2990.847..3490.557 <span class="attribute">rows</span>=20 <span class="attribute">loops</span>=5)</span><br><span class="line">         Hash Cond: (t_big.id = t_small.id)</span><br><span class="line">         -&gt;  Parallel Seq Scan on t_big  (<span class="attribute">cost</span>=0.00..491660.86 <span class="attribute">rows</span>=12499686 <span class="attribute">width</span>=4) (actual <span class="attribute">time</span>=0.240..1392.062 <span class="attribute">rows</span>=10000000 <span class="attribute">loops</span>=5)</span><br><span class="line">         -&gt;  Hash  (<span class="attribute">cost</span>=150859.66..150859.66 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=890.943..890.943 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=5)</span><br><span class="line">               Buckets: 1024  Batches: 1  Memory Usage: 13kB</span><br><span class="line">               -&gt;  Seq Scan on t_small  (<span class="attribute">cost</span>=0.00..150859.66 <span class="attribute">rows</span>=800 <span class="attribute">width</span>=17) (actual <span class="attribute">time</span>=884.288..890.906 <span class="attribute">rows</span>=99 <span class="attribute">loops</span>=5)</span><br><span class="line">                     Filter: (id &lt; 100)</span><br><span class="line">                     Rows Removed by Filter: 7999901</span><br><span class="line"> Planning Time: 0.154 ms</span><br><span class="line"> Execution Time: 3496.982 ms</span><br><span class="line">(13 rows)</span><br></pre></td></tr></table></figure><p>以上SQL执行多次，取最快时间，从以上看出，关闭并行哈希连接时SQL的执行时间为 3496.982 ms ，相比开启并行哈希连接执行时间长了 27%。</p><p>可见开启并行哈希连接后，性能有较大幅度提升。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://postgres.fun/20180922222100.html">PostgreSQL11：支持并行创建索引(Parallel Index Builds)</a></li><li><a href="https://postgres.fun/20170521162007.html">PostgreSQL10：Parallel Queries 增强</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本在并行方面得到增强，例如支持并行创建索引(Parallel Index Build)、并行哈希连接(Parallel Hash Join)、并行 &lt;code&gt;CREATE TABLE .. AS&lt;/code&gt;等，&lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Parallel Query" scheme="https://postgres.fun/tags/Parallel-Query/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11：支持并行创建索引(Parallel Index Builds)</title>
    <link href="https://postgres.fun/20180922222100.html"/>
    <id>https://postgres.fun/20180922222100.html</id>
    <published>2018-09-22T14:21:38.000Z</published>
    <updated>2018-09-24T05:46:21.808Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 版本在并行方面得到增强，例如支持并行创建索引、并行Hash Join、并行 <code>CREATE TABLE .. AS</code>等，本文先介绍并行创建索引。</p><p>PostgreSQL 11 版本并行创建索引仅支持 B-tree 索引，其它类型索引现阶段不支持并行创建。</p><h1 id="并行进程相关参数"><a href="#并行进程相关参数" class="headerlink" title="并行进程相关参数"></a>并行进程相关参数</h1><p>介绍并行创建索引之前先来看看并行进程的相关 postgresql.conf 参数。</p><ul><li><p>max_parallel_maintenance_workers<br>max_parallel_maintenance_workers 参数设置维护命令(例如 CREATE INDEX) 命令允许的最大并行进程数，默认值为2。</p></li><li><p>max_parallel_workers<br>设置系统支持的最大并行进程数，默认值为8。</p></li><li><p>max_worker_processes<br>设置数据库的最大后台进程数，默认值为8。</p></li><li><p>max_parallel_workers_per_gather<br>设置单个Gather或Gather Merge节点能够启用的最大并行进程数，默认值为2，并行查询(Parallel Query)的并行度受此参数的影响，CREATE INDEX 命令的并行度不受此参数影响。</p></li></ul><p>以上参数可能并不容易理解，进一步解释如下：</p><ol><li>max_worker_processes 参数设置的是数据库允许的最大后台进程数，并行进程属于后台进程的一种；</li><li>max_parallel_workers 参数设置数据库允许的最大并行进程数，这个值小于或等于 max_worker_processes。</li><li>并行进程数设置分为两类，第一类是并行查询，并行查询的并行度由 max_parallel_workers_per_gather 参数控制，第二类是维护命令(例如 CREATE INDEX)，维护命令的并行度由 max_parallel_maintenance_workers 参数控制。</li><li>max_parallel_workers_per_gather+max_parallel_maintenance_workers值应小于或等于 max_parallel_workers。</li></ol><p>postgresql.conf 设置以下并行度参数如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">max_worker_processes = 16               <span class="comment"># (change requires restart)</span></span><br><span class="line">max_parallel_maintenance_workers = 4    <span class="comment"># taken from max_parallel_workers</span></span><br><span class="line">max_parallel_workers_per_gather = 4     <span class="comment"># taken from max_parallel_workers</span></span><br><span class="line">max_parallel_workers = 8</span><br></pre></td></tr></table></figure></p><h1 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h1><p>创建测试表big并插入3000万条数据，如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">big</span>(user_id int4,user_name <span class="built_in">text</span>,ctime <span class="keyword">timestamp</span>(<span class="number">6</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone <span class="keyword">default</span> clock_timestamp() );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">big</span>(user_id,user_name) <span class="keyword">SELECT</span>  n ,n || <span class="string">'_data'</span> <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">30000000</span>) n;;</span><br></pre></td></tr></table></figure></p><h1 id="并行创建索引"><a href="#并行创建索引" class="headerlink" title="并行创建索引"></a>并行创建索引</h1><p>在会话级设置max_parallel_maintenance_workers值为4。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">set</span> max_parallel_maintenance_workers <span class="comment">=4</span>;</span><br><span class="line"><span class="keyword">SET</span></span><br></pre></td></tr></table></figure></p><p>创建索引，如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_big_ctime <span class="keyword">ON</span> big <span class="keyword">USING</span> BTREE(ctime);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>在主机上通过 top 命令可以看到 CREATE INDEX 命令的进程号为 21164，并且开启了4个并发子进程。</p><p><img src="/images/pg11_parallel_1.png" alt=""></p><h1 id="创建索引并行度测试"><a href="#创建索引并行度测试" class="headerlink" title="创建索引并行度测试"></a>创建索引并行度测试</h1><p>设置 max_parallel_maintenance_workers 值不同并行度，测试并行索引创建的时间。</p><p>本测试环境为一台4核8GB内存的虚机，测试结果如下：</p><table><thead><tr><th style="text-align:center">max_parallel_maintenance_workers</th><th style="text-align:center">索引创建时间(毫秒)</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">14938.738</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">10469.283</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">10439.237</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">11577.147</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">17020.216</td></tr></tbody></table><p>从以上看出，当 max_parallel_maintenance_workers 值为4时索引创建时间出现拐点。</p><h1 id="关闭指定表并行创建索引"><a href="#关闭指定表并行创建索引" class="headerlink" title="关闭指定表并行创建索引"></a>关闭指定表并行创建索引</h1><p>通过前面介绍大家知道可通过设置max_parallel_maintenance_workers参数为0关闭所有表的并行创建索引，如何关闭指定表的并行索引创建呢？</p><p>可通过 ALTER TABLE 方式禁止表上的并行创建索引，如下禁止表big上的所有并行创建索引。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; ALTER TABLE big <span class="builtin-name">SET</span> (<span class="attribute">parallel_workers</span>=0);</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure></p><p>如果想恢复指定表上的parallel_workers参数设置，使用 RESET 选项即可，如下：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; ALTER <span class="keyword">TABLE</span> big <span class="comment">RESET(parallel_workers)</span>;</span><br><span class="line">ALTER <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/sql-createtable.html" target="_blank" rel="noopener">CREATE TABLE</a></li><li><a href="https://www.depesz.com/2018/02/12/waiting-for-postgresql-11-support-parallel-btree-index-builds/" target="_blank" rel="noopener">WAITING FOR POSTGRESQL 11 – SUPPORT PARALLEL BTREE INDEX BUILDS.</a></li><li><a href="https://postgres.fun/20170521162007.html">PostgreSQL10：Parallel Queries 增强</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 版本在并行方面得到增强，例如支持并行创建索引、并行Hash Join、并行 &lt;code&gt;CREATE TABLE .. AS&lt;/code&gt;等，本文先介绍并行创建索引。&lt;/p&gt;
&lt;p&gt;PostgreSQL 11 版本并行创建索引仅支持 B-tree
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Parallel Query" scheme="https://postgres.fun/tags/Parallel-Query/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库迁移PostgreSQL实践</title>
    <link href="https://postgres.fun/20180921202900.html"/>
    <id>https://postgres.fun/20180921202900.html</id>
    <published>2018-09-21T12:29:25.000Z</published>
    <updated>2018-09-26T13:03:43.754Z</updated>
    
    <content type="html"><![CDATA[<p>前几年杭州PostgreSQL交流会上分享了一个MySQL数据库迁移到PostgreSQL的案例，虽然时间有些久了，仍有参考意义，方便有需要的朋友。</p><p>这个PPT在我的百度网盘上可下载，如下：</p><p><a href="https://yun.baidu.com/s/1gdAC8rp" target="_blank" rel="noopener">Converting MySQL to PostgreSQL</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几年杭州PostgreSQL交流会上分享了一个MySQL数据库迁移到PostgreSQL的案例，虽然时间有些久了，仍有参考意义，方便有需要的朋友。&lt;/p&gt;
&lt;p&gt;这个PPT在我的百度网盘上可下载，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yun.baidu.
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="mysql_fdw" scheme="https://postgres.fun/tags/mysql-fdw/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 分区表增加 Default Partition</title>
    <link href="https://postgres.fun/20180921101300.html"/>
    <id>https://postgres.fun/20180921101300.html</id>
    <published>2018-09-21T02:13:17.000Z</published>
    <updated>2018-09-21T12:47:30.275Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL11: 分区表增加 Default Partition</p><p>PostgreSQL 10 版本当往分区表写入的数据不在分区定义范围内时会报错，无法插入数据，PostgreSQL 11 版本分区表增加了 Default 分区用来存储不满足分区定义范围的数据。</p><p>本节以创建范围分区表为例进行测试。</p><h1 id="PostgreSQL-10-版本"><a href="#PostgreSQL-10-版本" class="headerlink" title="PostgreSQL 10 版本"></a>PostgreSQL 10 版本</h1><p>在PostgreSQL 10 版本进行测试，详见以下。</p><h2 id="创建父表"><a href="#创建父表" class="headerlink" title="创建父表"></a>创建父表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log (</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">serial</span>,</span><br><span class="line"> create_time <span class="keyword">timestamp</span>(<span class="number">0</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone,</span><br><span class="line"> remark <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span>  <span class="keyword">RANGE</span>(create_time);</span><br></pre></td></tr></table></figure><h2 id="创建子表"><a href="#创建子表" class="headerlink" title="创建子表"></a>创建子表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_log_p201801 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> tbl_log <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2018-01-01'</span>) <span class="keyword">TO</span> (<span class="string">'2018-02-01'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_log_p201802 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> tbl_log <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2018-02-01'</span>) <span class="keyword">TO</span> (<span class="string">'2018-03-01'</span>);</span><br></pre></td></tr></table></figure><h2 id="插入测试"><a href="#插入测试" class="headerlink" title="插入测试"></a>插入测试</h2><p>PostgreSQL 10 版本插入一条不在分区定义范围的记录，如下<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; INSERT INTO tbl_log(id,create_time,remark) VALUES (3,'2018<span class="string">-03</span><span class="string">-01</span>','a');</span><br><span class="line"><span class="keyword">ERROR:  </span>no partition of relation "tbl_log" found for row</span><br><span class="line">DETAIL:  Partition key of the failing row contains (create_time) = (2018<span class="string">-03</span><span class="string">-01</span> 00:00:00).</span><br></pre></td></tr></table></figure></p><p>插入报错，提示找不到相应分区无法插入数据。</p><h1 id="PostgreSQL-11-版本"><a href="#PostgreSQL-11-版本" class="headerlink" title="PostgreSQL 11 版本"></a>PostgreSQL 11 版本</h1><p>PostgreSQL 11 版本支持创建 Default 分区，用来存储不满足分区定义的数据，测试如下。</p><h2 id="创建父表-1"><a href="#创建父表-1" class="headerlink" title="创建父表"></a>创建父表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log (</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">serial</span>,</span><br><span class="line"> create_time <span class="keyword">timestamp</span>(<span class="number">0</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone,</span><br><span class="line"> remark <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span>  <span class="keyword">RANGE</span>(create_time);</span><br></pre></td></tr></table></figure><h2 id="创建常规分区"><a href="#创建常规分区" class="headerlink" title="创建常规分区"></a>创建常规分区</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_log_p201801 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> tbl_log <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2018-01-01'</span>) <span class="keyword">TO</span> (<span class="string">'2018-02-01'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_log_p201802 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> tbl_log <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2018-02-01'</span>) <span class="keyword">TO</span> (<span class="string">'2018-03-01'</span>);</span><br></pre></td></tr></table></figure><h2 id="创建默认分区"><a href="#创建默认分区" class="headerlink" title="创建默认分区"></a>创建默认分区</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_log_default <span class="keyword">PARTITION</span> <span class="keyword">OF</span> tbl_log <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure><h2 id="查看表tbl-log定义"><a href="#查看表tbl-log定义" class="headerlink" title="查看表tbl_log定义"></a>查看表tbl_log定义</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; \d+ tbl_log</span><br><span class="line">                                                              Table <span class="string">"francs.tbl_log"</span></span><br><span class="line">   Column    |<span class="string">              Type              </span>|<span class="string"> Collation </span>|<span class="string"> Nullable </span>|<span class="string">               Default               </span>|<span class="string"> Storage  </span>|<span class="string"> Stats target</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> Description </span></span><br><span class="line"><span class="string">-------------+--------------------------------+-----------+----------+-------------------------------------+----------+--------------+-------------</span></span><br><span class="line"><span class="string"> id          </span>|<span class="string"> integer                        </span>|<span class="string">           </span>|<span class="string"> not null </span>|<span class="string"> nextval('tbl_log_id_seq'::regclass) </span>|<span class="string"> plain    </span>|<span class="string">             </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> create_time </span>|<span class="string"> timestamp(0) without time zone </span>|<span class="string">           </span>|<span class="string">          </span>|<span class="string">                                     </span>|<span class="string"> plain    </span>|<span class="string">             </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> remark      </span>|<span class="string"> character(1)                   </span>|<span class="string">           </span>|<span class="string">          </span>|<span class="string">                                     </span>|<span class="string"> extended </span>|<span class="string">             </span>|<span class="string"> </span></span><br><span class="line"><span class="string">Partition key: RANGE (create_time)</span></span><br><span class="line"><span class="string">Partitions: tbl_log_p201801 FOR VALUES FROM ('2018-01-01 00:00:00') TO ('2018-02-01 00:00:00'),</span></span><br><span class="line"><span class="string">            tbl_log_p201802 FOR VALUES FROM ('2018-02-01 00:00:00') TO ('2018-03-01 00:00:00'),</span></span><br><span class="line"><span class="string">            tbl_log_default DEFAULT</span></span><br></pre></td></tr></table></figure><p>以上看出 tbl_log 表包含三个分区，其中一个是 DEFAULT 分区。</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; INSERT INTO tbl_log(id,create_time,remark) VALUES (<span class="number">3</span>,'<span class="number">2018</span><span class="number">-03</span><span class="number">-01</span>','a');</span><br><span class="line">INSERT <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h2><p>可以直接查询子表数据验证，如下：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM tbl<span class="emphasis">_log_</span>default ;</span><br><span class="line"><span class="code"> id |     create_time     | remark </span></span><br><span class="line">----<span class="code">+---------------------+</span>--------</span><br><span class="line"><span class="code">  3 | 2018-03-01 00:00:00 | a</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>也可以统计各子表记录总数统计，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT table_name,count(*) </span><br><span class="line"><span class="keyword">FROM</span> tbl_log, LATERAL (</span><br><span class="line">SELECT relname <span class="keyword">FROM</span> pg_class WHERE pg_class.<span class="attribute">oid</span>=tbl_log.tableoid) AS  table_name</span><br><span class="line">GROUP BY table_name </span><br><span class="line">ORDER BY table_name;</span><br><span class="line">    table_name     | count </span><br><span class="line">-------------------+-------</span><br><span class="line"> (tbl_log_default) |     1</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>从以上测试看出，不满足分区定义的数据存储到了DEFAULT分区，那么问题来了，定义了DEFAULT分区的分区表如何添加分区？</p><h1 id="定义了Default分区的分区表如何添加分区？"><a href="#定义了Default分区的分区表如何添加分区？" class="headerlink" title="定义了Default分区的分区表如何添加分区？"></a>定义了Default分区的分区表如何添加分区？</h1><p>出于管理或业务需求，需要给分区表 tbl_log 新增 tbl_log_p201803 分区用来存储 2018年3月份的日志数据，如下。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; CREATE TABLE tbl_log_p201803 PARTITION OF tbl_log FOR VALUES FROM ('2018<span class="string">-03</span><span class="string">-01</span>') TO ('2018<span class="string">-04</span><span class="string">-01</span>');</span><br><span class="line"><span class="keyword">ERROR:  </span>updated partition constraint for default partition "tbl_log_default" would be violated by some row</span><br></pre></td></tr></table></figure></p><p>以上添加分区报错，需要解绑default分区，之后再添加，如下：</p><h2 id="解绑Default分区"><a href="#解绑Default分区" class="headerlink" title="解绑Default分区"></a>解绑Default分区</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; ALTER <span class="keyword">TABLE</span> tbl_log <span class="comment">DETACH PARTITION tbl_log_default</span>;</span><br><span class="line">ALTER <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><p>之后再创建新分区 tbl_log_p201803。</p><h2 id="创建新分区"><a href="#创建新分区" class="headerlink" title="创建新分区"></a>创建新分区</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> TABLE tbl_log_p201803 <span class="keyword">PARTITION</span> OF tbl_log <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">FROM</span> (<span class="string">'2018-03-01'</span>) <span class="keyword">TO</span> (<span class="string">'2018-04-01'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> TABLE</span><br></pre></td></tr></table></figure><p>分区创建成功，分区创建之后需把DEFAULT分区连接。</p><h2 id="连接Default分区"><a href="#连接Default分区" class="headerlink" title="连接Default分区"></a>连接Default分区</h2><p>连接DEFAULT分区报错，如下:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; ALTER TABLE tbl_log ATTACH PARTITION tbl_log_default DEFAULT;</span><br><span class="line">ERROR:  partition constraint is violated by some row</span><br></pre></td></tr></table></figure></p><p>以上是由于 2018-03-01 的记录存储在了DEFAULT分区上，根据分区规则这条记录应该存储到 tbl_log_p201803 分区。</p><p>需将 tbl_log_default 数据转移到 tbl_log_p201803 分区，如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt;  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_log_p201803 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_log_default ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">francs=&gt; <span class="keyword">DELETE</span> <span class="keyword">FROM</span>  tbl_log_default ;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>数据量大的话建议使用 TRUNCATE 清除数据，不产生垃圾数据。</p><p>再次连接DEFAULT分区成功，如下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; ALTER TABLE tbl_log ATTACH PARTITION tbl_log_default DEFAULT;</span><br><span class="line">ALTER TABLE</span><br></pre></td></tr></table></figure></p><h2 id="查看表定义"><a href="#查看表定义" class="headerlink" title="查看表定义"></a>查看表定义</h2><p>再次查看分区表定义，<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; \d+ tbl_log</span><br><span class="line">                                                              Table <span class="string">"francs.tbl_log"</span></span><br><span class="line">   Column    |<span class="string">              Type              </span>|<span class="string"> Collation </span>|<span class="string"> Nullable </span>|<span class="string">               Default               </span>|<span class="string"> Storage  </span>|<span class="string"> Stats target</span></span><br><span class="line"><span class="string"> </span>|<span class="string"> Description </span></span><br><span class="line"><span class="string">-------------+--------------------------------+-----------+----------+-------------------------------------+----------+-------------</span></span><br><span class="line"></span><br><span class="line"><span class="string"> id          </span>|<span class="string"> integer                        </span>|<span class="string">           </span>|<span class="string"> not null </span>|<span class="string"> nextval('tbl_log_id_seq'::regclass) </span>|<span class="string"> plain    </span>|<span class="string">              </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> create_time </span>|<span class="string"> timestamp(0) without time zone </span>|<span class="string">           </span>|<span class="string">          </span>|<span class="string">                                     </span>|<span class="string"> plain    </span>|<span class="string">              </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> remark      </span>|<span class="string"> character(1)                   </span>|<span class="string">           </span>|<span class="string">          </span>|<span class="string">                                     </span>|<span class="string"> extended </span>|<span class="string">              </span>|<span class="string"> </span></span><br><span class="line"><span class="string">Partition key: RANGE (create_time)</span></span><br><span class="line"><span class="string">Partitions: tbl_log_p201801 FOR VALUES FROM ('2018-01-01 00:00:00') TO ('2018-02-01 00:00:00'),</span></span><br><span class="line"><span class="string">            tbl_log_p201802 FOR VALUES FROM ('2018-02-01 00:00:00') TO ('2018-03-01 00:00:00'),</span></span><br><span class="line"><span class="string">            tbl_log_p201803 FOR VALUES FROM ('2018-03-01 00:00:00') TO ('2018-04-01 00:00:00'),</span></span><br><span class="line"><span class="string">            tbl_log_default DEFAULT</span></span><br></pre></td></tr></table></figure></p><p>tbl_log_p201803 分区添加成功。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>PostgreSQL 11 版本分区表增加了DEFAULT分区，支持将不满足分区定义的数据存储到默认分区。</li><li>对于添加了DEFAULT分区的分区表如果想增加分区，需参照“解绑DEFAULT分区，创建新分区，转移分区数据，连接DEFAULT分区”的步骤进行。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://postgres.fun/20180920082700.html">PostgreSQL11: 分区表增加哈希分区</a></li><li><a href="https://postgres.fun/20180920155600.html">PostgreSQL11: 分区表支持创建主键、外键、索引</a></li><li><a href="https://postgres.fun/20180920214600.html">PostgreSQL11: 分区表支持UPDATE分区键</a></li><li><a href="https://postgres.fun/20180921101300.html">PostgreSQL11: 分区表增加 Default Partition</a></li><li><a href="https://pgdash.io/blog/partition-postgres-11.html" target="_blank" rel="noopener">PostgreSQL11: Partitioning Improvements</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL11: 分区表增加 Default Partition&lt;/p&gt;
&lt;p&gt;PostgreSQL 10 版本当往分区表写入的数据不在分区定义范围内时会报错，无法插入数据，PostgreSQL 11 版本分区表增加了 Default 分区用来存储不满足分区定义范
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Partition Table" scheme="https://postgres.fun/tags/Partition-Table/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 分区表支持UPDATE分区键</title>
    <link href="https://postgres.fun/20180920214600.html"/>
    <id>https://postgres.fun/20180920214600.html</id>
    <published>2018-09-20T13:46:22.000Z</published>
    <updated>2018-09-23T14:13:41.526Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 10 版本已支持分区表，但不支持分区表根据分区键UPDATE记录，PostgreSQL 11 版本这方面得到增加，当分区表的分区键字段被UPDATE后，会自动将该记录转移至新的分区中。</p><p>官网Release说明如下：</p><blockquote><p>UPDATE statements that change a partition key now move affected rows to the appropriate partitions</p></blockquote><p>本文以UPDATE列表分区表分区键为例进行演示。</p><h1 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h1><p>创建列表分区表并插入测试数据，为演示做准备。</p><h2 id="创建父表"><a href="#创建父表" class="headerlink" title="创建父表"></a>创建父表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">    city_id      bigserial <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span>         <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    population   <span class="built_in">bigint</span></span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">LIST</span> (<span class="keyword">left</span>(<span class="keyword">lower</span>(<span class="keyword">name</span>), <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h2 id="创建子表"><a href="#创建子表" class="headerlink" title="创建子表"></a>创建子表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities_a <span class="keyword">PARTITION</span> <span class="keyword">OF</span> cities ( <span class="keyword">CONSTRAINT</span> city_id_nonzero <span class="keyword">CHECK</span> (city_id != <span class="number">0</span>)) <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities_b <span class="keyword">PARTITION</span> <span class="keyword">OF</span> cities ( <span class="keyword">CONSTRAINT</span> city_id_nonzero <span class="keyword">CHECK</span> (city_id != <span class="number">0</span>)) <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities_c <span class="keyword">PARTITION</span> <span class="keyword">OF</span> cities ( <span class="keyword">CONSTRAINT</span> city_id_nonzero <span class="keyword">CHECK</span> (city_id != <span class="number">0</span>)) <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure><h2 id="插入测试数据"><a href="#插入测试数据" class="headerlink" title="插入测试数据"></a>插入测试数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities(city_id,<span class="keyword">name</span>,population) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'a_city'</span>,<span class="string">'100000'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities(city_id,<span class="keyword">name</span>,population) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">'b_city'</span>,<span class="string">'200000'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities(city_id,<span class="keyword">name</span>,population) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'c_city'</span>,<span class="string">'300000'</span>);</span><br></pre></td></tr></table></figure><h1 id="PostgreSQL-10-测试"><a href="#PostgreSQL-10-测试" class="headerlink" title="PostgreSQL 10 测试"></a>PostgreSQL 10 测试</h1><p>PostgreSQL 10 版本UPDATE分区键报错，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mydb</span>=&gt; SELECT version();</span><br><span class="line">                                                 version</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line"> PostgreSQL 10.0 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-11), 64-bit</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">mydb</span>=&gt; UPDATE cities <span class="builtin-name">SET</span> <span class="attribute">name</span>=<span class="string">'ca_city'</span> WHERE <span class="attribute">city_id</span>=1;</span><br><span class="line">ERROR:  new row <span class="keyword">for</span> relation <span class="string">"cities_a"</span> violates partition constraint</span><br><span class="line">DETAIL:  Failing row contains (1, ca_city, 100000).</span><br></pre></td></tr></table></figure></p><h1 id="PostgreSQL-11-测试"><a href="#PostgreSQL-11-测试" class="headerlink" title="PostgreSQL 11 测试"></a>PostgreSQL 11 测试</h1><p>PostgreSQL 11 版本支持更新分区键，如下:<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT version();</span><br><span class="line"><span class="code">                                                  version</span></span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="code"> PostgreSQL 11beta3 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-11), 64-bit</span></span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">francs=&gt; UPDATE cities SET name=<span class="emphasis">'ca_city'</span> WHERE city<span class="emphasis">_id=1;</span></span><br><span class="line"><span class="emphasis">UPDATE 1</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">francs=&gt; SELECT * FROM cities;</span></span><br><span class="line"><span class="emphasis"> city_</span>id |  name   | population</span><br><span class="line">---------<span class="code">+---------+</span>------------</span><br><span class="line"><span class="code">       2 | b_city  |     200000</span></span><br><span class="line"><span class="code">       3 | c_city  |     300000</span></span><br><span class="line"><span class="code">       1 | ca_city |     100000</span></span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure></p><p>查看cities_c分区，发现city_id为1的记录已转移到此分区，如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * from cities_c;</span><br><span class="line"> city_id |  <span class="type">name</span>   | <span class="type">population</span></span><br><span class="line">---------+---------+------------</span><br><span class="line">       <span class="number">3</span> | <span class="type">c_city</span>  |     <span class="type">300000</span></span><br><span class="line">       <span class="number">1</span> | <span class="type">ca_city</span> |     <span class="type">100000</span></span><br><span class="line">(<span class="number">2</span> rows)</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://postgres.fun/20170521123452.html">PostgreSQL10: 重量级新特性-支持分区表</a></li><li><a href="https://postgres.fun/20180920082700.html">PostgreSQL11: 分区表增加哈希分区</a></li><li><a href="https://postgres.fun/20180920155600.html">PostgreSQL11: 分区表支持创建主键、外键、索引</a></li><li><a href="https://postgres.fun/20180920214600.html">PostgreSQL11: 分区表支持UPDATE分区键</a></li><li><a href="https://postgres.fun/20180921101300.html">PostgreSQL11: 分区表增加 Default Partition</a></li><li><a href="https://pgdash.io/blog/partition-postgres-11.html" target="_blank" rel="noopener">PostgreSQL11: Partitioning Improvements</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 10 版本已支持分区表，但不支持分区表根据分区键UPDATE记录，PostgreSQL 11 版本这方面得到增加，当分区表的分区键字段被UPDATE后，会自动将该记录转移至新的分区中。&lt;/p&gt;
&lt;p&gt;官网Release说明如下：&lt;/p&gt;
&lt;blockq
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Partition Table" scheme="https://postgres.fun/tags/Partition-Table/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11：分区表支持创建主键、外键、索引</title>
    <link href="https://postgres.fun/20180920155600.html"/>
    <id>https://postgres.fun/20180920155600.html</id>
    <published>2018-09-20T07:56:18.000Z</published>
    <updated>2018-09-23T14:14:04.403Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 10 版本虽然支持创建范围分区表和列表分区表，但创建过程依然比较繁琐，需要手工定义子表索引、主键，详见 <a href="https://postgres.fun/20170521123452.html">PostgreSQL10：重量级新特性-支持分区表</a>，PostgreSQL 11 版本得到增强，在父表上创建索引、主键、外键后，子表上将自动创建，本文演示这三种场景。</p><p>值得一提的是，11 版本之前 PostgreSQL 的分区表不支持全局主键，虽然可以在父表和子表上分别定义主键，但不支持全局主键，也就是说，父表和子表、子表和子表的主键数据可以重复。</p><p>手册上的 Release 说明</p><blockquote><p>Support for PRIMARY KEY, FOREIGN KEY, indexes, and triggers on partitioned tables</p></blockquote><p>本文以创建哈希分区表为例进行测试。</p><h1 id="测试环境准备"><a href="#测试环境准备" class="headerlink" title="测试环境准备"></a>测试环境准备</h1><p>创建分区表并插入测试数据，为后续测试做准备。</p><h2 id="创建父表"><a href="#创建父表" class="headerlink" title="创建父表"></a>创建父表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo (</span><br><span class="line"> userid    int4,</span><br><span class="line"> username  <span class="built_in">character</span> <span class="built_in">varying</span>(<span class="number">64</span>),</span><br><span class="line"> ctime   <span class="keyword">timestamp</span>(<span class="number">6</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(userid);</span><br></pre></td></tr></table></figure><h2 id="创建子表"><a href="#创建子表" class="headerlink" title="创建子表"></a>创建子表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo_p0 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> userinfo <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo_p1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> userinfo <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo_p2 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> userinfo <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">2</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> userinfo_p3 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> userinfo <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>给分区表插入100万数据，如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> userinfo(userid,username,ctime) <span class="keyword">SELECT</span> n, n || <span class="string">'_username'</span>,clock_timestamp() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">1000000</span>) n;</span><br></pre></td></tr></table></figure></p><h1 id="测试一-创建主键"><a href="#测试一-创建主键" class="headerlink" title="测试一: 创建主键"></a>测试一: 创建主键</h1><p>在父表上创建主键，如下。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> userinfo <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (userid);</span><br></pre></td></tr></table></figure></p><p>在父表上查看，如下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; \d userinfo</span><br><span class="line">                          Table <span class="string">"francs.userinfo"</span></span><br><span class="line">  Column  |             <span class="built_in"> Type </span>             | Collation | Nullable | Default</span><br><span class="line">----------+--------------------------------+-----------+----------+---------</span><br><span class="line"> userid   | integer                        |           | <span class="keyword">not</span> <span class="literal">null</span> |</span><br><span class="line"> username | character varying(64)          |           |          |</span><br><span class="line"> ctime    | timestamp(6) without time zone |           |          |</span><br><span class="line">Partition key: HASH (userid)</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"userinfo_pkey"</span> PRIMARY KEY, btree (userid)</span><br><span class="line">Number of partitions: 4 (Use \d+ <span class="keyword">to</span> list them.)</span><br></pre></td></tr></table></figure></p><p>查看子表，发现子表上也有了主键。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; \d userinfo_p0</span><br><span class="line">                         Table <span class="string">"francs.userinfo_p0"</span></span><br><span class="line">  Column  |             <span class="built_in"> Type </span>             | Collation | Nullable | Default</span><br><span class="line">----------+--------------------------------+-----------+----------+---------</span><br><span class="line"> userid   | integer                        |           | <span class="keyword">not</span> <span class="literal">null</span> |</span><br><span class="line"> username | character varying(64)          |           |          |</span><br><span class="line"> ctime    | timestamp(6) without time zone |           |          |</span><br><span class="line">Partition of: userinfo <span class="keyword">FOR</span> VALUES WITH (modulus 4, remainder 0)</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"userinfo_p0_pkey"</span> PRIMARY KEY, btree (userid)</span><br></pre></td></tr></table></figure></p><p>此主键为全局主键，子表间的主键之间不能有重复数据。</p><h1 id="测试二-创建索引"><a href="#测试二-创建索引" class="headerlink" title="测试二: 创建索引"></a>测试二: 创建索引</h1><p>在父表上创建索引，如下<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; <span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_userinfo_username <span class="keyword">ON</span> userinfo <span class="keyword">USING</span> BTREE(username);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure></p><p>发现父表和子表上都创建了索引，如下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; \d userinfo</span><br><span class="line">                          Table <span class="string">"francs.userinfo"</span></span><br><span class="line">  Column  |             <span class="built_in"> Type </span>             | Collation | Nullable | Default</span><br><span class="line">----------+--------------------------------+-----------+----------+---------</span><br><span class="line"> userid   | integer                        |           | <span class="keyword">not</span> <span class="literal">null</span> |</span><br><span class="line"> username | character varying(64)          |           |          |</span><br><span class="line"> ctime    | timestamp(6) without time zone |           |          |</span><br><span class="line">Partition key: HASH (userid)</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"userinfo_pkey"</span> PRIMARY KEY, btree (userid)</span><br><span class="line">    <span class="string">"idx_userinfo_username"</span> btree (username)</span><br><span class="line">Number of partitions: 4 (Use \d+ <span class="keyword">to</span> list them.)</span><br><span class="line"></span><br><span class="line"><span class="attribute">francs</span>=&gt; \d userinfo_p1</span><br><span class="line">                         Table <span class="string">"francs.userinfo_p1"</span></span><br><span class="line">  Column  |             <span class="built_in"> Type </span>             | Collation | Nullable | Default</span><br><span class="line">----------+--------------------------------+-----------+----------+---------</span><br><span class="line"> userid   | integer                        |           | <span class="keyword">not</span> <span class="literal">null</span> |</span><br><span class="line"> username | character varying(64)          |           |          |</span><br><span class="line"> ctime    | timestamp(6) without time zone |           |          |</span><br><span class="line">Partition of: userinfo <span class="keyword">FOR</span> VALUES WITH (modulus 4, remainder 1)</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"userinfo_p1_pkey"</span> PRIMARY KEY, btree (userid)</span><br><span class="line">    <span class="string">"userinfo_p1_username_idx"</span> btree (username)</span><br></pre></td></tr></table></figure></p><h1 id="测试三-创建外键"><a href="#测试三-创建外键" class="headerlink" title="测试三: 创建外键"></a>测试三: 创建外键</h1><p>例如两张表，supplier_groups 和 supplier 分别用来存储供应商分组和供应商信, 如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> supplier_groups(</span><br><span class="line">    <span class="keyword">group_id</span>    int4 PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    group_name  <span class="built_in">text</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> suppliers (</span><br><span class="line">    supplier_id    int4 PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    supplier_name  <span class="built_in">text</span>,</span><br><span class="line">    <span class="keyword">group_id</span>       int4 <span class="keyword">REFERENCES</span> supplier_groups(<span class="keyword">group_id</span>)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span> (supplier_id);</span><br></pre></td></tr></table></figure><h2 id="创建子表-1"><a href="#创建子表-1" class="headerlink" title="创建子表"></a>创建子表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> suppliers_p0 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> suppliers <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> suppliers_p1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> suppliers <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> suppliers_p2 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> suppliers <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">2</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> suppliers_p3 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> suppliers <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="查看子表"><a href="#查看子表" class="headerlink" title="查看子表"></a>查看子表</h2><p>查看子表，发现子表上也自动创建了外键。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; \d suppliers_p0</span><br><span class="line">               Table <span class="string">"francs.suppliers_p0"</span></span><br><span class="line">    Column     | <span class="built_in"> Type </span>  | Collation | Nullable | Default</span><br><span class="line">---------------+---------+-----------+----------+---------</span><br><span class="line"> supplier_id   | integer |           | <span class="keyword">not</span> <span class="literal">null</span> |</span><br><span class="line"> supplier_name | text    |           |          |</span><br><span class="line"> group_id      | integer |           |          |</span><br><span class="line">Partition of: suppliers <span class="keyword">FOR</span> VALUES WITH (modulus 4, remainder 0)</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"suppliers_p0_pkey"</span> PRIMARY KEY, btree (supplier_id)</span><br><span class="line">Foreign-key constraints:</span><br><span class="line">    <span class="string">"suppliers_group_id_fkey"</span> FOREIGN KEY (group_id) REFERENCES supplier_groups(group_id)</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上演示了 PostgreSQL 11 分区表在父表上创建索引、主键、外键后，子表会自动创建相应索引、主键、外键，相比10版本极大减少了分区表维护工作量。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://postgres.fun/20170521123452.html">PostgreSQL10: 重量级新特性-支持分区表</a></li><li><a href="https://postgres.fun/20180920082700.html">PostgreSQL11: 分区表增加哈希分区</a></li><li><a href="https://postgres.fun/20180920155600.html">PostgreSQL11: 分区表支持创建主键、外键、索引</a></li><li><a href="https://postgres.fun/20180920214600.html">PostgreSQL11: 分区表支持UPDATE分区键</a></li><li><a href="https://postgres.fun/20180921101300.html">PostgreSQL11: 分区表增加 Default Partition</a></li><li><a href="https://pgdash.io/blog/partition-postgres-11.html" target="_blank" rel="noopener">PostgreSQL11: Partitioning Improvements</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 10 版本虽然支持创建范围分区表和列表分区表，但创建过程依然比较繁琐，需要手工定义子表索引、主键，详见 &lt;a href=&quot;https://postgres.fun/20170521123452.html&quot;&gt;PostgreSQL10：重量级新特性-支持分
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Partition Table" scheme="https://postgres.fun/tags/Partition-Table/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL11: 分区表增加哈希分区</title>
    <link href="https://postgres.fun/20180920082700.html"/>
    <id>https://postgres.fun/20180920082700.html</id>
    <published>2018-09-20T00:27:30.000Z</published>
    <updated>2018-09-21T12:50:13.506Z</updated>
    
    <content type="html"><![CDATA[<p>PostgreSQL 11 Beta3 版本已经发布，最近忙于工作和家里事情没有研究，后面抽时间补上。</p><p>PostgreSQL 11 的一个重量级新特性为分区表得到较大增强，例如支持哈希分区(HASH)表，因此 PostgreSQL 支持范围分区(RANGE)、列表分区(LIST)、&gt;哈希分区(HASH)三种分区方式，本文简单演示下哈希分区表。</p><p><strong>Hash Partitioning</strong></p><blockquote><p>The table is partitioned by specifying a modulus and a remainder for each partition. Each partition will hold the rows for which the hash value of the partition key divided by the specified modulus will produce the specified remainder.</p></blockquote><p>Hash分区表的分区定义包含两个属性，如下：</p><ul><li>modulus: 指Hash分区个数。</li><li>remainder: 指Hash分区键取模余。</li></ul><h1 id="创建分区表语法"><a href="#创建分区表语法" class="headerlink" title="创建分区表语法"></a>创建分区表语法</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (  ...  )</span><br><span class="line">[ <span class="keyword">PARTITION</span> <span class="keyword">BY</span> &#123; <span class="keyword">RANGE</span> | <span class="keyword">LIST</span> | <span class="keyword">HASH</span> &#125;  (  &#123; column_name |  ( expression )  &#125;</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">OF</span> parent_table [  (</span><br><span class="line">)  ] <span class="keyword">FOR</span> <span class="keyword">VALUES</span> partition_bound_spec</span><br></pre></td></tr></table></figure><h1 id="创建数据生成函数"><a href="#创建数据生成函数" class="headerlink" title="创建数据生成函数"></a>创建数据生成函数</h1><p>为了便于生成测试数据，创建以下两个函数用来随机生成指定长度的字符串，创建 random_range(int4, int4) 函数如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> random_range(int4, int4)</span><br><span class="line"><span class="keyword">RETURNS</span> int4</span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line">    <span class="keyword">SELECT</span> ($<span class="number">1</span> + <span class="keyword">FLOOR</span>(($<span class="number">2</span> - $<span class="number">1</span> + <span class="number">1</span>) * random() ))::int4;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure></p><p>接着创建random_text_simple(length int4)函数，此函数会调用random_range(int4, int4)函数。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> random_text_simple(<span class="keyword">length</span> int4)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">text</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> PLPGSQL</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    possible_chars <span class="built_in">text</span> := <span class="string">'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;</span><br><span class="line">    output text := '';</span><br><span class="line">    i int4;</span><br><span class="line">    pos int4;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.length <span class="keyword">LOOP</span></span><br><span class="line">        pos := random_range(<span class="number">1</span>, <span class="keyword">length</span>(possible_chars));</span><br><span class="line">        output := output || substr(possible_chars, pos, 1);</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">    RETURN output;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure></p><p>random_text_simple(length int4)函数可以随机生成指定长度字符串，如下随机生成含三位字符的字符串。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT random<span class="emphasis">_text_</span>simple(3);</span><br><span class="line"><span class="code"> random_text_simple </span></span><br><span class="line">--------------------</span><br><span class="line"><span class="code"> LL9</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>随机生成含六位字符的字符串，如下所示：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mydb=&gt; SELECT random<span class="emphasis">_text_</span>simple(6);</span><br><span class="line"><span class="code"> random_text_simple </span></span><br><span class="line">--------------------</span><br><span class="line"><span class="code"> B81BPW</span></span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure></p><p>后面会用到这个函数生成测试数据。</p><h1 id="创建哈希分区父表"><a href="#创建哈希分区父表" class="headerlink" title="创建哈希分区父表"></a>创建哈希分区父表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line"> stuname <span class="built_in">text</span> ,</span><br><span class="line"> ctime   <span class="keyword">timestamp</span>(<span class="number">6</span>) <span class="keyword">without</span> <span class="keyword">time</span> zone</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(stuname);</span><br></pre></td></tr></table></figure><p>创建索引<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_stuendt_stuname <span class="keyword">on</span> student <span class="keyword">using</span> btree(stuname);</span><br></pre></td></tr></table></figure></p><h1 id="创建子表"><a href="#创建子表" class="headerlink" title="创建子表"></a>创建子表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_p0 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> student <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_p1 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> student <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_p2 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> student <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">2</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_p3 <span class="keyword">PARTITION</span> <span class="keyword">OF</span> student <span class="keyword">FOR</span> <span class="keyword">VALUES</span> <span class="keyword">WITH</span>(MODULUS <span class="number">4</span>, <span class="keyword">REMAINDER</span> <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="查看分区表定义"><a href="#查看分区表定义" class="headerlink" title="查看分区表定义"></a>查看分区表定义</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; \d+ student</span><br><span class="line">                                              Table <span class="string">"francs.student"</span></span><br><span class="line"> Column  |             <span class="built_in"> Type </span>             | Collation | Nullable |<span class="built_in"> Default </span>| Storage  | Stats target | Description </span><br><span class="line">---------+--------------------------------+-----------+----------+---------+----------+--------------+-------------</span><br><span class="line"> stuname | text                           |           |          |         | extended |              | </span><br><span class="line"> ctime   | timestamp(6) without time zone |           |          |         | plain    |              | </span><br><span class="line">Partition key: HASH (stuname)</span><br><span class="line">Indexes:</span><br><span class="line">    <span class="string">"idx_stuendt_stuname"</span> btree (stuname)</span><br><span class="line">Partitions: student_p0 <span class="keyword">FOR</span> VALUES WITH (modulus 4, remainder 0),</span><br><span class="line">            student_p1 <span class="keyword">FOR</span> VALUES WITH (modulus 4, remainder 1),</span><br><span class="line">            student_p2 <span class="keyword">FOR</span> VALUES WITH (modulus 4, remainder 2),</span><br><span class="line">            student_p3 <span class="keyword">FOR</span> VALUES WITH (modulus 4, remainder 3)</span><br></pre></td></tr></table></figure><p>从以上看出表 student 和它的四个分区。</p><h1 id="插入测试数据"><a href="#插入测试数据" class="headerlink" title="插入测试数据"></a>插入测试数据</h1><p>使用之前创建的函数 random_text_simple() 生成100万测试数据，如下。<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(stuname,ctime) <span class="keyword">SELECT</span> random_text_simple(<span class="number">6</span>),clock_timestamp() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>,<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure></p><h1 id="查看分区表数据"><a href="#查看分区表数据" class="headerlink" title="查看分区表数据"></a>查看分区表数据</h1><p>表数据如下<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">francs=&gt; SELECT * FROM student LIMIT 3;</span><br><span class="line"><span class="code"> stuname |        ctime        </span></span><br><span class="line">---------+---------------------</span><br><span class="line"><span class="code"> 4JJOPN  | 2018-09-20 10:45:06</span></span><br><span class="line"><span class="code"> NHQONC  | 2018-09-20 10:45:06</span></span><br><span class="line"><span class="code"> 8V5BGH  | 2018-09-20 10:45:06</span></span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure></p><p>统计分区数据量<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">francs</span>=&gt; SELECT tableoid::regclass,count(*) <span class="keyword">from</span> student<span class="built_in"> group </span>by 1 order by 1;</span><br><span class="line">  tableoid  | count  </span><br><span class="line">------------+--------</span><br><span class="line"> student_p0 | 250510</span><br><span class="line"> student_p1 | 249448</span><br><span class="line"> student_p2 | 249620</span><br><span class="line"> student_p3 | 250422</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure></p><p>可见数据均匀分布到了四个分区。</p><h1 id="根据分区键查询"><a href="#根据分区键查询" class="headerlink" title="根据分区键查询"></a>根据分区键查询</h1><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">francs=&gt;</span> EXPLAIN ANALYZE SELECT * FROM student WHERE <span class="attr">stuname='3LXBEV';</span></span><br><span class="line">                                                                QUERY PLAN                                                          </span><br><span class="line">      </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> Append  (<span class="attr">cost=0.42..8.44</span> <span class="attr">rows=1</span> <span class="attr">width=15)</span> (actual <span class="attr">time=0.017..0.018</span> <span class="attr">rows=1</span> <span class="attr">loops=1)</span></span><br><span class="line">   -&gt;  Index Scan using student_p3_stuname_idx on student_p3  (<span class="attr">cost=0.42..8.44</span> <span class="attr">rows=1</span> <span class="attr">width=15)</span> (actual <span class="attr">time=0.017..0.017</span> <span class="attr">rows=1</span> <span class="attr">loops=1)</span></span><br><span class="line">         Index Cond: (<span class="attr">stuname</span> = '<span class="number">3</span>LXBEV'::text)</span><br><span class="line"> Planning Time: <span class="number">0.198</span> ms</span><br><span class="line"> Execution Time: <span class="number">0.042</span> ms</span><br><span class="line">(<span class="number">5</span> rows)</span><br></pre></td></tr></table></figure><p>根据分区键stuname查询仅扫描分区 student_p3，并走了索引。</p><h1 id="根据非分区键查询"><a href="#根据非分区键查询" class="headerlink" title="根据非分区键查询"></a>根据非分区键查询</h1><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">francs=&gt;</span> EXPLAIN ANALYZE SELECT * FROM student WHERE <span class="attr">ctime='2018-09-20</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">55.48392</span>';</span><br><span class="line">                                                          QUERY PLAN                                                           </span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (<span class="attr">cost=1000.00..13761.36</span> <span class="attr">rows=4</span> <span class="attr">width=15)</span> (actual <span class="attr">time=37.891..39.183</span> <span class="attr">rows=1</span> <span class="attr">loops=1)</span></span><br><span class="line">   Workers Planned: <span class="number">2</span></span><br><span class="line">   Workers Launched: <span class="number">2</span></span><br><span class="line">   -&gt;  Parallel Append  (<span class="attr">cost=0.00..12760.96</span> <span class="attr">rows=4</span> <span class="attr">width=15)</span> (actual <span class="attr">time=23.753..35.006</span> <span class="attr">rows=0</span> <span class="attr">loops=3)</span></span><br><span class="line">         -&gt;  Parallel Seq Scan on student_p0  (<span class="attr">cost=0.00..3196.99</span> <span class="attr">rows=1</span> <span class="attr">width=15)</span> (actual <span class="attr">time=0.014..28.550</span> <span class="attr">rows=1</span> <span class="attr">loops=1)</span></span><br><span class="line">               Filter: (<span class="attr">ctime</span> = '<span class="number">2018</span>-<span class="number">09</span>-<span class="number">20</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">55.48392</span>'::timestamp without time zone)</span><br><span class="line">               Rows Removed by Filter: <span class="number">250509</span></span><br><span class="line">         -&gt;  Parallel Seq Scan on student_p3  (<span class="attr">cost=0.00..3195.34</span> <span class="attr">rows=1</span> <span class="attr">width=15)</span> (actual <span class="attr">time=29.543..29.543</span> <span class="attr">rows=0</span> <span class="attr">loops=1)</span></span><br><span class="line">               Filter: (<span class="attr">ctime</span> = '<span class="number">2018</span>-<span class="number">09</span>-<span class="number">20</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">55.48392</span>'::timestamp without time zone)</span><br><span class="line">               Rows Removed by Filter: <span class="number">250422</span></span><br><span class="line">         -&gt;  Parallel Seq Scan on student_p2  (<span class="attr">cost=0.00..3185.44</span> <span class="attr">rows=1</span> <span class="attr">width=15)</span> (actual <span class="attr">time=8.260..8.260</span> <span class="attr">rows=0</span> <span class="attr">loops=3)</span></span><br><span class="line">               Filter: (<span class="attr">ctime</span> = '<span class="number">2018</span>-<span class="number">09</span>-<span class="number">20</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">55.48392</span>'::timestamp without time zone)</span><br><span class="line">               Rows Removed by Filter: <span class="number">83207</span></span><br><span class="line">         -&gt;  Parallel Seq Scan on student_p1  (<span class="attr">cost=0.00..3183.18</span> <span class="attr">rows=1</span> <span class="attr">width=15)</span> (actual <span class="attr">time=22.135..22.135</span> <span class="attr">rows=0</span> <span class="attr">loops=1)</span></span><br><span class="line">               Filter: (<span class="attr">ctime</span> = '<span class="number">2018</span>-<span class="number">09</span>-<span class="number">20</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">55.48392</span>'::timestamp without time zone)</span><br><span class="line">               Rows Removed by Filter: <span class="number">249448</span></span><br><span class="line"> Planning Time: <span class="number">0.183</span> ms</span><br><span class="line"> Execution Time: <span class="number">39.219</span> ms</span><br><span class="line">(<span class="number">18</span> rows)</span><br></pre></td></tr></table></figure><p>根据非分区键ctime查询扫描了分区表所有分区。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文演示了 PostgreSQL 哈希分区表的创建、测试数据的生成导入和查询计划，后面博客演示分区表增强的其它方面。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.postgresql.org/docs/11/static/sql-createtable.html" target="_blank" rel="noopener">CREATE TABLE </a></li><li><a href="https://www.postgresql.org/docs/11/static/ddl-partitioning.html" target="_blank" rel="noopener">Table Partitioning</a></li><li><a href="https://www.depesz.com/2017/11/10/waiting-for-postgresql-11-add-hash-partitioning/" target="_blank" rel="noopener">WAITING FOR POSTGRESQL 11 – ADD HASH PARTITIONING</a></li><li><a href="https://postgres.fun/20180920082700.html">PostgreSQL11: 分区表增加哈希分区</a></li><li><a href="https://postgres.fun/20180920155600.html">PostgreSQL11: 分区表支持创建主键、外键、索引</a></li><li><a href="https://postgres.fun/20180920214600.html">PostgreSQL11: 分区表支持UPDATE分区键</a></li><li><a href="https://postgres.fun/20180921101300.html">PostgreSQL11: 分区表增加 Default Partition</a></li><li><a href="https://pgdash.io/blog/partition-postgres-11.html" target="_blank" rel="noopener">PostgreSQL11: Partitioning Improvements</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PostgreSQL 11 Beta3 版本已经发布，最近忙于工作和家里事情没有研究，后面抽时间补上。&lt;/p&gt;
&lt;p&gt;PostgreSQL 11 的一个重量级新特性为分区表得到较大增强，例如支持哈希分区(HASH)表，因此 PostgreSQL 支持范围分区(RANGE)、
      
    
    </summary>
    
      <category term="Postgres基础" scheme="https://postgres.fun/categories/Postgres%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Partition Table" scheme="https://postgres.fun/tags/Partition-Table/"/>
    
  </entry>
  
</feed>
